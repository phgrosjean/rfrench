#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: \n"
"PO-Revision-Date: \n"
"Last-Translator: Elise Maigné <elise.maigne@inrae.fr>\n"
"Language-Team: \n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.5\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 1 (code)
msgid ""
"title: \"Keys and fast binary search based subset\"\n"
"date: \"`r Sys.Date()`\"\n"
"output:\n"
"  markdown::html_format\n"
"vignette: >\n"
"  %\\VignetteIndexEntry{Keys and fast binary search based subset}\n"
"  %\\VignetteEngine{knitr::knitr}\n"
"  \\usepackage[utf8]{inputenc}\n"
msgstr ""
"title: \"Extraire des sous-ensemble avec les clés et la recherche binaire "
"rapide\"\n"
"date: \"`r Sys.Date()`\"\n"
"output:\n"
"  markdown::html_format\n"
"vignette: >\n"
"  %\\VignetteIndexEntry{Extraire des sous-ensemble avec les clés et la "
"recherche binaire rapide}\n"
"  %\\VignetteEngine{knitr::knitr}\n"
"  \\usepackage[utf8]{inputenc}\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 2 (code)
msgid ""
"#===== r, echo = FALSE, message = FALSE\n"
"require(data.table)\n"
"knitr::opts_chunk$set(\n"
"  comment = \"#\",\n"
"    error = FALSE,\n"
"     tidy = FALSE,\n"
"    cache = FALSE,\n"
" collapse = TRUE)\n"
".old.th = setDTthreads(1)\n"
msgstr ""
"#===== r, echo = FALSE, message = FALSE\n"
"require(data.table)\n"
"knitr::opts_chunk$set(\n"
"  comment = \"#\",\n"
"    error = FALSE,\n"
"     tidy = FALSE,\n"
"    cache = FALSE,\n"
" collapse = TRUE)\n"
".old.th = setDTthreads(1)\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 3 (paragraph)
msgid ""
"This vignette is aimed at those who are already familiar with *data.table* "
"syntax, its general form, how to subset rows in `i`, select and compute on "
"columns, add/modify/delete columns *by reference* in `j` and group by using "
"`by`. If you're not familiar with these concepts, please read the *"
"\"Introduction to data.table\"* and *\"Reference semantics\"* vignettes "
"first."
msgstr ""
"Cette vignette s'adresse à ceux qui sont déjà familiers avec la syntaxe de "
"*data.table*, sa forme générale, comment extraire des sous-ensembles de "
"lignes dans `i`, sélectionner et faire des opérations sur des colonnes, "
"ajouter/modifier/supprimer des colonnes *par référence* dans `j` et grouper "
"en utilisant `by`. Si vous n'êtes pas familier avec ces concepts, veuillez "
"d'abord lire les vignettes *\"Introduction à data.table\"* et *\"Sémantique "
"de référence\"*."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 4 (header)
msgid "Data {#data}"
msgstr "Données {#data}"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 5 (paragraph)
msgid ""
"We will use the same `flights` data as in the *\"Introduction to data.table"
"\"* vignette."
msgstr ""
"Nous utiliserons les mêmes données `flights` que dans la vignette *"
"\"Introduction à data.table\"*."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 6 (code)
msgid ""
"#===== r echo = FALSE\n"
"options(width = 100L)\n"
msgstr ""
"#===== r echo = FALSE\n"
"options(with = 100L)\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 7 (code)
msgid ""
"flights <- fread(\"flights14.csv\")\n"
"head(flights)\n"
"dim(flights)\n"
msgstr ""
"flights <- fread(\"../flights14.csv\")\n"
"head(flights)\n"
"dim(flights)\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 8 (header)
msgid "Introduction"
msgstr "Introduction"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 9 (paragraph)
msgid "In this vignette, we will"
msgstr "Dans cette vignette, nous allons"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 10 (paragraph)
msgid ""
"=====* first introduce the concept of `key` in *data.table*, and set and "
"use keys to perform *fast binary search* based subsets in `i`,====="
msgstr ""
"=====* introduire le concept de `clé` dans une *data.table*, définir et "
"utiliser des clés pour extraire des sous-ensembles basés sur une *recherche "
"binaire rapide* dans `i`,====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 11 (paragraph)
msgid ""
"=====* see that we can combine key based subsets along with `j` and `by` in "
"the exact same way as before,====="
msgstr ""
"=====* voir que nous pouvons combiner des sous-ensembles basés sur les clés "
"avec `j` et `by` exactement de la même manière que précédemment,====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 12 (paragraph)
msgid ""
"=====* look at other additional useful arguments - `mult` and `nomatch`,"
"====="
msgstr "=====* voir d'autres arguments utiles - `mult` et `nomatch`,====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 13 (paragraph)
msgid ""
"=====* and finally conclude by looking at the advantage of setting keys - "
"perform *fast binary search based subsets* and compare with the traditional "
"vector scan approach.====="
msgstr ""
"=====* et enfin conclure en examinant l'avantage de définir des clés - "
"extraire des *sous-ensembles basés sur la recherche binaire rapide* et "
"comparer avec l'approche traditionnelle du balayage vectoriel.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 14 (header)
msgid "1. Keys"
msgstr "1. Clés"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 15 (header)
msgid "a) What is a *key*?"
msgstr "a) Qu'est-ce qu'une *clé* ?"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 16 (paragraph)
msgid ""
"In the *\"Introduction to data.table\"* vignette, we saw how to subset rows "
"in `i` using logical expressions, row numbers and using `order()`. In this "
"section, we will look at another way of subsetting incredibly fast - using "
"*keys*."
msgstr ""
"Dans la vignette *\"Introduction à data.table\"*, nous avons vu comment "
"sous-diviser des lignes dans `i` en utilisant des expressions logiques, des "
"numéros de lignes et en utilisant `order()`. Dans cette section, nous "
"allons voir une autre façon d'extraire des sous-ensembles de façon "
"incroyablement rapide - en utilisant les *clés*."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 17 (paragraph)
msgid ""
"But first, let's start by looking at *data.frames*. All *data.frames* have "
"a row names attribute. Consider the *data.frame* `DF` below."
msgstr ""
"Mais tout d'abord, commençons par examiner les *data.frames*. Tous les "
"*data.frames* ont un attribut de noms de lignes (row names). Considérons le "
"*data.frame* `DF` ci-dessous."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 18 (code)
msgid ""
"set.seed(1L)\n"
"DF = data.frame(ID1 = sample(letters[1:2], 10, TRUE),\n"
"                ID2 = sample(1:3, 10, TRUE),\n"
"                val = sample(10),\n"
"                stringsAsFactors = FALSE,\n"
"                row.names = sample(LETTERS[1:10]))\n"
"DF\n"
"\n"
"rownames(DF)\n"
msgstr ""
"set.seed(1L)\n"
"DF = data.frame(ID1 = sample(letters[1:2], 10, TRUE),\n"
"                ID2 = sample(1:3, 10, TRUE),\n"
"                val = sample(10),\n"
"                stringsAsFactors = FALSE,\n"
"                row.names = sample(LETTERS[1:10]))\n"
"DF\n"
"\n"
"rownames(DF)\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 19 (paragraph)
msgid "We can *subset* a particular row using its row name as shown below:"
msgstr ""
"Nous pouvons récupérer un *sous-ensemble* composé d'une ligne particulière "
"en utilisant son nom de ligne comme indiqué ci-dessous :"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 20 (code)
msgid "DF[\"C\", ]\n"
msgstr "DF[\"C\", ]\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 21 (paragraph)
msgid ""
"i.e., row names are more or less *an index* to rows of a *data.frame*. "
"However,"
msgstr ""
"autrement dit, les noms de lignes sont plus ou moins *un indice* des lignes "
"d'un *data.frame*. Cependant,"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 22 (paragraph)
msgid "=====1. Each row is limited to *exactly one* row name.====="
msgstr "=====1. Chaque ligne est limitée à *exactement* un nom de ligne.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 23 (code)
msgid ""
"But, a person (for example) has at least two names - a *first* and a "
"*second* name. It is useful to organise a telephone directory by *surname* "
"then *first name*.\n"
msgstr ""
"Mais une personne (par exemple) a au moins deux noms - un *prénom* et un "
"*second* nom. Il est utile d'organiser un annuaire téléphonique par *nom* "
"puis *prénom*.\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 24 (paragraph)
msgid "=====2. And row names should be *unique*.====="
msgstr "=====2. Et les noms de ligne doivent être *uniques*.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 25 (code)
msgid ""
"```{chunk_with_args}\n"
"#===== r eval = FALSE\n"
"rownames(DF) = sample(LETTERS[1:5], 10, TRUE)\n"
"# Warning: non-unique values when setting 'row.names': 'C', 'D'\n"
"# Error in `.rowNamesDF<-`(x, value = value): duplicate 'row.names' are not "
"allowed\n"
"```\n"
msgstr ""
"```{chunk_with_args}\n"
"#===== r eval = FALSE\n"
"rownames(DF) = sample(LETTERS[1:5], 10, TRUE)\n"
"\n"
"# Warning: non-unique values when setting 'row.names': 'C', 'D'\n"
"# Error in `.rowNamesDF<-`(x, value = value): duplicate 'row.names' are not "
"allowed\n"
"```\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 26 (paragraph)
msgid "Now let's convert it to a *data.table*."
msgstr "Nous allons maintenant le convertir en *data.table*."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 27 (code)
msgid ""
"DT = as.data.table(DF)\n"
"DT\n"
"\n"
"rownames(DT)\n"
msgstr ""
"DT = as.data.table(DF)\n"
"DT\n"
"\n"
"rownames(DT)\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 28 (paragraph)
msgid "=====* Note that row names have been reset.====="
msgstr "=====* Notez que les noms des lignes ont été réinitialisés.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 29 (paragraph)
msgid ""
"=====* *data.tables* never uses row names. Since *data.tables* **inherit** "
"from *data.frames*, it still has the row names attribute. But it never uses "
"them. We'll see in a moment as to why.====="
msgstr ""
"=====* Les *data.tables* n'utilisent jamais de noms de ligne. Puisque les "
"*data.tables* **héritent** des *data.frames*, ils possèdent toujours "
"l'attribut des noms de lignes (`row names`). Mais ils ne les utilisent "
"jamais. Nous verrons dans un instant pourquoi.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 30 (code)
msgid ""
"If you would like to preserve the row names, use `keep.rownames = TRUE` in "
"`as.data.table()` - this will create a new column called `rn` and assign "
"row names to this column.\n"
msgstr ""
"Si vous souhaitez conserver les noms des lignes, utilisez `keep.rownames = "
"TRUE` dans `as.data.table()` - cela créera une nouvelle colonne appelée "
"`rn` et attribuera les noms des lignes à cette colonne.\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 31 (paragraph)
msgid ""
"Instead, in *data.tables* we set and use `keys`. Think of a `key` as "
"**supercharged rownames**."
msgstr ""
"Au lieu de cela, dans les *data.tables*, nous définissons et utilisons des "
"`clés`. Pensez aux `clés` comme à des **\"super\" noms de lignes**."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 32 (header)
msgid "Keys and their properties {#key-properties}"
msgstr "Les clés et leurs propriétés {#key-properties}"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 33 (paragraph)
msgid ""
"=====1. We can set keys on *multiple columns* and the column can be of "
"*different types* -- *integer*, *numeric*, *character*, *factor*, "
"*integer64* etc. *list* and *complex* types are not supported yet.====="
msgstr ""
"=====1. Nous pouvons définir des clés sur *plusieurs colonnes* et les "
"colonnes peuvent être de *différents types* -- *entier*, *numérique*, "
"*caractère*, *facteur*, *entier64* etc. Les types *liste* et *complexe* ne "
"sont pas encore supportés.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 34 (paragraph)
msgid ""
"=====2. Uniqueness is not enforced, i.e., duplicate key values are allowed. "
"Since rows are sorted by key, any duplicates in the key columns will appear "
"consecutively.====="
msgstr ""
"=====2. L'unicité n'est pas requise, c'est-à-dire que les valeurs de clé "
"dupliquées sont autorisées. Les lignes étant triées par clé, tout doublon "
"dans les colonnes de la clé apparaîtra consécutivement.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 35 (paragraph)
msgid "=====3. Setting a `key` does *two* things:====="
msgstr "=====3. Définir une `clé` fait *deux* choses : ====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 36 (code)
msgid ""
"a. physically reorders the rows of the *data.table* by the column(s) "
"provided *by reference*, always in *increasing* order.\n"
"\n"
"b. marks those columns as *key* columns by setting an attribute called "
"`sorted` to the *data.table*.\n"
"\n"
"Since the rows are reordered, a *data.table* can have at most one key "
"because it can not be sorted in more than one way.\n"
msgstr ""
"a. les lignes de la *data.table* sont réorganisées physiquement en fonction "
"des colonnes fournies *par référence*, toujours dans un ordre "
"*incrémentiel*.\n"
"\n"
"b. ces colonnes sont marquées comme des colonnes de *clés* en définissant "
"un attribut appelé `sorted` à *data.table*.\n"
"\n"
"Puisque les lignes sont réordonnées, une *data.table* ne peut avoir qu'une "
"seule clé car elle ne peut pas être triée de plusieurs façons "
"simultanément.\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 37 (paragraph)
msgid "For the rest of the vignette, we will work with `flights` data set."
msgstr ""
"Pour le reste de la vignette, nous travaillerons avec le jeu de données "
"`flights`."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 38 (header)
msgid "b) Set, get and use keys on a *data.table*"
msgstr "b) Définir, obtenir et utiliser des clés sur une *data.table*"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 39 (header)
msgid ""
"-- How can we set the column `origin` as key in the *data.table* `flights`?"
msgstr ""
"-- Comment définir la colonne `origin` comme clé dans la *data.table* "
"`flights` ?"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 40 (code)
msgid ""
"setkey(flights, origin)\n"
"head(flights)\n"
"\n"
"## alternatively we can provide character vectors to the function "
"'setkeyv()'\n"
"# setkeyv(flights, \"origin\") # useful to program with\n"
msgstr ""
"setkey(flights, origin)\n"
"head(flights)\n"
"\n"
"## nous pouvons aussi fournir des vecteurs de caractères à la fonction "
"'setkeyv()'\n"
"# setkeyv(flights, \"origin\") # utile pour la programmation\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 41 (paragraph)
msgid ""
"=====* You can use the function `setkey()` and provide the column names "
"(without quoting them). This is helpful during interactive use.====="
msgstr ""
"=====* Vous pouvez utiliser la fonction `setkey()` et fournir les noms des "
"colonnes (sans les entourer de guillemets). Ceci est utile lors d'une "
"utilisation interactive.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 42 (paragraph)
msgid ""
"=====* Alternatively you can pass a character vector of column names to the "
"function `setkeyv()`. This is particularly useful while designing functions "
"to pass columns to set key on as function arguments.====="
msgstr ""
"=====* Alternativement, vous pouvez passer un vecteur de caractères "
"contenant les noms de colonnes à la fonction `setkeyv()`. Cela est "
"particulièrement utile lors de la conception de fonctions pour passer des "
"colonnes à définir comme clé via des arguments de fonction.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 43 (paragraph)
msgid ""
"=====* Note that we did not have to assign the result back to a variable. "
"This is because like the `:=` function we saw in the *\"Reference semantics"
"\"* vignette, `setkey()` and `setkeyv()` modify the input *data.table* *by "
"reference*. They return the result invisibly.====="
msgstr ""
"=====* Notez que nous n'avons pas eu besoin d'assigner le résultat à une "
"variable. C'est parce que, comme la fonction `:=` que nous avons vue dans "
"la vignette *\"Sémantique de référence\"*, `setkey()` et `setkeyv()` "
"modifient l'entrée *data.table* *par référence*. Elles renvoient le "
"résultat de manière invisible.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 44 (paragraph)
msgid ""
"=====* The *data.table* is now reordered (or sorted) by the column we "
"provided - `origin`. Since we reorder by reference, we only require "
"additional memory of one column of length equal to the number of rows in "
"the *data.table*, and is therefore very memory efficient.====="
msgstr ""
"=====* La *data.table* est maintenant réordonnée (ou triée) par la colonne "
"que nous avons fournie - `origin`. Comme nous réorganisons par référence, "
"nous n'avons besoin que de la mémoire supplémentaire d'une colonne dont la "
"longueur est égale au nombre de lignes de la *data.table*, ce qui est donc "
"très efficace en termes de mémoire.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 45 (paragraph)
msgid ""
"=====* You can also set keys directly when creating *data.tables* using the "
"`data.table()` function using `key` argument. It takes a character vector "
"of column names.====="
msgstr ""
"=====* Vous pouvez également définir les clés directement lors de la "
"création de *data.tables* en utilisant la fonction `data.table()` avec "
"l'argument `key`. Elle prend un vecteur de caractères de noms de colonnes."
"====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 46 (header)
msgid "set* and `:=`:"
msgstr "set* et `:=` :"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 47 (paragraph)
msgid ""
"In *data.table*, the `:=` operator and all the `set*` (e.g., `setkey`, "
"`setorder`, `setnames` etc.) functions are the only ones which modify the "
"input object *by reference*."
msgstr ""
"Dans *data.table*, l'opérateur `:=` et toutes les fonctions `set*` (par "
"exemple, `setkey`, `setorder`, `setnames`, etc.) sont les seules qui "
"modifient l'objet d'entrée *par référence*."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 48 (paragraph)
msgid ""
"Once you *key* a *data.table* by certain columns, you can subset by "
"querying those key columns using the `.()` notation in `i`. Recall that `."
"()` is an *alias to* `list()`."
msgstr ""
"Une fois que vous avez défini une *clé* pour une *data.table* par certaines "
"colonnes, vous pouvez sous-sélectionner en interrogeant ces colonnes clés "
"en utilisant la notation `.()` dans `i`. Rappelez-vous que `.()` est un "
"*alias de* `list()`."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 49 (header)
msgid ""
"-- Use the key column `origin` to subset all rows where the origin airport "
"matches *\"JFK\"*"
msgstr ""
"-- Utilisez la colonne `origin` définie comme clé pour extraire toutes les "
"lignes dont l'aéroport d'origine correspond à *\"JFK\"*"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 50 (code)
msgid ""
"flights[.(\"JFK\")]\n"
"\n"
"## alternatively\n"
"# flights[J(\"JFK\")] (or)\n"
"# flights[list(\"JFK\")]\n"
msgstr ""
"flights[.(\"JFK\")]\n"
"\n"
"## ou alors :\n"
"# flights[J(\"JFK\")] (ou)\n"
"# flights[list(\"JFK\")]\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 51 (paragraph)
msgid ""
"=====* The *key* column has already been set to `origin`. So it is "
"sufficient to provide the value, here *\"JFK\"*, directly. The `.()` syntax "
"helps identify that the task requires looking up the value *\"JFK\"* in the "
"key column of *data.table* (here column `origin` of `flights` *data.table*)."
"====="
msgstr ""
"=====* La `clé` a déjà été définie sur la colonne `origin`. Il suffit donc "
"de fournir la valeur, ici *\"JFK\"*, directement. La syntaxe `.()` permet "
"d'identifier que la tâche nécessite de rechercher la valeur *\"JFK\"* dans "
"la colonne définie comme clé de *data.table* (ici la colonne `origin` du "
"*data.table* `flights`).====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 52 (paragraph)
msgid ""
"=====* The *row indices* corresponding to the value *\"JFK\"* in `origin` "
"is obtained first. And since there is no expression in `j`, all columns "
"corresponding to those row indices are returned.====="
msgstr ""
"=====* Les *indices de ligne* correspondant à la valeur *\"JFK\"* dans "
"`origin` sont obtenus en premier. Et comme il n'y a pas d'expression dans "
"`j`, toutes les colonnes correspondant à ces indices de ligne sont "
"renvoyées.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 53 (paragraph)
msgid ""
"=====* On single column key of *character* type, you can drop the `.()` "
"notation and use the values directly when subsetting, like subset using row "
"names on *data.frames*.====="
msgstr ""
"=====* Pour une clé sur une seule colonne de type *caractère*, vous pouvez "
"omettre la notation `.()` et utiliser les valeurs directement lors de "
"l'extraction du sous-ensemble, comme si vous faisiez un sous-ensemble avec "
"les noms de lignes dans un *data.frames*.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 54 (code)
msgid ""
"```{chunk_with_args}\n"
"#===== r eval = FALSE\n"
"flights[\"JFK\"]              ## same as flights[.(\"JFK\")]\n"
"```\n"
msgstr ""
"```{chunk_with_args}\n"
"#===== r eval = FALSE\n"
"flights[\"JFK\"] ## identique à flights[.(\"JFK\")]\n"
"```\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 55 (paragraph)
msgid "=====* We can subset any amount of values as required====="
msgstr "=====* Nous pouvons extraire autant de valeurs que nécessaire ====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 56 (code)
msgid ""
"```{chunk_with_args}\n"
"#===== r eval = FALSE\n"
"flights[c(\"JFK\", \"LGA\")]    ## same as flights[.(c(\"JFK\", \"LGA\"))]\n"
"```\n"
"\n"
"This returns all columns corresponding to those rows where `origin` column "
"matches either *\"JFK\"* or *\"LGA\"*.\n"
msgstr ""
"```{chunk_with_args}\n"
"#===== r eval = FALSE\n"
"flights[c(\"JFK\", \"LGA\")] ## same as flights[.(c(\"JFK\", \"LGA\"))]\n"
"```\n"
"\n"
"Ceci renvoie toutes les colonnes correspondant aux lignes où la colonne "
"`origin` correspond à *\"JFK\"* ou *\"LGA\"*.\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 57 (header)
msgid "-- How can we get the column(s) a *data.table* is keyed by?"
msgstr ""
"-- Comment obtenir la (les) colonne(s) d'une *data.table* définie(s) par "
"une clé ?"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 58 (paragraph)
msgid "Using the function `key()`."
msgstr "En utilisant la fonction `key()`."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 59 (code)
msgid "key(flights)\n"
msgstr "key(flights)\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 60 (paragraph)
msgid "=====* It returns a character vector of all the key columns.====="
msgstr ""
"=====* Elle renvoie un vecteur de caractères contenant toutes les colonnes "
"définies comme clés.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 61 (paragraph)
msgid "=====* If no key is set, it returns `NULL`.====="
msgstr "=====* Si aucune clé n'est définie, elle renvoie `NULL`.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 62 (header)
msgid "c) Keys and multiple columns"
msgstr "c) Clés et colonnes multiples"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 63 (paragraph)
msgid ""
"To refresh, *keys* are like *supercharged* row names. We can set key on "
"multiple columns and they can be of multiple types."
msgstr ""
"Pour rappel, les clés sont comme des noms de lignes *surpuissants*. Nous "
"pouvons définir des clés sur plusieurs colonnes, et elles peuvent être de "
"types multiples."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 64 (header)
msgid "-- How can I set keys on both `origin` *and* `dest` columns?"
msgstr ""
"-- Comment puis-je définir des clés sur les colonnes `origin` *et* `dest` ?"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 65 (code)
msgid ""
"setkey(flights, origin, dest)\n"
"head(flights)\n"
"\n"
"## or alternatively\n"
"# setkeyv(flights, c(\"origin\", \"dest\")) # provide a character vector of "
"column names\n"
"\n"
"key(flights)\n"
msgstr ""
"setkey(flights, origin, dest)\n"
"head(flights)\n"
"\n"
"## ou alors :\n"
"# setkeyv(flights, c(\"origin\", \"dest\")) # fournir un vecteur de "
"caractères pour les noms de colonnes\n"
"\n"
"key(flights)\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 66 (paragraph)
msgid ""
"=====* It sorts the *data.table* first by the column `origin` and then by "
"`dest` *by reference*.====="
msgstr ""
"=====* Cela trie la *data.table* d'abord par la colonne `origin` et ensuite "
"par `dest` *par référence*.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 67 (header)
msgid ""
"-- Subset all rows using key columns where first key column `origin` "
"matches *\"JFK\"* and second key column `dest` matches *\"MIA\"*"
msgstr ""
"-- Extraire toutes les lignes en utilisant les colonnes définies comme clés "
"où la première clé `origin` correspond à *\"JFK\"* et la deuxième clé "
"`dest` correspond à *\"MIA\"*"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 68 (code)
msgid "flights[.(\"JFK\", \"MIA\")]\n"
msgstr "flights[.(\"JFK\", \"MIA\")]\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 69 (header)
msgid "How does the subset work here? {#multiple-key-point}"
msgstr ""
"Comment l'extraction du sous-ensemble fonctionne ici ? {#multiple-key-point}"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 70 (paragraph)
msgid ""
"=====* It is important to understand how this works internally. *\"JFK\"* "
"is first matched against the first key column `origin`. And *within those "
"matching rows*, *\"MIA\"* is matched against the second key column `dest` "
"to obtain *row indices* where both `origin` and `dest` match the given "
"values.====="
msgstr ""
"=====* Il est important de comprendre comment cela fonctionne en interne. *"
"\"JFK\"* est d'abord comparé à la première colonne clé `origin`. Et *dans "
"ces lignes correspondantes*, *\"MIA\"* est comparé à la deuxième colonne "
"clé `dest` pour obtenir des *indices de ligne* où `origin` et `dest` "
"correspondent aux valeurs données.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 71 (paragraph)
msgid ""
"=====* Since no `j` is provided, we simply return *all columns* "
"corresponding to those row indices.====="
msgstr ""
"=====* Étant donné qu'il n'y a pas d'expression dans `j`, nous renvoyons "
"simplement *toutes les colonnes* correspondant à ces indices de ligne.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 72 (header)
msgid ""
"-- Subset all rows where just the first key column `origin` matches *\"JFK"
"\"*"
msgstr ""
"-- Extraire toutes les lignes où seule la première colonne clé `origin` "
"correspond à *\"JFK\"*"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 73 (code)
msgid ""
"key(flights)\n"
"\n"
"flights[.(\"JFK\")] ## or in this case simply flights[\"JFK\"], for "
"convenience\n"
msgstr ""
"key(flights)\n"
"\n"
"flights[.(\"JFK\")] ## ou dans ce cas simplement flights[\"JFK\"], par "
"commodité\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 74 (paragraph)
msgid ""
"=====* Since we did not provide any values for the second key column "
"`dest`, it just matches *\"JFK\"* against the first key column `origin` and "
"returns all the matched rows.====="
msgstr ""
"=====* Puisque nous n'avons pas fourni de valeurs pour la deuxième colonne "
"clé `dest`, il fait simplement correspondre *\"JFK\"* à la première colonne "
"clé `origin` et renvoie toutes les lignes correspondantes.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 75 (header)
msgid ""
"-- Subset all rows where just the second key column `dest` matches *\"MIA\"*"
msgstr ""
"-- Extraire toutes les lignes où seule la deuxième colonne clé `dest` "
"correspond à *\"MIA\"*"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 76 (code)
msgid "flights[.(unique(origin), \"MIA\")]\n"
msgstr "flights[.(unique(origin), \"MIA\")]\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 77 (header)
msgid "What's happening here?"
msgstr "Que se passe-t-il ici ?"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 78 (paragraph)
msgid ""
"=====* Read [this](#multiple-key-point) again. The value provided for the "
"second key column *\"MIA\"* has to find the matching values in `dest` key "
"column *on the matching rows provided by the first key column `origin`*. We "
"can not skip the values of key columns *before*. Therefore, we provide "
"*all* unique values from key column `origin`.====="
msgstr ""
"=====* Relisez bien [ceci](#multiple-key-point). La valeur fournie pour la "
"deuxième colonne clé *\"MIA\"* doit trouver les valeurs correspondantes "
"dans la colonne clé `dest` *parmi les lignes correspondantes fournies par "
"la première colonne clé `origin`*. Nous ne pouvons pas ignorer les valeurs "
"des colonnes clés *précédentes*. Par conséquent, nous fournissons *toutes* "
"les valeurs uniques de la colonne clé `origin`.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 79 (paragraph)
msgid ""
"=====* *\"MIA\"* is automatically recycled to fit the length of "
"`unique(origin)` which is *3*.====="
msgstr ""
"=====* *\"MIA\"* est automatiquement recyclée pour s'adapter à la longueur "
"de `unique(origin)` qui est de *3*.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 80 (header)
msgid "2. Combining keys with `j` and `by`"
msgstr "2. Combiner les clés avec `j` et `by`"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 81 (paragraph)
msgid ""
"All we have seen so far is the same concept -- obtaining *row indices* in "
"`i`, but just using a different method -- using `keys`. It shouldn't be "
"surprising that we can do exactly the same things in `j` and `by` as seen "
"from the previous vignettes. We will highlight this with a few examples."
msgstr ""
"Tout ce que nous avons vu jusqu'à présent repose sur le même concept -- "
"obtenir les *indices de lignes* dans `i`, mais en utilisant une méthode "
"différente -- en utilisant des `clés`. Il n'est donc pas surprenant que "
"nous puissions faire exactement les mêmes opérations pour `j` et `by`, "
"comme vu dans les vignettes précédentes. Nous allons illustrer cela avec "
"quelques exemples."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 82 (header)
msgid "a) Select in `j`"
msgstr "b) Sélection dans `j`"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 83 (header)
msgid ""
"-- Return `arr_delay` column as a *data.table* corresponding to `origin = "
"\"LGA\"` and `dest = \"TPA\"`."
msgstr ""
"-- Renvoie la colonne `arr_delay` sous forme de *data.table* correspondant "
"à `origin = \"LGA\"` et `dest = \"TPA\"`."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 84 (code)
msgid ""
"key(flights)\n"
"flights[.(\"LGA\", \"TPA\"), .(arr_delay)]\n"
msgstr ""
"key(flights)\n"
"flights[.(\"LGA\", \"TPA\"), .(arr_delay)]\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 85 (paragraph)
msgid ""
"=====* The *row indices* corresponding to `origin == \"LGA\"` and `dest == "
"\"TPA\"` are obtained using *key based subset*.====="
msgstr ""
"=====* Les *indices de ligne* correspondant à `origin == \"LGA\"` et `dest "
"== \"TPA\"` sont obtenus à l'aide d'un *sous-ensemble basé sur une clé*."
"====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 86 (paragraph)
msgid ""
"=====* Once we have the row indices, we look at `j` which requires only the "
"`arr_delay` column. So we simply select the column `arr_delay` for those "
"*row indices* in the exact same way as we have seen in *Introduction to "
"data.table* vignette.====="
msgstr ""
"=====* Une fois que nous avons les indices des lignes, nous examinons `j` "
"qui ne nécessite que la colonne `arr_delay`. Nous sélectionnons donc "
"simplement la colonne `arr_delay` pour ces *indices de lignes* de la même "
"manière que nous l'avons vu dans la vignette *Introduction à data.table*."
"====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 87 (paragraph)
msgid ""
"=====* We could have returned the result by using `with = FALSE` as well."
"====="
msgstr ""
"=====* Nous aurions également pu renvoyer le résultat en utilisant `with = "
"FALSE`.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 88 (code)
msgid ""
"```{chunk_with_args}\n"
"#===== r eval = FALSE\n"
"flights[.(\"LGA\", \"TPA\"), \"arr_delay\", with = FALSE]\n"
"```\n"
msgstr ""
"```{chunk_with_args}\n"
"#===== r eval = FALSE\n"
"flights[.(\"LGA\", \"TPA\"), \"arr_delay\", with = FALSE]\n"
"```\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 89 (header)
msgid "b) Chaining"
msgstr "b) Chaînage"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 90 (header)
msgid ""
"-- On the result obtained above, use chaining to order the column in "
"decreasing order."
msgstr ""
"-- Sur la base du résultat obtenu ci-dessus, utilisez le chaînage pour "
"trier la colonne dans l'ordre décroissant."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 91 (code)
msgid "flights[.(\"LGA\", \"TPA\"), .(arr_delay)][order(-arr_delay)]\n"
msgstr "flights[.(\"LGA\", \"TPA\"), .(arr_delay)][order(-arr_delay)]\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 92 (header)
msgid "c) Compute or *do* in `j`"
msgstr "c) Calculer ou *exécuter* dans `j`"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 93 (header)
msgid ""
"-- Find the maximum arrival delay corresponding to `origin = \"LGA\"` and "
"`dest = \"TPA\"`."
msgstr ""
"-- Trouvez le retard d'arrivée maximal correspondant à `origin = \"LGA\"` "
"et `dest = \"TPA\"`."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 94 (code)
msgid "flights[.(\"LGA\", \"TPA\"), max(arr_delay)]\n"
msgstr "flights[.(\"LGA\", \"TPA\"), max(arr_delay)]\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 95 (paragraph)
msgid ""
"=====* We can verify that the result is identical to first value (486) from "
"the previous example.====="
msgstr ""
"=====* Nous pouvons vérifier que le résultat est identique à la première "
"valeur (486) de l'exemple précédent.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 96 (header)
msgid "d) *sub-assign* by reference using `:=` in `j`"
msgstr "d) *sous-affectation* par référence en utilisant `:=` dans `j`"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 97 (paragraph)
msgid ""
"We have seen this example already in the *Reference semantics* vignette. "
"Let's take a look at all the `hours` available in the `flights` *data."
"table*:"
msgstr ""
"Nous avons déjà vu cet exemple dans la vignette *Sémantique de référence*. "
"Jetons un coup d'œil à toutes les heures (`hour`) disponibles dans la *data."
"table* `flights` :"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 98 (code)
msgid ""
"# get all 'hours' in flights\n"
"flights[, sort(unique(hour))]\n"
msgstr ""
"# récupère toutes les 'hours' de flights\n"
"flights[, sort(unique(hour))]\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 99 (paragraph)
msgid ""
"We see that there are totally `25` unique values in the data. Both *0* and "
"*24* hours seem to be present. Let's go ahead and replace *24* with *0*, "
"but this time using *key*."
msgstr ""
"Nous voyons qu'il y a au total `25` valeurs uniques dans les données. Les "
"heures *0* et *24* semblent toutes les deux être présentes. Allons-y et "
"remplaçons *24* par *0*, mais cette fois en utilisant *key*."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 100 (code)
msgid ""
"setkey(flights, hour)\n"
"key(flights)\n"
"flights[.(24), hour := 0L]\n"
"key(flights)\n"
msgstr ""
"setkey(flights, hour)\n"
"key(flights)\n"
"flights[.(24), hour := 0L]\n"
"key(flights)\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 101 (paragraph)
msgid ""
"=====* We first set `key` to `hour`. This reorders `flights` by the column "
"`hour` and marks that column as the `key` column.====="
msgstr ""
"=====* Nous définissons d'abord la clé (`key`) sur `hour`. Cela réorganise "
"`flights` en fonction de la colonne `hour` et marque cette colonne comme "
"`clé`.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 102 (paragraph)
msgid ""
"=====* Now we can subset on `hour` by using the `.()` notation. We subset "
"for the value *24* and obtain the corresponding *row indices*.====="
msgstr ""
"=====* Nous pouvons maintenant faire un sous-ensemble sur `hour` en "
"utilisant la notation `.()`. Nous extrayons les valeurs pour *24* et "
"obtenons les *indices des lignes* correspondants.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 103 (paragraph)
msgid ""
"=====* And on those row indices, we replace the `key` column with the value "
"`0`.====="
msgstr ""
"=====* Et sur ces indices de lignes, nous remplaçons la colonne `clé` par "
"la valeur `0`.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 104 (paragraph)
msgid ""
"=====* Since we have replaced values on the *key* column, the *data.table* "
"`flights` isn't sorted by `hour` anymore. Therefore, the key has been "
"automatically removed by setting to NULL.====="
msgstr ""
"=====* Comme nous avons remplacé les valeurs de la colonne *clé*, le *data."
"table* `flights` n'est plus triée par `hour`. Par conséquent, la clé a été "
"automatiquement supprimée en la définissant sur NULL.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 105 (paragraph)
msgid "Now, there shouldn't be any *24* in the `hour` column."
msgstr ""
"Maintenant, Il ne devrait plus y avoir de *24* dans la colonne `hour`."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 106 (code)
msgid "flights[, sort(unique(hour))]\n"
msgstr "flights[, sort(unique(hour))]\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 107 (header)
msgid "e) Aggregation using `by`"
msgstr "e) Agrégation avec `by`"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 108 (paragraph)
msgid "Let's set the key back to `origin, dest` first."
msgstr "Remettons d'abord la clé sur `origin, dest`."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 109 (code)
msgid ""
"setkey(flights, origin, dest)\n"
"key(flights)\n"
msgstr ""
"setkey(flights, origin, dest)\n"
"key(flights)\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 110 (header)
msgid ""
"-- Get the maximum departure delay for each `month` corresponding to "
"`origin = \"JFK\"`. Order the result by `month`"
msgstr ""
"-- Obtenir le retard maximum de départ pour chaque mois (`month`) "
"correspondant à `origin = \"JFK\"`. Classer les résultats par `mois`"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 111 (code)
msgid ""
"ans <- flights[\"JFK\", max(dep_delay), keyby = month]\n"
"head(ans)\n"
"key(ans)\n"
msgstr ""
"ans <- flights[\"JFK\", max(dep_delay), keyby = month]\n"
"head(ans)\n"
"key(ans)\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 112 (paragraph)
msgid ""
"=====* We subset on the `key` column *origin* to obtain the *row indices* "
"corresponding to *\"JFK\"*.====="
msgstr ""
"=====* Nous extrayons un sous-ensemble à partir de la colonne `clé` "
"*origin* pour obtenir les *indices des lignes* correspondant à *\"JFK\"*."
"====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 113 (paragraph)
msgid ""
"=====* Once we obtain the row indices, we only need two columns - `month` "
"to group by and `dep_delay` to obtain `max()` for each group. *data."
"table's* query optimisation therefore subsets just those two columns "
"corresponding to the *row indices* obtained in `i`, for speed and memory "
"efficiency.====="
msgstr ""
"=====* Une fois que nous avons obtenu les indices des lignes, nous n'avons "
"besoin que de deux colonnes - `month` pour grouper et `dep_delay` pour "
"obtenir `max()` pour chaque groupe. L'optimisation des requêtes de *data."
"table* permet d'extraire un sous-ensemble juste à partir de ces deux "
"colonnes, correspondant aux *indices de lignes* obtenus dans `i`, pour la "
"rapidité et l'efficacité mémoire.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 114 (paragraph)
msgid ""
"=====* And on that subset, we group by *month* and compute `max(dep_delay)`."
"====="
msgstr ""
"=====* Et sur ce sous-ensemble, nous regroupons par *mois* (*month*) et "
"calculons `max(dep_delay)`.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 115 (paragraph)
msgid ""
"=====* We use `keyby` to automatically key that result by *month*. Now we "
"understand what that means. In addition to ordering, it also sets *month* "
"as the `key` column.====="
msgstr ""
"=====* Nous utilisons `keyby` pour définir automatiquement cette clé par "
"*mois*. Nous comprenons maintenant ce que cela signifie. En plus de "
"l'ordre, cela définit *month* comme la colonne `key`.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 116 (header)
msgid "3. Additional arguments - `mult` and `nomatch`"
msgstr "3. Arguments supplémentaires - `mult` et `nomatch`"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 117 (header)
msgid "a) The *mult* argument"
msgstr "g) L'argument *mult*"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 118 (paragraph)
msgid ""
"We can choose, for each query, if *\"all\"* the matching rows should be "
"returned, or just the *\"first\"* or *\"last\"* using the `mult` argument. "
"The default value is *\"all\"* - what we've seen so far."
msgstr ""
"Nous pouvons choisir, pour chaque requête, si *\"toutes\"* les lignes "
"correspondantes doivent être retournées, ou seulement la *\"première\"* ou "
"la *\"dernière\"* en utilisant l'argument `mult`. La valeur par défaut est *"
"\"all\"* - ce que nous avons vu jusqu'à présent."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 119 (header)
msgid ""
"-- Subset only the first matching row from all rows where `origin` matches *"
"\"JFK\"* and `dest` matches *\"MIA\"*"
msgstr ""
"-- Extraire uniquement la première ligne correspondante parmi toutes les "
"lignes où `origin` correspond à *\"JFK\"* et `dest` correspond à *\"MIA\"*"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 120 (code)
msgid "flights[.(\"JFK\", \"MIA\"), mult = \"first\"]\n"
msgstr "flights[.(\"JFK\", \"MIA\"), mult = \"first\"]\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 121 (header)
msgid ""
"-- Subset only the last matching row of all the rows where `origin` matches "
"*\"LGA\", \"JFK\", \"EWR\"* and `dest` matches *\"XNA\"*"
msgstr ""
"-- Extraire uniquement la dernière ligne correspondante parmi toutes les "
"lignes où `origin` correspond à *\"LGA\", \"JFK\", \"EWR\"* et `dest` "
"correspond à *\"XNA\"*"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 122 (code)
msgid "flights[.(c(\"LGA\", \"JFK\", \"EWR\"), \"XNA\"), mult = \"last\"]\n"
msgstr "flights[.(c(\"LGA\", \"JFK\", \"EWR\"), \"XNA\"), mult = \"last\"]\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 123 (paragraph)
msgid ""
"=====* The query *\"JFK\", \"XNA\"* doesn't match any rows in `flights` and "
"therefore returns `NA`.====="
msgstr ""
"=====* La requête *\"JFK\", \"XNA\"* ne correspond à aucune ligne dans "
"`flights` et renvoie donc `NA`.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 124 (paragraph)
msgid ""
"=====* Once again, the query for second key column `dest`, *\"XNA\"*, is "
"recycled to fit the length of the query for first key column `origin`, "
"which is of length 3.====="
msgstr ""
"=====* Encore une fois, la requête pour la deuxième colonne clé `dest`, *"
"\"XNA\"*, est réutilisée pour correspondre à la longueur de la requête pour "
"la première colonne clé `origin`, qui est de longueur de 3.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 125 (header)
msgid "b) The *nomatch* argument"
msgstr "b) L'argument *nomatch*"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 126 (paragraph)
msgid ""
"We can choose if queries that do not match should return `NA` or be skipped "
"altogether using the `nomatch` argument."
msgstr ""
"Nous pouvons choisir si les requêtes qui ne correspondent pas doivent "
"renvoyer `NA` ou être ignorées en utilisant l'argument `nomatch`."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 127 (header)
msgid "-- From the previous example, Subset all rows only if there's a match"
msgstr ""
"-- D'après l'exemple précédent, extraire toutes les lignes uniquement si "
"elles correspondent"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 128 (code)
msgid ""
"flights[.(c(\"LGA\", \"JFK\", \"EWR\"), \"XNA\"), mult = \"last\", nomatch "
"= NULL]\n"
msgstr ""
"flights[.(c(\"LGA\", \"JFK\", \"EWR\"), \"XNA\"), mult = \"last\", nomatch "
"= NULL]\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 129 (paragraph)
msgid ""
"=====* Default value for `nomatch` is `NA`. Setting `nomatch = NULL` skips "
"queries with no matches.====="
msgstr ""
"=====* La valeur par défaut de `nomatch` est `NA`. En définissant `nomatch "
"= NULL`, on ignore les requêtes qui n'ont pas de correspondance.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 130 (paragraph)
msgid ""
"=====* The query “JFK”, “XNA” doesn’t match any rows in flights and "
"therefore is skipped.====="
msgstr ""
"=====* La requête \"JFK\", \"XNA\" ne correspond à aucune ligne dans "
"`flights` et est donc ignorée.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 131 (header)
msgid "4. binary search vs vector scans"
msgstr "4. recherche binaire vs balayage vectoriel"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 132 (paragraph)
msgid ""
"We have seen so far how we can set and use keys to subset. But what's the "
"advantage? For example, instead of doing:"
msgstr ""
"Nous avons vu jusqu'à présent comment définir et utiliser des clés pour "
"extraire des sous-ensembles. Mais quel est l'avantage ? Par exemple, au "
"lieu de faire :"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 133 (code)
msgid ""
"#===== r eval = FALSE\n"
"# key by origin,dest columns\n"
"flights[.(\"JFK\", \"MIA\")]\n"
msgstr ""
"#===== r eval = FALSE\n"
"# clé par origin,dest columns\n"
"flights[.(\"JFK\", \"MIA\")]\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 134 (paragraph)
msgid "we could have done:"
msgstr "nous aurions pu faire :"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 135 (code)
msgid ""
"#===== r eval = FALSE\n"
"flights[origin == \"JFK\" & dest == \"MIA\"]\n"
msgstr ""
"#===== r eval = FALSE\n"
"flights[origin == \"JFK\" & dest == \"MIA\"]\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 136 (paragraph)
msgid ""
"One advantage very likely is shorter syntax. But even more than that, "
"*binary search based subsets* are **incredibly fast**."
msgstr ""
"Un avantage évident est d'avoir une syntaxe plus courte. Mais plus encore, "
"*extraire des sous-ensembles basés par recherche binaire* est "
"**incroyablement rapide**."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 137 (paragraph)
msgid ""
"As the time goes `data.table` gets new optimization and currently the "
"latter call is automatically optimized to use *binary search*. To use slow "
"*vector scan* key needs to be removed."
msgstr ""
"Au fil du temps, `data.table` bénéficie de nouvelles optimisations et "
"actuellement, obtenir un sous-ensemble basé sur cette méthode applique "
"automatiquement la *recherche binaire*. Afin d'utiliser la méthode lente "
"par *balayage vectoriel*, la clé doit être supprimée."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 138 (code)
msgid ""
"#===== r eval = FALSE\n"
"setkey(flights, NULL)\n"
"flights[origin == \"JFK\" & dest == \"MIA\"]\n"
msgstr ""
"#===== r eval = FALSE\n"
"setkey(flights, NULL)\n"
"flights[origin == \"JFK\" & dest == \"MIA\"]\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 139 (header)
msgid "a) Performance of binary search approach"
msgstr "a) Performance de l'approche par recherche binaire"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 140 (paragraph)
msgid ""
"To illustrate, let's create a sample *data.table* with 20 million rows and "
"three columns and key it by columns `x` and `y`."
msgstr ""
"Pour illustrer cela, créons un *data.table* avec 20 millions de lignes et "
"trois colonnes, avec pour clés les colonnes `x` et `y`."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 141 (code)
msgid ""
"set.seed(2L)\n"
"N = 2e7L\n"
"DT = data.table(x = sample(letters, N, TRUE),\n"
"                y = sample(1000L, N, TRUE),\n"
"                val = runif(N))\n"
"print(object.size(DT), units = \"Mb\")\n"
msgstr ""
"set.seed(2L)\n"
"N = 2e7L\n"
"DT = data.table(x = sample(letters, N, TRUE),\n"
"                y = sample(1000L, N, TRUE),\n"
"                val = runif(N))\n"
"print(object.size(DT), units = \"Mb\")\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 142 (paragraph)
msgid ""
"`DT` is ~380MB. It is not really huge, but this will do to illustrate the "
"point."
msgstr ""
"`DT` est de ~380Mo. Ce n'est pas vraiment énorme, mais suffisant pour "
"illustrer le propos."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 143 (paragraph)
msgid ""
"From what we have seen in the Introduction to data.table section, we can "
"subset those rows where columns `x = \"g\"` and `y = 877` as follows:"
msgstr ""
"D'après ce que nous avons vu dans la section Introduction à data.table, "
"nous pouvons faire un sous-ensemble des lignes où les colonnes `x = \"g\"` "
"et `y = 877` comme suit :"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 144 (code)
msgid ""
"key(DT)\n"
"## (1) Usual way of subsetting - vector scan approach\n"
"t1 <- system.time(ans1 <- DT[x == \"g\" & y == 877L])\n"
"t1\n"
"head(ans1)\n"
"dim(ans1)\n"
msgstr ""
"key(DT)\n"
"## (1) Méthode habituelle pour extraire un sous-ensemble - approche par "
"balayage vectoriel\n"
"t1 <- system.time(ans1 <- DT[x == \"g\" & y == 877L])\n"
"t1\n"
"head(ans1)\n"
"dim(ans1)\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 145 (paragraph)
msgid "Now let's try to subset by using keys."
msgstr "Essayons maintenant de faire un sous-ensemble en utilisant des clés."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 146 (code)
msgid ""
"setkeyv(DT, c(\"x\", \"y\"))\n"
"key(DT)\n"
"## (2) Subsetting using keys\n"
"t2 <- system.time(ans2 <- DT[.(\"g\", 877L)])\n"
"t2\n"
"head(ans2)\n"
"dim(ans2)\n"
"\n"
"identical(ans1$val, ans2$val)\n"
msgstr ""
"setkeyv(DT, c(\"x\", \"y\"))\n"
"key(DT)\n"
"## (2) Sous-ensemble à l'aide de clés\n"
"t2 <- system.time(ans2 <- DT[.(\"g\", 877L)])\n"
"t2\n"
"head(ans2)\n"
"dim(ans2)\n"
"\n"
"identical(ans1$val, ans2$val)\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 147 (paragraph)
msgid "=====* The speed-up is **~`r round(t1[3]/max(t2[3], .001))`x**!====="
msgstr ""
"=====* Le gain de vitesse est d'envrion **~`r round(t1[3]/"
"max(t2[3], .001))`x**!====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 148 (header)
msgid "b) Why does keying a *data.table* result in blazing fast subsets?"
msgstr ""
"b)  Pourquoi le fait de définir une clé pour une *data.table* permet-il "
"d'obtenir des sous-ensembles extrêmement rapides ?"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 149 (paragraph)
msgid ""
"To understand that, let's first look at what *vector scan approach* (method "
"1) does."
msgstr ""
"Pour comprendre cela, examinons d'abord ce que fait l'approche par "
"*balayage vectoriel* (méthode 1)."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 150 (header)
msgid "Vector scan approach"
msgstr "Approche par balayage vectoriel"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 151 (paragraph)
msgid ""
"=====* The column `x` is searched for the value *\"g\"* row by row, on all "
"20 million of them. This results in a *logical vector* of size 20 million, "
"with values `TRUE, FALSE or NA` corresponding to `x`'s value.====="
msgstr ""
"=====* La colonne `x` est parcourue ligne par ligne pour rechercher la "
"valeur *\"g\"* parmi les 20 millions de lignes. Cela produit un *vecteur "
"logique* de taille 20 millions, avec les valeurs `TRUE, FALSE ou NA` "
"correspondant à la valeur de `x`.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 152 (paragraph)
msgid ""
"=====* Similarly, the column `y` is searched for `877` on all 20 million "
"rows one by one, and stored in another logical vector.====="
msgstr ""
"=====* De même, la colonne `y` est parcourue pour rechercher la valeur "
"`877` parmi les 20 millions de lignes, et les résultats sont stockés dans "
"un autre vecteur logique.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 153 (paragraph)
msgid ""
"=====* Element wise `&` operations are performed on the intermediate "
"logical vectors and all the rows where the expression evaluates to `TRUE` "
"are returned.====="
msgstr ""
"=====* Ensuite, une opération élément par élément `&` est effectuée sur les "
"vecteurs logiques intermédiaires et toutes les lignes où l'expression est "
"évaluée à `TRUE` sont renvoyées.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 154 (paragraph)
msgid ""
"This is what we call a *vector scan approach*. And this is quite "
"inefficient, especially on larger tables and when one needs repeated "
"subsetting, because it has to scan through all the rows each time."
msgstr ""
"C'est ce que nous appelons une *approche par balayage vectoriel*. Cette "
"méthode est assez inefficace, en particulier pour les tableaux volumineux "
"ou lorsque des sous-ensembles doivent être créés de manière répétée, car "
"elle doit parcourir toutes les lignes à chaque fois."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 155 (paragraph)
msgid ""
"Now let us look at binary search approach (method 2). Recall from "
"[Properties of key](#key-properties) - *setting keys reorders the data."
"table by key columns*. Since the data is sorted, we don't have to *scan "
"through the entire length of the column*! We can instead use *binary "
"search* to search a value in `O(log n)` as opposed to `O(n)` in case of "
"*vector scan approach*, where `n` is the number of rows in the *data.table*."
msgstr ""
"Examinons maintenant l'approche de la recherche binaire (méthode 2). "
"Rappelons que dans [Les clés et leurs propriétés](#key-properties) - "
"*lorsque l’on définit des clés, cela réorganise la data.table selon les "
"colonnes clés*. Étant donné que les données sont triées, nous n'avons pas "
"besoin de *parcourir toute la longueur de la colonne* ! Nous pouvons "
"utiliser *la recherche binaire* pour rechercher une valeur en `O(log n)` au "
"lieu de `O(n)` dans le cas de *l'approche par balayage vectoriel*, où `n` "
"est le nombre de lignes dans la *data.table*."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 156 (header)
msgid "Binary search approach"
msgstr "Approche par recherche binaire"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 157 (paragraph)
msgid ""
"Here's a very simple illustration. Let's consider the (sorted) numbers "
"shown below:"
msgstr ""
"Prenons un exemple très simple. Considérons les nombres (triés) ci-dessous :"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 158 (code)
msgid "1, 5, 10, 19, 22, 23, 30\n"
msgstr "1, 5, 10, 19, 22, 23, 30\n"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 159 (paragraph)
msgid ""
"Suppose we'd like to find the matching position of the value *1*, using "
"binary search, this is how we would proceed - because we know that the data "
"is *sorted*."
msgstr ""
"Supposons que nous voulions trouver la position correspondant à la valeur "
"*1*, en utilisant la recherche binaire. Voici comment nous procéderions -"
"(en sachant que les données sont *triées*)."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 160 (paragraph)
msgid "=====* Start with the middle value = 19. Is 1 == 19? No. 1 < 19.====="
msgstr ""
"=====* Commencez par la valeur du milieu = 19. Est-ce que 1 == 19 ? Non. 1 "
"< 19.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 161 (paragraph)
msgid ""
"=====* Since the value we're looking for is smaller than 19, it should be "
"somewhere before 19. So we can discard the rest of the half that are >= 19."
"====="
msgstr ""
"=====* Comme la valeur recherchée est plus petite que 19, elle doit se "
"trouver quelque part avant 19. Nous pouvons donc écarter le reste de la "
"moitié qui est >= 19.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 162 (paragraph)
msgid ""
"=====* Our set is now reduced to *1, 5, 10*. Grab the middle value once "
"again = 5. Is 1 == 5? No. 1 < 5.====="
msgstr ""
"=====* Notre ensemble est maintenant réduit à *1, 5, 10*. Prenons à nouveau "
"la valeur centrale = 5. Est-ce que 1 == 5 ? Non. 1 < 5.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 163 (paragraph)
msgid ""
"=====* Our set is reduced to *1*. Is 1 == 1? Yes. The corresponding index "
"is also 1. And that's the only match.====="
msgstr ""
"=====* Notre ensemble est réduit à *1*. Est-ce que 1 == 1 ? Oui. L'indice "
"correspondant est également 1. Et c'est la seule correspondance.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 164 (paragraph)
msgid ""
"A vector scan approach on the other hand would have to scan through all the "
"values (here, 7)."
msgstr ""
"Avec une approche de balayage vectoriel, nous aurions dû parcourir toutes "
"les valeurs (ici, 7 valeurs)."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 165 (paragraph)
msgid ""
"It can be seen that with every search we reduce the number of searches by "
"half. This is why *binary search* based subsets are **incredibly fast**. "
"Since rows of each column of *data.tables* have contiguous locations in "
"memory, the operations are performed in a very cache efficient manner (also "
"contributes to *speed*)."
msgstr ""
"On peut constater qu'à chaque recherche, le nombre de recherches est réduit "
"de moitié. C'est pourquoi la construction de sous-ensembles en utilisant la "
"recherche binaire est **incroyablement rapide**. Étant donné que les lignes "
"de chaque colonne des *data.tables* sont stockées de manière contiguë en "
"mémoire, les opérations sont effectuées de manière très efficace en termes "
"de cache (ce qui contribue également à la *vitesse*)."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 166 (paragraph)
msgid ""
"In addition, since we obtain the matching row indices directly without "
"having to create those huge logical vectors (equal to the number of rows in "
"a *data.table*), it is quite **memory efficient** as well."
msgstr ""
"De plus, comme nous obtenons directement les indices des lignes "
"correspondantes sans avoir à créer ces énormes vecteurs logiques (égal au "
"nombre de lignes d'un *data.table*), cette méthode est également très "
"**très efficace en termes de mémoire**."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 167 (header)
msgid "Summary"
msgstr "Résumé"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 168 (paragraph)
msgid ""
"In this vignette, we have learnt another method to subset rows in `i` by "
"keying a *data.table*. Setting keys allows us to perform blazing fast "
"subsets by using *binary search*. In particular, we have seen how to"
msgstr ""
"Dans cette vignette, nous avons appris une autre méthode pour subdiviser "
"les lignes dans `i` en utilisant les clés d'une *data.table*. Définir des "
"clés nous permet de créer des sous-ensembles extrêmement rapidement en "
"utilisant la *recherche binaire*. En particulier, nous avons vu comment"

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 169 (paragraph)
msgid "=====* set key and subset using the key on a *data.table*.====="
msgstr ""
"=====* définir une clé et utiliser cette clé pour créer des sous-ensembles "
"dans une *data.table*.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 170 (paragraph)
msgid ""
"=====* subset using keys which fetches *row indices* in `i`, but much "
"faster.====="
msgstr ""
"=====* utiliser les clés pour obtenir des *indices de lignes* en `i`, mais "
"beaucoup plus rapidement.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 171 (paragraph)
msgid ""
"=====* combine key based subsets with `j` and `by`. Note that the `j` and "
"`by` operations are exactly the same as before.====="
msgstr ""
"=====* combiner les sous-ensembles basés sur les clés avec `j` et `by`. "
"Notez que les opérations `j` et `by` sont exactement les mêmes que "
"précédemment.====="

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 172 (paragraph)
msgid ""
"Key based subsets are **incredibly fast** and are particularly useful when "
"the task involves *repeated subsetting*. But it may not be always desirable "
"to set key and physically reorder the *data.table*. In the next vignette, "
"we will address this using a *new* feature -- *secondary indexes*."
msgstr ""
"La création de sous-ensembles basés sur les clés est **incroyablement "
"rapide** et particulièrement utile lorsque la tâche implique de créer des "
"*sous-ensembles de manière répété*. Cependant, il peut ne pas toujours être "
"souhaitable de définir une clé et de réorganiser physiquement la *data."
"table*. Dans la prochaine vignette, nous aborderons ce problème en "
"utilisant une *nouvelle* fonctionnalité -- les *indices secondaires*."

#: fr/datatable-keys-fast-subset.Rmd.tmp:block 173 (code)
msgid ""
"#===== r, echo=FALSE\n"
"setDTthreads(.old.th)\n"
msgstr ""
"#===== r, echo=FALSE\n"
"setDTthreads(.old.th)\n"
