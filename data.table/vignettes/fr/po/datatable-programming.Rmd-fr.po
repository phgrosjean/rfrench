#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: \n"
"PO-Revision-Date: \n"
"Last-Translator: Elise Maigné <elise.maigne@inrae.fr>\n"
"Language-Team: \n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.5\n"

#: fr/datatable-programming.Rmd.tmp:block 1 (code)
msgid ""
"title: \"Programming on data.table\"\n"
"date: \"`r Sys.Date()`\"\n"
"output:\n"
"  markdown::html_format\n"
"vignette: >\n"
"  %\\VignetteIndexEntry{Programming on data.table}\n"
"  %\\VignetteEngine{knitr::knitr}\n"
"  \\usepackage[utf8]{inputenc}\n"
msgstr ""
"title: \"Programmation avec data.table\"\n"
"date: \"`r Sys.Date()`\"\n"
"output:\n"
"  markdown::html_format\n"
"vignette: >\n"
"  %\\VignetteIndexEntry{Programmation avec data.table}\n"
"  %\\VignetteEngine{knitr::knitr}\n"
"  \\usepackage[utf8]{inputenc}\n"

#: fr/datatable-programming.Rmd.tmp:block 2 (code)
msgid ""
"#===== r init, include = FALSE\n"
"require(data.table)\n"
"knitr::opts_chunk$set(\n"
"  comment = \"#\",\n"
"    error = FALSE,\n"
"     tidy = FALSE,\n"
"    cache = FALSE,\n"
" collapse = TRUE\n"
")\n"
msgstr ""
"#===== r init, include = FALSE\n"
"require(data.table)\n"
"knitr::opts_chunk$set(\n"
"  comment = \"#\",\n"
"    error = FALSE,\n"
"     tidy = FALSE,\n"
"    cache = FALSE,\n"
" collapse = TRUE\n"
")\n"

#: fr/datatable-programming.Rmd.tmp:block 3 (header)
msgid "Introduction"
msgstr "Introduction"

#: fr/datatable-programming.Rmd.tmp:block 4 (paragraph)
msgid ""
"`data.table`, from its very first releases, enabled the usage of `subset` "
"and `with` (or `within`) functions by defining the `[.data.table` method. "
"`subset` and `with` are base R functions that are useful for reducing "
"repetition in code, enhancing readability, and reducing number the total "
"characters the user has to type. This functionality is possible in R "
"because of a quite unique feature called *lazy evaluation*. This feature "
"allows a function to catch its arguments, before they are evaluated, and to "
"evaluate them in a different scope than the one in which they were called. "
"Let's recap usage of the `subset` function."
msgstr ""
"`data.table`, dès ses premières versions, a permis l'utilisation des "
"fonctions `subset` et `with` (ou `within`) en définissant la méthode `[."
"data.table`. `subset` et `with` sont des fonctions de base de R qui sont "
"utiles pour réduire les répétitions dans le code, améliorer la lisibilité, "
"et réduire le nombre total de caractères que l'utilisateur doit taper. "
"Cette fonctionnalité est possible dans R grâce à une fonction unique "
"appelée *évaluation paresseuse* ('lazy evaluation'). Cette fonctionnalité "
"permet à une fonction de récupérer ses arguments, avant qu'ils ne soient "
"évalués, et de les évaluer dans un cadre différente de celle dans laquelle "
"ils ont été appelés. Récapitulons l'utilisation de la fonction `subset`."

#: fr/datatable-programming.Rmd.tmp:block 5 (code)
msgid ""
"#===== r df_print, echo=FALSE\n"
"registerS3method(\"print\", \"data.frame\", function(x, ...) {\n"
"  base::print.data.frame(head(x, 2L), ...)\n"
"  cat(\"...\\n\")\n"
"  invisible(x)\n"
"})\n"
".opts = options(\n"
"  datatable.print.topn=2L,\n"
"  datatable.print.nrows=20L\n"
")\n"
msgstr ""
"#===== r df_print, echo=FALSE\n"
"registerS3method(\"print\", \"data.frame\", function(x, ...) {\n"
"  base::print.data.frame(head(x, 2L), ...)\n"
"  cat(\"...\\n\")\n"
"  invisible(x)\n"
"})\n"
".opts = options(\n"
"  datatable.print.topn=2L,\n"
"  datatable.print.nrows=20L\n"
")\n"

#: fr/datatable-programming.Rmd.tmp:block 6 (code)
msgid ""
"#===== r subset\n"
"subset(iris, Species == \"setosa\")\n"
msgstr ""
"#===== r subset\n"
"subset(iris, Species == \"setosa\")\n"

#: fr/datatable-programming.Rmd.tmp:block 7 (paragraph)
msgid ""
"Here, `subset` takes the second argument and evaluates it within the scope "
"of the `data.frame` given as its first argument. This removes the need for "
"variable repetition, making it less prone to errors, and makes the code "
"more readable."
msgstr ""
"Ici, `subset` prend le second argument et l'évalue dans le cadre du `data."
"frame` donné comme premier argument. Cela supprime le besoin de répéter les "
"variables, ce qui réduit le risque d'erreurs et rend le code plus lisible."

#: fr/datatable-programming.Rmd.tmp:block 8 (header)
msgid "Problem description"
msgstr "Description du problème"

#: fr/datatable-programming.Rmd.tmp:block 9 (paragraph)
msgid ""
"The problem with this kind of interface is that we cannot easily "
"parameterize the code that uses it. This is because the expressions passed "
"to those functions are substituted before being evaluated."
msgstr ""
"Le problème de ce type d'interface est qu'il n'est pas facile de paramétrer "
"le code qui l'utilise. En effet, les expressions passées à ces fonctions "
"sont substituées avant d'être évaluées."

#: fr/datatable-programming.Rmd.tmp:block 10 (header)
msgid "Example"
msgstr "Exemple"

#: fr/datatable-programming.Rmd.tmp:block 11 (code)
msgid ""
"#===== r subset_error, error=TRUE, purl=FALSE\n"
"my_subset = function(data, col, val) {\n"
"  subset(data, col == val)\n"
"}\n"
"my_subset(iris, Species, \"setosa\")\n"
msgstr ""
"#===== r subset_error, error=TRUE, purl=FALSE\n"
"my_subset = function(data, col, val) {\n"
"  subset(data, col == val)\n"
"}\n"
"my_subset(iris, Species, \"setosa\")\n"

#: fr/datatable-programming.Rmd.tmp:block 12 (header)
msgid "Approaches to the problem"
msgstr "Approches du problème"

#: fr/datatable-programming.Rmd.tmp:block 13 (paragraph)
msgid "There are multiple ways to work around this problem."
msgstr "Il existe plusieurs façons de contourner ce problème."

#: fr/datatable-programming.Rmd.tmp:block 14 (header)
msgid "Avoid *lazy evaluation*"
msgstr "Éviter les *lazy evaluation*"

#: fr/datatable-programming.Rmd.tmp:block 15 (paragraph)
msgid ""
"The easiest workaround is to avoid *lazy evaluation* in the first place, "
"and fall back to less intuitive, more error-prone approaches like "
"`df[[\"variable\"]]`, etc."
msgstr ""
"La solution la plus simple est d'éviter les *évaluations paresseuses* "
"('lazy evaluation'), et de se rabattre sur des approches moins intuitives "
"et plus sujettes aux erreurs comme `df[[\"variable\"]]`, etc."

#: fr/datatable-programming.Rmd.tmp:block 16 (code)
msgid ""
"#===== r subset_nolazy\n"
"my_subset = function(data, col, val) {\n"
"  data[data[[col]] == val & !is.na(data[[col]]), ]\n"
"}\n"
"my_subset(iris, col = \"Species\", val = \"setosa\")\n"
msgstr ""
"#===== r subset_nolazy\n"
"my_subset = function(data, col, val) {\n"
"  data[data[[col]] == val & !is.na(data[[col]]), ]\n"
"}\n"
"my_subset(iris, col = \"Species\", val = \"setosa\")\n"

#: fr/datatable-programming.Rmd.tmp:block 17 (paragraph)
msgid ""
"Here, we compute a logical vector of length `nrow(iris)`, then this vector "
"is supplied to the `i` argument of `[.data.frame` to perform ordinary "
"\"logical vector\"-based subsetting. To align with `subset()`, which also "
"drops NAs, we need to include an additional use of `data[[col]]` to catch "
"that. It works well enough for this simple example, but it lacks "
"flexibility, introduces variable repetition, and requires user to change "
"the function interface to pass the column name as a character rather than "
"unquoted symbol. The more complex the expression we need to parameterize, "
"the less practical this approach becomes."
msgstr ""
"Ici, nous calculons un vecteur logique de longueur `nrow(iris)`, puis ce "
"vecteur est fourni à l'argument `i` de `[.data.frame` pour effectuer un "
"sous-ensemble ordinaire basé sur un \"vecteur logique\". Pour s'aligner "
"avec `subset()`, qui supprime aussi les NA, nous devons inclure une "
"utilisation supplémentaire de `data[[col]]`. Cela fonctionne assez bien "
"pour cet exemple simple, mais cela manque de flexibilité, introduit des "
"répétitions de variables, et demande à l'utilisateur de changer l'interface "
"de la fonction pour passer le nom de la colonne comme un caractère plutôt "
"qu'un symbole sans guillemet. Plus l'expression à paramétrer est complexe, "
"moins cette approche est pratique."

#: fr/datatable-programming.Rmd.tmp:block 18 (header)
msgid "Use of `parse` / `eval`"
msgstr "Utilisation de `parse` / `eval`"

#: fr/datatable-programming.Rmd.tmp:block 19 (paragraph)
msgid ""
"This method is usually preferred by newcomers to R as it is, perhaps, the "
"most straightforward conceptually. This way requires producing the required "
"expression using string concatenation, parsing it, and then evaluating it."
msgstr ""
"Cette méthode est généralement préférée par les nouveaux venus dans R, car "
"elle est peut-être la plus simple sur le plan conceptuel. Cette méthode "
"consiste à produire l'expression requise à l'aide de la concaténation de "
"chaînes, à l'analyser, puis à l'évaluer."

#: fr/datatable-programming.Rmd.tmp:block 20 (code)
msgid ""
"#===== r subset_parse\n"
"my_subset = function(data, col, val) {\n"
"  data = deparse(substitute(data))\n"
"  col  = deparse(substitute(col))\n"
"  val  = paste0(\"'\", val, \"'\")\n"
"  text = paste0(\"subset(\", data, \", \", col, \" == \", val, \")\")\n"
"  eval(parse(text = text)[[1L]])\n"
"}\n"
"my_subset(iris, Species, \"setosa\")\n"
msgstr ""
"#===== r subset_parse\n"
"my_subset = function(data, col, val) {\n"
"  data = deparse(substitute(data))\n"
"  col = deparse(substitute(col))\n"
"  val = paste0(\"'\", val, \"'\")\n"
"  text = paste0(\"subset(\", data, \", \", col, \" == \", val, \")\")\n"
"  eval(parse(text = text)[[1L]])\n"
"}\n"
"my_subset(iris, Species, \"setosa\")\n"

#: fr/datatable-programming.Rmd.tmp:block 21 (paragraph)
msgid ""
"We have to use `deparse(substitute(...))` to catch the actual names of "
"objects passed to function, so we can construct the `subset` function call "
"using those original names. Although this provides unlimited flexibility "
"with relatively low complexity, **use of `eval(parse(...))` should be "
"avoided**. The main reasons are:"
msgstr ""
"Nous devons utiliser `deparse(substitute(...))` pour récupérer les noms "
"réels des objets passés à la fonction, afin de pouvoir construire l'appel à "
"la fonction `subset` en utilisant ces noms originaux. Bien que cela offre "
"une flexibilité illimitée avec une complexité relativement faible, "
"**l'utilisation de `eval(parse(...))` devrait être évitée**. Les raisons "
"principales sont les suivantes :"

#: fr/datatable-programming.Rmd.tmp:block 22 (paragraph)
msgid ""
"=====- lack of syntax validation===== =====- [vulnerability to code "
"injection](https://github.com/Rdatatable/data.table/"
"issues/2655#issuecomment-376781159)===== =====- the existence of better "
"alternatives====="
msgstr ""
"=====- absence de validation syntaxique===== =====- [vulnérabilité à "
"l'injection de code](https://github.com/Rdatatable/data.table/"
"issues/2655#issuecomment-376781159)===== =====- existence de meilleures "
"alternatives====="

#: fr/datatable-programming.Rmd.tmp:block 23 (paragraph)
msgid ""
"Martin Machler, R Project Core Developer, [once said](https://stackoverflow."
"com/a/40164111/2490497):"
msgstr ""
"Martin Machler, R Project Core Developer, [a dit](https://stackoverflow.com/"
"a/40164111/2490497) :"

#: fr/datatable-programming.Rmd.tmp:block 24 (quote)
msgid ""
"Sorry but I don't understand why too many people even think a string was "
"something that could be evaluated. You must change your mindset, really. "
"Forget all connections between strings on one side and expressions, calls, "
"evaluation on the other side. The (possibly) only connection is via "
"`parse(text = ....)` and all good R programmers should know that this is "
"rarely an efficient or safe means to construct expressions (or calls). "
"Rather learn more about `substitute()`, `quote()`, and possibly the power "
"of using `do.call(substitute, ......)`."
msgstr ""
"Désolé, mais je ne comprends pas pourquoi tant de gens pensent qu'une "
"chaîne de caractères est quelque chose qui peut être évalué. Il faut "
"vraiment changer d'état d'esprit. Oubliez toutes les connexions entre les "
"chaînes d'un côté et les expressions, les appels, l'évaluation de l'autre "
"côté. La (possible) seule connexion est via `parse(text = ....)` et tous "
"les bons programmeurs R devraient savoir que c'est rarement un moyen "
"efficace ou sûr de construire des expressions (ou des appels). Apprenez "
"plutôt à connaître `substitute()`, `quote()`, et peut-être la puissance de "
"l'utilisation de `do.call(substitute, ......)`."

#: fr/datatable-programming.Rmd.tmp:block 25 (header)
msgid "Computing on the language"
msgstr "Calculs sur le langage"

#: fr/datatable-programming.Rmd.tmp:block 26 (paragraph)
msgid ""
"The aforementioned functions, along with some others (including `as.call`, "
"`as.name`/`as.symbol`, `bquote`, and `eval`), can be categorized as "
"functions to *compute on the language*, as they operate on *language* "
"objects (e.g. `call`, `name`/`symbol`)."
msgstr ""
"Les fonctions mentionnées ci-dessus, ainsi que quelques autres (y compris "
"`as.call`, `as.name`/`as.symbol`, `bquote`, et `eval`), peuvent être "
"catégorisées comme des fonctions pour *calculer sur le langage*, "
"puisqu'elles opèrent sur des objets du *langage* (par exemple `call`, "
"`name`/`symbol`)."

#: fr/datatable-programming.Rmd.tmp:block 27 (code)
msgid ""
"#===== r subset_substitute\n"
"my_subset = function(data, col, val) {\n"
"  eval(substitute(subset(data, col == val)))\n"
"}\n"
"my_subset(iris, Species, \"setosa\")\n"
msgstr ""
"#===== r subset_substitute\n"
"my_subset = function(data, col, val) {\n"
"  eval(substitute(subset(data, col == val)))\n"
"}\n"
"my_subset(iris, Species, \"setosa\")\n"

#: fr/datatable-programming.Rmd.tmp:block 28 (paragraph)
msgid ""
"Here, we used the base R `substitute` function to transform the call "
"`subset(data, col == val)` into `subset(iris, Species == \"setosa\")` by "
"substituting `data`, `col`, and `val` with their original names (or values) "
"from their parent environment. The benefits of this approach to the "
"previous ones should be clear. Note that because we operate at the level of "
"language objects, and don't have to resort to string manipulation, we refer "
"to this as *computing on the language*. There is a dedicated chapter on "
"*Computing on the language* in [R language manual](https://cran.r-project."
"org/doc/manuals/r-release/R-lang.html). Although it is not necessary for "
"*programming on data.table*, we encourage readers to read this chapter for "
"the sake of better understanding this powerful and unique feature of R "
"language."
msgstr ""
"Ici, nous avons utilisé la fonction de base R `substitute` pour transformer "
"l'appel `subset(data, col = val)` en `subset(iris, Species == \"setosa\")` "
"en remplaçant `data`, `col`, et `val` par leurs noms (ou valeurs) d'origine "
"dans leur environnement parent. Les avantages de cette approche par rapport "
"aux précédentes devraient être clairs. Notez que parce que nous opérons au "
"niveau des objets du langage, et que nous n'avons pas à recourir à la "
"manipulation de chaînes de caractères, nous nous référons à cela comme "
"*calcul sur le langage* ('computing on the language'). Il existe un "
"chapitre dédié au *calcul sur le langage* dans le [Manuel du langage R]"
"(https://cran.r-project.org/doc/manuals/r-release/R-lang.html). Bien qu'il "
"ne soit pas nécessaire pour *programmer sur data.table*, nous encourageons "
"les lecteurs à lire ce chapitre afin de mieux comprendre cette "
"fonctionnalité puissante et unique du langage R."

#: fr/datatable-programming.Rmd.tmp:block 29 (header)
msgid "Use third party packages"
msgstr "Utiliser des packages tiers"

#: fr/datatable-programming.Rmd.tmp:block 30 (paragraph)
msgid ""
"There are third party packages that can achieve what base R computing on "
"the language routines do (`pryr`, `lazyeval` and `rlang`, to name a few)."
msgstr ""
"Il existe des packages tiers qui peuvent réaliser ce que les routines de "
"calcul du R de base sur le langage font (`pryr`, `lazyeval` et `rlang`, "
"pour n'en citer que quelques-uns)."

#: fr/datatable-programming.Rmd.tmp:block 31 (paragraph)
msgid ""
"Though these can be helpful, we will be discussing a `data.table`-unique "
"approach here."
msgstr ""
"Bien qu'ils puissent être utiles, nous discuterons ici d'une approche "
"propre à `data.table`."

#: fr/datatable-programming.Rmd.tmp:block 32 (header)
msgid "Programming on data.table"
msgstr "Programmation sur data.table"

#: fr/datatable-programming.Rmd.tmp:block 33 (paragraph)
msgid ""
"Now that we've established the proper way to parameterize code that uses "
"*lazy evaluation*, we can move on to the main subject of this vignette, "
"*programming on data.table*."
msgstr ""
"Maintenant que nous avons établi la bonne façon de paramétrer le code qui "
"utilise l'évaluation paresseuse ('*lazy evaluation*'), nous pouvons passer "
"au sujet principal de cette vignette, *la programmation sur data.table*."

#: fr/datatable-programming.Rmd.tmp:block 34 (paragraph)
msgid ""
"Starting from version 1.15.0, data.table provides a robust mechanism for "
"parameterizing expressions passed to the `i`, `j`, and `by` (or `keyby`) "
"arguments of `[.data.table`. It is built upon the base R `substitute` "
"function, and mimics its interface. Here, we introduce `substitute2` as a "
"more robust and more user-friendly version of base R's `substitute`. For a "
"complete list of differences between `base::substitute` and `data.table::"
"substitute2` please read the [`substitute2` manual](https://rdatatable."
"gitlab.io/data.table/library/data.table/html/substitute2.html)."
msgstr ""
"A partir de la version 1.15.0, data.table fournit un mécanisme robuste pour "
"paramétrer les expressions passées aux arguments `i`, `j`, et `by` (ou "
"`keyby`) de `[.data.table`. Il est construit sur la fonction de base R "
"`substitute`, et imite son interface. Nous présentons ici `substitute2` "
"comme une version plus robuste et plus conviviale de la fonction "
"`substitute` de R de base. Pour une liste complète des différences entre "
"`base::substitute` et `data.table::substitute2`, veuillez lire le [manuel "
"`substitute2`](https://rdatatable.gitlab.io/data.table/library/data.table/"
"html/substitute2.html)."

#: fr/datatable-programming.Rmd.tmp:block 35 (header)
msgid "Substituting variables and names"
msgstr "Substitution de variables et de noms"

#: fr/datatable-programming.Rmd.tmp:block 36 (paragraph)
msgid ""
"Let's say we want to have a general function that applies a function to sum "
"of two arguments that has been applied another function. As a concrete "
"example, below we have a function to compute the length of the hypotenuse "
"in a right triangle, knowing length of its legs."
msgstr ""
"Disons que nous voulons une fonction générale qui applique une fonction à "
"la somme de deux arguments auxquels une autre fonction a été appliquée. "
"Comme exemple concret, nous avons ci-dessous une fonction qui calcule la "
"longueur de l'hypoténuse dans un triangle droit, connaissant la longueur de "
"ses côtés."

#: fr/datatable-programming.Rmd.tmp:block 37 (paragraph)
msgid "${\\displaystyle c = \\sqrt{a^2 + b^2}}$"
msgstr "${{displaystyle c = \\sqrt{a^2 + b^2}}$"

#: fr/datatable-programming.Rmd.tmp:block 38 (code)
msgid ""
"#===== r hypotenuse\n"
"square = function(x) x^2\n"
"quote(\n"
"  sqrt(square(a) + square(b))\n"
")\n"
msgstr ""
"#===== r hypotenuse\n"
"square = function(x) x^2\n"
"quote(\n"
"  sqrt(square(a) + square(b))\n"
")\n"

#: fr/datatable-programming.Rmd.tmp:block 39 (paragraph)
msgid ""
"The goal is the make every name in the above call able to be passed as a "
"parameter."
msgstr ""
"L'objectif est de faire en sorte que chaque nom dans l'appel ci-dessus "
"puisse être passé en tant que paramètre."

#: fr/datatable-programming.Rmd.tmp:block 40 (code)
msgid ""
"#===== r hypotenuse_substitute2\n"
"substitute2(\n"
"  outer(inner(var1) + inner(var2)),\n"
"  env = list(\n"
"    outer = \"sqrt\",\n"
"    inner = \"square\",\n"
"    var1 = \"a\",\n"
"    var2 = \"b\"\n"
"  )\n"
")\n"
msgstr ""
"#===== r hypotenuse_substitute2\n"
"substitute2(\n"
"  outer(inner(var1) + inner(var2)),\n"
"  env = list(\n"
"    outer = \"sqrt\",\n"
"    inner = \"square\",\n"
"    var1 = \"a\",\n"
"    var2 = \"b\"\n"
"  )\n"
")\n"

#: fr/datatable-programming.Rmd.tmp:block 41 (paragraph)
msgid ""
"We can see in the output that both the functions names, as well as the "
"names of the variables passed to those functions, have been replaced. We "
"used `substitute2` for convenience. In this simple case, base R's "
"`substitute` could have been used as well, though it would've required "
"usage of `lapply(env, as.name)`."
msgstr ""
"Nous pouvons voir dans la sortie que les noms des fonctions, ainsi que les "
"noms des variables passées à ces fonctions, ont été remplacés. Nous avons "
"utilisé `substitute2` par commodité. Dans ce cas simple, le `substitute` de "
"base R aurait pu être utilisé aussi, bien qu'il aurait fallu utiliser "
"`lapply(env, as.name)`."

#: fr/datatable-programming.Rmd.tmp:block 42 (paragraph)
msgid ""
"Now, to use substitution inside `[.data.table`, we don't need to call the "
"`substitute2` function. As it is now being used internally, all we have to "
"do is to provide `env` argument, the same way as we've provided it to the "
"`substitute2` function in the example above. Substitution can be applied to "
"the `i`, `j` and `by` (or `keyby`) arguments of the `[.data.table` method. "
"Note that setting the `verbose` argument to `TRUE` can be used to print "
"expressions after substitution is applied. This is very useful for "
"debugging."
msgstr ""
"Maintenant, pour utiliser la substitution à l'intérieur de `[.data.table`, "
"nous n'avons pas besoin d'appeler la fonction `substitute2`. Comme elle est "
"maintenant utilisée en interne, tout ce que nous avons à faire est de "
"fournir l'argument `env`, de la même manière que nous l'avons fourni à la "
"fonction `substitute2` dans l'exemple ci-dessus. La substitution peut être "
"appliquée aux arguments `i`, `j` et `by` (ou `keyby`) de la méthode `[.data."
"table`. Notez que le fait de mettre l'argument `verbose` à `TRUE` peut être "
"utilisé pour afficher les expressions après que la substitution ait été "
"appliquée. Ceci est très utile pour le débogage."

#: fr/datatable-programming.Rmd.tmp:block 43 (paragraph)
msgid ""
"Let's use the `iris` data set as a demonstration. Just as an example, let's "
"pretend we want to compute the `Sepal.Hypotenuse`, treating the sepal width "
"and length as if they were legs of a right triangle."
msgstr ""
"Utilisons le jeu de données `iris` comme démonstration. A titre d'exemple, "
"imaginons que nous voulions calculer la `Sepal.Hypotenuse`, en traitant la "
"largeur et la longueur du sépale comme s'il s'agissait des côtés d'un "
"triangle rectangle."

#: fr/datatable-programming.Rmd.tmp:block 44 (code)
msgid ""
"#===== r hypotenuse_datatable\n"
"DT = as.data.table(iris)\n"
"\n"
"str(\n"
"  DT[, outer(inner(var1) + inner(var2)),\n"
"     env = list(\n"
"       outer = \"sqrt\",\n"
"       inner = \"square\",\n"
"       var1 = \"Sepal.Length\",\n"
"       var2 = \"Sepal.Width\"\n"
"    )]\n"
")\n"
"\n"
"# return as a data.table\n"
"DT[, .(Species, var1, var2, out = outer(inner(var1) + inner(var2))),\n"
"   env = list(\n"
"     outer = \"sqrt\",\n"
"     inner = \"square\",\n"
"     var1 = \"Sepal.Length\",\n"
"     var2 = \"Sepal.Width\",\n"
"     out = \"Sepal.Hypotenuse\"\n"
"  )]\n"
msgstr ""
"#===== r hypotenuse_datable\n"
"DT = as.data.table(iris)\n"
"\n"
"str(\n"
"  DT[, outer(inner(var1) + inner(var2)),\n"
"     env = list(\n"
"       outer = \"sqrt\",\n"
"       inner = \"square\",\n"
"       var1 = \"Sepal.Length\",\n"
"       var2 = \"Sepal.Width\"\n"
"    )]\n"
")\n"
"\n"
"# retourner le résultat sous forme de data.table\n"
"DT[, .(Species, var1, var2, out = outer(inner(var1) + inner(var2))),\n"
"   env = list(\n"
"     outer = \"sqrt\",\n"
"     inner = \"square\",\n"
"     var1 = \"Sepal.Length\",\n"
"     var2 = \"Sepal.Width\",\n"
"     out = \"Sepal.Hypotenuse\"\n"
"  )]\n"

#: fr/datatable-programming.Rmd.tmp:block 45 (paragraph)
msgid ""
"In the last call, we added another parameter, `out = \"Sepal.Hypotenuse\"`, "
"that conveys the intended name of output column. Unlike base R's "
"`substitute`, `substitute2` will handle the substitution of the names of "
"call arguments, as well."
msgstr ""
"Dans le dernier appel, nous avons ajouté un autre paramètre, `out = \"Sepal."
"Hypotenuse\"`, qui transmet le nom prévu de la colonne de sortie. "
"Contrairement à `substitute` de base R, `substitute2` gérera également la "
"substitution des noms des arguments d'appel."

#: fr/datatable-programming.Rmd.tmp:block 46 (paragraph)
msgid "Substitution works on `i` and `by` (or `keyby`), as well."
msgstr "La substitution fonctionne également pour `i` et `by` (ou `keyby`)."

#: fr/datatable-programming.Rmd.tmp:block 47 (code)
msgid ""
"#===== r hypotenuse_datatable_i_j_by\n"
"DT[filter_col %in% filter_val,\n"
"   .(var1, var2, out = outer(inner(var1) + inner(var2))),\n"
"   by = by_col,\n"
"   env = list(\n"
"     outer = \"sqrt\",\n"
"     inner = \"square\",\n"
"     var1 = \"Sepal.Length\",\n"
"     var2 = \"Sepal.Width\",\n"
"     out = \"Sepal.Hypotenuse\",\n"
"     filter_col = \"Species\",\n"
"     filter_val = I(c(\"versicolor\", \"virginica\")),\n"
"     by_col =  \"Species\"\n"
"  )]\n"
msgstr ""
"#===== r hypotenuse_datable_i_j_by\n"
"DT[filter_col %in% filter_val,\n"
"   .(var1, var2, out = outer(inner(var1) + inner(var2))),\n"
"   by = by_col,\n"
"   env = list(\n"
"     outer = \"sqrt\",\n"
"     inner = \"square\",\n"
"     var1 = \"Sepal.Length\",\n"
"     var2 = \"Sepal.Width\",\n"
"     out = \"Sepal.Hypotenuse\",\n"
"     filter_col = \"Species\",\n"
"     filter_val = I(c(\"versicolor\", \"virginica\")),\n"
"     by_col = \"Species\"\n"
"  )]\n"

#: fr/datatable-programming.Rmd.tmp:block 48 (header)
msgid "Substitute variables and character values"
msgstr "Remplacer des variables et des valeurs de caractères"

#: fr/datatable-programming.Rmd.tmp:block 49 (paragraph)
msgid ""
"In the above example, we have seen a convenient feature of `substitute2`: "
"automatic conversion from strings into names/symbols. An obvious question "
"arises: what if we actually want to substitute a parameter with a "
"*character* value, so as to have base R `substitute` behaviour. We provide "
"a mechanism to escape automatic conversion by wrapping the elements into "
"base R `I()` call. The `I` function marks an object as *AsIs*, preventing "
"its arguments from character-to-symbol automatic conversion. (Read the `?"
"AsIs` documentation for more details.) If base R behaviour is desired for "
"the whole `env` argument, then it's best to wrap the whole argument in "
"`I()`. Alternatively, each list element can be wrapped in `I()` "
"individually. Let's explore both cases below."
msgstr ""
"Dans l'exemple ci-dessus, nous avons vu une fonctionnalité pratique de "
"`substitute2` : la conversion automatique de chaînes de caractères en noms/"
"symboles. Une question évidente se pose : que se passe-t-il si nous voulons "
"substituer un paramètre par une valeur *caractère*, afin d'avoir le "
"comportement `substitute` de R de base. Nous fournissons un mécanisme pour "
"échapper à la conversion automatique en enveloppant les éléments dans "
"l'appel de base R `I()`. La fonction `I` marque un objet comme *AsIs*, "
"empêchant ses arguments d'être convertis automatiquement de caractère à "
"symbole. (Lisez la documentation `?AsIs` pour plus de détails.) Si le "
"comportement de R de base est souhaité pour l'ensemble de l'argument `env`, "
"alors il est préférable d'envelopper l'ensemble de l'argument dans `I()`. "
"Alternativement, chaque élément de la liste peut être enveloppé dans `I()` "
"individuellement. Explorons les deux cas ci-dessous."

#: fr/datatable-programming.Rmd.tmp:block 50 (code)
msgid ""
"#===== r rank\n"
"substitute(    # base R behaviour\n"
"  rank(input, ties.method = ties),\n"
"  env = list(input = as.name(\"Sepal.Width\"), ties = \"first\")\n"
")\n"
"\n"
"substitute2(   # mimicking base R's \"substitute\" using \"I\"\n"
"  rank(input, ties.method = ties),\n"
"  env = I(list(input = as.name(\"Sepal.Width\"), ties = \"first\"))\n"
")\n"
"\n"
"substitute2(   # only particular elements of env are used \"AsIs\"\n"
"  rank(input, ties.method = ties),\n"
"  env = list(input = \"Sepal.Width\", ties = I(\"first\"))\n"
")\n"
msgstr ""
"#===== r rank\n"
"substitute( # comportement de base de R\n"
"  rank(input, ties.method = ties),\n"
"  env = list(input = as.name(\"Sepal.Width\"), ties = \"first\")\n"
")\n"
"\n"
"substitute2( # imite le comportement \"substitute\" de base R en utilisant "
"\"I\"\n"
"  rank(input, ties.method = ties),\n"
"  env = I(list(input = as.name(\"Sepal.Width\"), ties = \"first\"))\n"
")\n"
"\n"
"substitute2( # seuls certains éléments de env sont utilisés \"AsIs\"\n"
"  rank(input, ties.method = ties),\n"
"  env = list(input = \"Sepal.Width\", ties = I(\"first\"))\n"
")\n"

#: fr/datatable-programming.Rmd.tmp:block 51 (paragraph)
msgid ""
"Note that conversion works recursively on each list element, including the "
"escape mechanism of course."
msgstr ""
"Notez que la conversion s'effectue de manière récursive sur chaque élément "
"de la liste, y compris le mécanisme d'échappement bien sûr."

#: fr/datatable-programming.Rmd.tmp:block 52 (code)
msgid ""
"#===== r substitute2_recursive\n"
"substitute2(   # all are symbols\n"
"  f(v1, v2),\n"
"  list(v1 = \"a\", v2 = list(\"b\", list(\"c\", \"d\")))\n"
")\n"
"substitute2(   # 'a' and 'd' should stay as character\n"
"  f(v1, v2),\n"
"  list(v1 = I(\"a\"), v2 = list(\"b\", list(\"c\", I(\"d\"))))\n"
")\n"
msgstr ""
"#===== r substitute2_recursive\n"
"substitute2( # tous sont des symboles\n"
"  f(v1, v2),\n"
"  list(v1 = \"a\", v2 = list(\"b\", list(\"c\", \"d\")))\n"
")\n"
"substitute2( # 'a' et 'd' doivent rester des chaines de caractères\n"
"  f(v1, v2),\n"
"  list(v1 = I(\"a\"), v2 = list(\"b\", list(\"c\", I(\"d\"))))\n"
")\n"

#: fr/datatable-programming.Rmd.tmp:block 53 (header)
msgid "Substituting lists of arbitrary length"
msgstr "Substituer des listes de longueur arbitraire"

#: fr/datatable-programming.Rmd.tmp:block 54 (paragraph)
msgid ""
"The example presented above illustrates a neat and powerful way to make "
"your code more dynamic. However, there are many other much more complex "
"cases that a developer might have to deal with. One common problem handling "
"a list of arguments of arbitrary length."
msgstr ""
"L'exemple présenté ci-dessus illustre un moyen propre et puissant de rendre "
"votre code plus dynamique. Cependant, il existe de nombreux autres cas "
"beaucoup plus complexes auxquels un développeur peut être confronté. Un "
"problème courant consiste à gérer une liste d'arguments de longueur "
"arbitraire."

#: fr/datatable-programming.Rmd.tmp:block 55 (paragraph)
msgid ""
"An obvious use case could be to mimic `.SD` functionality by injecting a "
"`list` call into the `j` argument."
msgstr ""
"Un cas d'utilisation évident pourrait être d'imiter la fonctionnalité `.SD` "
"en injectant un appel `list` dans l'argument `j`."

#: fr/datatable-programming.Rmd.tmp:block 56 (code)
msgid ""
"#===== r splice_sd\n"
"cols = c(\"Sepal.Length\", \"Sepal.Width\")\n"
"DT[, .SD, .SDcols = cols]\n"
msgstr ""
"#===== r splice_sd\n"
"cols = c(\"Sepal.Length\", \"Sepal.Width\")\n"
"DT[, .SD, .SDcols = cols]\n"

#: fr/datatable-programming.Rmd.tmp:block 57 (paragraph)
msgid ""
"Having `cols` parameter, we'd want to splice it into a `list` call, making "
"`j` argument look like in the code below."
msgstr ""
"Avec le paramètre `cols`, nous voudrions l'intégrer dans un appel `list`, "
"en faisant ressembler l'argument `j` au code ci-dessous."

#: fr/datatable-programming.Rmd.tmp:block 58 (code)
msgid ""
"#===== r splice_tobe\n"
"DT[, list(Sepal.Length, Sepal.Width)]\n"
msgstr ""
"#===== r splice_tobe\n"
"DT[, list(Sepal.Length, Sepal.Width)]\n"

#: fr/datatable-programming.Rmd.tmp:block 59 (paragraph)
msgid ""
"*Splicing* is an operation where a list of objects have to be inlined into "
"an expression as a sequence of arguments to call. In base R, splicing "
"`cols` into a `list` can be achieved using `as.call(c(quote(list), "
"lapply(cols, as.name)))`. Additionally, starting from R 4.0.0, there is new "
"interface for such an operation in the `bquote` function."
msgstr ""
"Le *'splicing'* est une opération où une liste d'objets doit être intégrée "
"dans une expression comme une séquence d'arguments à appeler. Dans R de "
"base, le 'splicing' de `cols` dans une `liste` peut être réalisé en "
"utilisant `as.call(c(quote(list), lapply(cols, as.name)))`. De plus, à "
"partir de R 4.0.0, il y a une nouvelle interface pour une telle opération "
"dans la fonction `bquote`."

#: fr/datatable-programming.Rmd.tmp:block 60 (paragraph)
msgid ""
"In data.table, we make it easier by automatically *enlist*-ing a list of "
"objects into a list call with those objects. This means that any `list` "
"object inside the `env` list argument will be turned into list `call`, "
"making the API for that use case as simple as presented below."
msgstr ""
"Dans data.table, nous facilitons les choses en transformant automatiquement "
"en liste une liste d'objets en un appel de liste avec ces objets. Cela "
"signifie que tout objet `list` à l'intérieur de l'argument `env` list sera "
"transformé en `call` list, rendant l'API pour ce cas d'utilisation aussi "
"simple que présenté ci-dessous."

#: fr/datatable-programming.Rmd.tmp:block 61 (code)
msgid ""
"#===== r splice_datatable\n"
"# this works\n"
"DT[, j,\n"
"   env = list(j = as.list(cols)),\n"
"   verbose = TRUE]\n"
"\n"
"# this will not work\n"
"#DT[, list(cols),\n"
"#   env = list(cols = cols)]\n"
msgstr ""
"#===== r splice_datable\n"
"# cela fonctionne\n"
"DT[, j,\n"
"   env = list(j = as.list(cols)),\n"
"   verbose = TRUE]\n"
"\n"
"# cela ne fonctionnera pas\n"
"#DT[, list(cols),\n"
"# env = list(cols = cols)]\n"

#: fr/datatable-programming.Rmd.tmp:block 62 (paragraph)
msgid ""
"It is important to provide a call to `as.list`, rather than simply a list, "
"inside the `env` list argument, as is shown in the above example."
msgstr ""
"Il est important de fournir un appel à `as.list`, plutôt qu'une simple "
"liste, à l'intérieur de l'argument list de `env`, comme le montre l'exemple "
"ci-dessus."

#: fr/datatable-programming.Rmd.tmp:block 63 (paragraph)
msgid "Let's explore *enlist*-ing in more detail."
msgstr ""
"Examinons plus en détail la question de l'ajout à la liste ('*enlist*-ing')."

#: fr/datatable-programming.Rmd.tmp:block 64 (code)
msgid ""
"#===== r splice_enlist\n"
"DT[, j,  # data.table automatically enlists nested lists into list calls\n"
"   env = list(j = as.list(cols)),\n"
"   verbose = TRUE]\n"
"\n"
"DT[, j,  # turning the above 'j' list into a list call\n"
"   env = list(j = quote(list(Sepal.Length, Sepal.Width))),\n"
"   verbose = TRUE]\n"
"\n"
"DT[, j,  # the same as above but accepts character vector\n"
"   env = list(j = as.call(c(quote(list), lapply(cols, as.name)))),\n"
"   verbose = TRUE]\n"
msgstr ""
"#===== r splice_enlist\n"
"DT[, j, # data.table met automatiquement en liste les listes imbriquées "
"dans des appels de liste\n"
"   env = list(j = as.list(cols)),\n"
"   verbose = TRUE]\n"
"\n"
"DT[, j, # transformer la liste 'j' ci-dessus en un appel de liste\n"
"   env = list(j = quote(list(Sepal.Length, Sepal.Width))),\n"
"   verbose = TRUE]\n"
"\n"
"DT[, j, # la même chose que ci-dessus mais accepte un vecteur de "
"caractères\n"
"   env = list(j = as.call(c(quote(list), lapply(cols, as.name)))),\n"
"   verbose = TRUE]\n"

#: fr/datatable-programming.Rmd.tmp:block 65 (paragraph)
msgid ""
"Now let's try to pass a list of symbols, rather than list call to those "
"symbols. We'll use `I()` to escape automatic *enlist*-ing but, as this will "
"also turn off character to symbol conversion, we also have to use `as.name`."
msgstr ""
"Essayons maintenant de passer une liste de symboles, plutôt qu'un appel de "
"liste à ces symboles. Nous utiliserons `I()` pour échapper à la mise en "
"liste (*enlist*-ing) automatique, mais comme cela désactivera aussi la "
"conversion des caractères en symboles, nous devrons aussi utiliser `as."
"name`."

#: fr/datatable-programming.Rmd.tmp:block 66 (code)
msgid ""
"#===== r splice_not, error=TRUE, purl=FALSE\n"
"DT[, j,  # list of symbols\n"
"   env = I(list(j = lapply(cols, as.name))),\n"
"   verbose = TRUE]\n"
"\n"
"DT[, j,  # again the proper way, enlist list to list call automatically\n"
"   env = list(j = as.list(cols)),\n"
"   verbose = TRUE]\n"
msgstr ""
"#===== r splice_not, error=TRUE, purl=FALSE\n"
"DT[, j, # liste de symboles\n"
"   env = I(list(j = lapply(cols, as.name))),\n"
"   verbose = VRAI]\n"
"\n"
"DT[, j, # encore une fois de la meilleure façon, ajout automatique de la "
"liste à l'appel de liste\n"
"   env = list(j = as.list(cols)),\n"
"   verbose = TRUE]\n"

#: fr/datatable-programming.Rmd.tmp:block 67 (paragraph)
msgid ""
"Note that both expressions, although visually appearing to be the same, are "
"not identical."
msgstr ""
"Notez que les deux expressions, bien qu'elles semblent visuellement "
"identiques, ne le sont pas."

#: fr/datatable-programming.Rmd.tmp:block 68 (code)
msgid ""
"#===== r splice_substitute2_not\n"
"str(substitute2(j, env = I(list(j = lapply(cols, as.name)))))\n"
"\n"
"str(substitute2(j, env = list(j = as.list(cols))))\n"
msgstr ""
"#===== r splice_substitute2_not\n"
"str(substitute2(j, env = I(list(j = lapply(cols, as.name)))))\n"
"\n"
"str(substitute2(j, env = list(j = as.list(cols))))\n"

#: fr/datatable-programming.Rmd.tmp:block 69 (paragraph)
msgid ""
"For more detailed explanation on that matter, please see the examples in "
"the [`substitute2` documentation](https://rdatatable.gitlab.io/data.table/"
"library/data.table/html/substitute2.html)."
msgstr ""
"Pour une explication plus détaillée à ce sujet, veuillez consulter les "
"exemples dans la [documentation `substitute2`](https://rdatatable.gitlab.io/"
"data.table/library/data.table/html/substitute2.html)."

#: fr/datatable-programming.Rmd.tmp:block 70 (header)
msgid "Substitution of a complex query"
msgstr "Substitution d'une requête complexe"

#: fr/datatable-programming.Rmd.tmp:block 71 (paragraph)
msgid ""
"Let's take, as an example of a more complex function, calculating root mean "
"square."
msgstr ""
"Prenons l'exemple d'une fonction plus complexe, le calcul de la moyenne "
"quadratique."

#: fr/datatable-programming.Rmd.tmp:block 72 (paragraph)
msgid ""
"${\\displaystyle x_{\\text{RMS}}={\\sqrt{{\\frac{1}{n}}\\left(x_{1}"
"^{2}+x_{2}^{2}+\\cdots +x_{n}^{2}\\right)}}}$"
msgstr ""
"${\\displaystyle x_{\\text{RMS}}={\\sqrt{{\\frac{1}{n}}\\left(x_{1}"
"^{2}+x_{2}^{2}+\\cdots +x_{n}^{2}\\right)}}}$"

#: fr/datatable-programming.Rmd.tmp:block 73 (paragraph)
msgid ""
"It takes arbitrary number of variables on input, but now we cannot just "
"*splice* a list of arguments into a list call because each of those "
"arguments have to be wrapped in a `square` call. In this case, we have to "
"*splice* by hand rather than relying on data.table's automatic *enlist*."
msgstr ""
"Il prend un nombre arbitraire de variables en entrée, mais maintenant nous "
"ne pouvons pas simplement ajouter (splice) une liste d'arguments dans un "
"appel de liste parce que chacun de ces arguments doit être enveloppé dans "
"un appel `square`. Dans ce cas, nous devons faire l'opération à la main "
"plutôt que de compter sur la transformation automatique en liste "
"(*'enlist'*) de data.table."

#: fr/datatable-programming.Rmd.tmp:block 74 (paragraph)
msgid ""
"First, we have to construct calls to the `square` function for each of the "
"variables (see `inner_calls`). Then, we have to reduce the list of calls "
"into a single call, having a nested sequence of `+` calls (see "
"`add_calls`). Lastly, we have to substitute the constructed call into the "
"surrounding expression (see `rms`)."
msgstr ""
"Tout d'abord, nous devons construire des appels à la fonction `square` pour "
"chacune des variables (voir `inner_calls`). Ensuite, nous devons réduire la "
"liste des appels en un seul appel, avec une séquence imbriquée d'appels `+` "
"(voir `add_calls`). Enfin, nous devons substituer l'appel construit dans "
"l'expression environnante (voir `rms`)."

#: fr/datatable-programming.Rmd.tmp:block 75 (code)
msgid ""
"#===== r complex\n"
"outer = \"sqrt\"\n"
"inner = \"square\"\n"
"vars = c(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width"
"\")\n"
"\n"
"syms = lapply(vars, as.name)\n"
"to_inner_call = function(var, fun) call(fun, var)\n"
"inner_calls = lapply(syms, to_inner_call, inner)\n"
"print(inner_calls)\n"
"\n"
"to_add_call = function(x, y) call(\"+\", x, y)\n"
"add_calls = Reduce(to_add_call, inner_calls)\n"
"print(add_calls)\n"
"\n"
"rms = substitute2(\n"
"  expr = outer((add_calls) / len),\n"
"  env = list(\n"
"    outer = outer,\n"
"    add_calls = add_calls,\n"
"    len = length(vars)\n"
"  )\n"
")\n"
"print(rms)\n"
"\n"
"str(\n"
"  DT[, j, env = list(j = rms)]\n"
")\n"
"\n"
"# same, but skipping last substitute2 call and using add_calls directly\n"
"str(\n"
"  DT[, outer((add_calls) / len),\n"
"     env = list(\n"
"       outer = outer,\n"
"       add_calls = add_calls,\n"
"       len = length(vars)\n"
"    )]\n"
")\n"
"\n"
"# return as data.table\n"
"j = substitute2(j, list(j = as.list(setNames(nm = c(vars, \"Species\", \"rms"
"\")))))\n"
"j[[\"rms\"]] = rms\n"
"print(j)\n"
"DT[, j, env = list(j = j)]\n"
"\n"
"# alternatively\n"
"j = as.call(c(\n"
"  quote(list),\n"
"  lapply(setNames(nm = vars), as.name),\n"
"  list(Species = as.name(\"Species\")),\n"
"  list(rms = rms)\n"
"))\n"
"print(j)\n"
"DT[, j, env = list(j = j)]\n"
msgstr ""
"#===== r complexe\n"
"outer = \"sqrt\"\n"
"inner = \"square\"\n"
"vars = c(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width"
"\")\n"
"\n"
"syms = lapply(vars, as.name)\n"
"to_inner_call = function(var, fun) call(fun, var)\n"
"inner_calls = lapply(syms, to_inner_call, inner)\n"
"print(inner_calls)\n"
"\n"
"to_add_call = function(x, y) call(\"+\", x, y)\n"
"add_calls = Reduce(to_add_call, inner_calls)\n"
"print(add_calls)\n"
"\n"
"rms = substitute2(\n"
"  expr = outer((add_calls) / len),\n"
"  env = list(\n"
"    outer = outer,\n"
"    add_calls = add_calls,\n"
"    len = length(vars)\n"
"  )\n"
")\n"
"print(rms)\n"
"\n"
"str(\n"
"  DT[, j, env = list(j = rms)]\n"
")\n"
"\n"
"# idem, mais en sautant le dernier appel à substitute2 et en utilisant "
"directement add_calls\n"
"str(\n"
"  DT[, outer((add_calls) / len),\n"
"     env = list(\n"
"       outer = outer,\n"
"       add_calls = add_calls,\n"
"       len = length(vars)\n"
"    )]\n"
")\n"
"\n"
"# retourner le résultat en tant que data.table\n"
"j = substitute2(j, list(j = as.list(setNames(nm = c(vars, \"Species\", \"rms"
"\")))))\n"
"j[[\"rms\"]] = rms\n"
"print(j)\n"
"DT[, j, env = list(j = j)]\n"
"\n"
"# ou alors :\n"
"j = as.call(c(\n"
"  quote(list),\n"
"  lapply(setNames(nm = vars), as.name),\n"
"  list(Species = as.name(\"Species\")),\n"
"  list(rms = rms)\n"
"))\n"
"print(j)\n"
"DT[, j, env = list(j = j)]\n"

#: fr/datatable-programming.Rmd.tmp:block 76 (header)
msgid "Retired interfaces"
msgstr "Interfaces supprimées"

#: fr/datatable-programming.Rmd.tmp:block 77 (paragraph)
msgid ""
"In `[.data.table`, it is also possible to use other mechanisms for variable "
"substitution or for passing quoted expressions. These include `get` and "
"`mget` for inline injection of variables by providing their names as "
"strings, and `eval` that tells `[.data.table` that the expression we passed "
"into an argument is a quoted expression and that it should be handled "
"differently. Those interfaces should now be considered retired and we "
"recommend using the new `env` argument, instead."
msgstr ""
"Dans `[.data.table`, il est aussi possible d'utiliser d'autres mécanismes "
"pour la substitution de variables ou pour passer des expressions entre "
"guillemets. Ceux-ci incluent `get` et `mget` pour l'injection en ligne de "
"variables en fournissant leurs noms sous forme de chaînes, et `eval` qui "
"indique à `[.data.table` que l'expression passée en argument est une "
"expression entre guillemets et qu'elle doit être traitée différemment. Ces "
"interfaces doivent maintenant être considérées comme retirées et nous "
"recommandons d'utiliser le nouvel argument `env` à la place."

#: fr/datatable-programming.Rmd.tmp:block 78 (header)
msgid "`get`"
msgstr "`get`"

#: fr/datatable-programming.Rmd.tmp:block 79 (code)
msgid ""
"#===== r old_get\n"
"v1 = \"Petal.Width\"\n"
"v2 = \"Sepal.Width\"\n"
"\n"
"DT[, .(total = sum(get(v1), get(v2)))]\n"
"\n"
"DT[, .(total = sum(v1, v2)),\n"
"   env = list(v1 = v1, v2 = v2)]\n"
msgstr ""
"#===== r old_get\n"
"v1 = \"Petal.Width\"\n"
"v2 = \"Sepal.Width\"\n"
"\n"
"DT[, .(total = sum(get(v1), get(v2)))]\n"
"\n"
"DT[, .(total = sum(v1, v2)),\n"
"   env = list(v1 = v1, v2 = v2)]\n"

#: fr/datatable-programming.Rmd.tmp:block 80 (header)
msgid "`mget`"
msgstr "`mget`"

#: fr/datatable-programming.Rmd.tmp:block 81 (code)
msgid ""
"#===== r old_mget\n"
"v = c(\"Petal.Width\", \"Sepal.Width\")\n"
"\n"
"DT[, lapply(mget(v), mean)]\n"
"\n"
"DT[, lapply(v, mean),\n"
"   env = list(v = as.list(v))]\n"
"\n"
"DT[, lapply(v, mean),\n"
"   env = list(v = as.list(setNames(nm = v)))]\n"
msgstr ""
"#===== r old_mget\n"
"v = c(\"Petal.Width\", \"Sepal.Width\")\n"
"\n"
"DT[, lapply(mget(v), mean)]\n"
"\n"
"DT[, lapply(v, mean),\n"
"   env = list(v = as.list(v))]\n"
"\n"
"DT[, lapply(v, mean),\n"
"   env = list(v = as.list(setNames(nm = v)))]\n"

#: fr/datatable-programming.Rmd.tmp:block 82 (header)
msgid "`eval`"
msgstr "`eval`"

#: fr/datatable-programming.Rmd.tmp:block 83 (paragraph)
msgid ""
"Instead of using `eval` function we can provide quoted expression into the "
"element of `env` argument, no extra `eval` call is needed then."
msgstr ""
"Au lieu d'utiliser la fonction `eval`, nous pouvons fournir une expression "
"citée dans l'élément de l'argument `env`, aucun appel supplémentaire à "
"`eval` n'est alors nécessaire."

#: fr/datatable-programming.Rmd.tmp:block 84 (code)
msgid ""
"#===== r old_eval\n"
"cl = quote(\n"
"  .(Petal.Width = mean(Petal.Width), Sepal.Width = mean(Sepal.Width))\n"
")\n"
"\n"
"DT[, eval(cl)]\n"
"\n"
"DT[, cl, env = list(cl = cl)]\n"
msgstr ""
"#===== r old_eval\n"
"cl = quote(\n"
"  .(Petal.Width = mean(Petal.Width), Sepal.Width = mean(Sepal.Width))\n"
")\n"
"\n"
"DT[, eval(cl)]\n"
"\n"
"DT[, cl, env = list(cl = cl)]\n"

#: fr/datatable-programming.Rmd.tmp:block 85 (code)
msgid ""
"#===== r cleanup, echo=FALSE\n"
"options(.opts)\n"
"registerS3method(\"print\", \"data.frame\", base::print.data.frame)\n"
msgstr ""
"#===== r cleanup, echo=FALSE\n"
"options(.opts)\n"
"registerS3method(\"print\", \"data.frame\", base::print.data.frame)\n"
