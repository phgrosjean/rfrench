#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: \n"
"PO-Revision-Date: \n"
"Last-Translator: Christian Wiat <w9204-rs@yahoo.com>\n"
"Language-Team: \n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Generator: Poedit 3.4.4\n"

#: d.Rmd:block 3 (paragraph)
msgid ""
"This vignette introduces the `data.table` syntax, its general form, how to "
"*subset* rows, *select and compute* on columns, and perform aggregations *by "
"group*. Familiarity with the `data.frame` data structure from base R is "
"useful, but not essential to follow this vignette."
msgstr ""
"Cette vignette présente la syntaxe de `data.table` , sa forme générale, "
"comment *extraire les lignes*, *sélectionner et faire des opérations* sur les "
"colonnes, et réaliser des agrégations *par groupe*. Il est avantageux d'être "
"familiarisé avec la structure de données `data.frame` de base du R, mais cela "
"n'est pas essentiel pour suivre cette vignette."

#: d.Rmd:block 4 (header)
msgid "Data analysis using `data.table`"
msgstr "Analyser des données en utilisant `data.table`"

#: d.Rmd:block 5 (paragraph)
msgid ""
"Data manipulation operations such as *subset*, *group*, *update*, *join*, "
"etc. are all inherently related. Keeping these *related operations together* "
"allows for:"
msgstr ""
"Les opérations concernant le traitement des données telles que *subset*, "
"*group*, *update*, *join*, etc. sont toutes intimement liées. En regroupant "
"*ces opérations apparentées* cela nous permet :"

#: d.Rmd:block 7 (paragraph)
msgid ""
"Briefly, if you are interested in reducing *programming* and *compute* time "
"tremendously, then this package is for you. The philosophy that `data.table` "
"adheres to makes this possible. Our goal is to illustrate it through this "
"series of vignettes."
msgstr ""
"En résumé, si vous souhaitez réduire drastiquement le temps de "
"*programmation* et de *compilation*, alors ce package est fait pour vous. "
"C'est la philosophie suivie par  `data.table` pour rendre cela possible. "
"Notre but est d'illustrer ceci au travers de cette série de vignettes."

#: d.Rmd:block 8 (header)
msgid "Data {#data}"
msgstr "Données {#data}"

#: d.Rmd:block 9 (paragraph)
msgid ""
"In this vignette, we will use [NYC-flights14](https://raw.githubusercontent."
"com/Rdatatable/data.table/master/vignettes/flights14.csv) data obtained from "
"the [flights](https://github.com/arunsrinivasan/flights) package (available "
"on GitHub only). It contains On-Time flights data from the Bureau of "
"Transportation Statistics for all the flights that departed from New York "
"City airports in 2014 (inspired by [nycflights13](https://github.com/"
"tidyverse/nycflights13)). The data is available only for Jan-Oct'14."
msgstr ""
"Dans cette vignette, nous utiliseront les données [NYC-flights14](https://raw."
"githubusercontent.com/Rdatatable/data.table/master/vignettes/flights14.csv) "
"obtenues du package [flights](https://github.com/arunsrinivasan/flights) "
"(disponible sur GitHub seulement). Il contient les horaires des vols d'avions "
"du Bureau of Transportation Statistics à propos de tous les vols partant des "
"aéroports de New York City en 2014 (inspiré de [nycflights13](https://github."
"com/tidyverse/nycflights13)). Les données ne concernent que les mois de "
"janvier à octobre 2014."

#: d.Rmd:block 10 (paragraph)
msgid ""
"We can use `data.table`'s fast-and-friendly file reader `fread` to load "
"`flights` directly as follows:"
msgstr ""
"Vous pouvez utiliser le lecteur de fichiers rapide et convivial `fread` de "
"`data.table` pour charger `flights` ditectement ainsi :"

#: d.Rmd:block 13 (paragraph)
msgid ""
"Aside: `fread` accepts `http` and `https` URLs directly, as well as operating "
"system commands such as `sed` and `awk` output. See `?fread` for examples."
msgstr ""
"A noter : `fread` accepte directement les URLS `http` et `https`, ainsi que "
"les commandes système opérationnelles telles que les sorties de `sed` et "
"`awk`. Voir `?fread` pour les exemples."

#: d.Rmd:block 14 (header)
msgid "Introduction"
msgstr "Introduction"

#: d.Rmd:block 15 (paragraph)
msgid "In this vignette, we will"
msgstr "Dans cette vignette, nous allons"

#: d.Rmd:block 17 (header)
msgid "1. Basics {#basics-1}"
msgstr "1. Les bases {#basics-1}"

#: d.Rmd:block 18 (header)
msgid "a) What is `data.table`? {#what-is-datatable-1a}"
msgstr "a) `data.table` c'est quoi ? {#what-is-datatable-1a}"

#: d.Rmd:block 19 (paragraph)
msgid ""
"`data.table` is an R package that provides **an enhanced version** of a `data."
"frame`, the standard data structure for storing data in `base` R. In the "
"[Data](#data) section above, we saw how to create a `data.table` using "
"`fread()`, but alternatively we can also create one using the `data.table()` "
"function. Here is an example:"
msgstr ""
"`data.table` est un package R qui fournit **une version étendue** d'un `data."
"frame`, qui est la structure de données standard pour stocker des données "
"dans la `base` R. Dans la [Data](#data) section ci-dessus, nous avons vu "
"comment créer une `data.table` avec `fread()`, mais on peut aussi en créer "
"une en utilisant la fonction `data.table()` . Voici un exemple :"

#: d.Rmd:block 21 (paragraph)
msgid ""
"You can also convert existing objects to a `data.table` using `setDT()` (for "
"`data.frame` and `list` structures) or `as.data.table()` (for other "
"structures). For more details pertaining to the difference (goes beyond the "
"scope of this vignette), please see `?setDT` and `?as.data.table`."
msgstr ""
"Vous pouvez aussi convertir des objets existants en une `data.table` en "
"utilisant `setDT()` (pour les structures `data.frame` et `list`) ou `as.data."
"table()` (pour les autres structures). Pour les autres détails concernant les "
"différences (ce qui est hors du champ de cette vignette), voir `?setDT` et `?"
"as.data.table`."

#: d.Rmd:block 22 (header)
msgid "Note that:"
msgstr "Notez que :"

#: d.Rmd:block 24 (header)
msgid ""
"b) General form - in what way is a `data.table` *enhanced*? {#enhanced-1b}"
msgstr ""
"b) Forme générale - dans quel sens la `data.table` est-elle *étendue* ? "
"{#enhanced-1b}"

#: d.Rmd:block 25 (paragraph)
msgid ""
"In contrast to a `data.frame`, you can do *a lot more* than just subsetting "
"rows and selecting columns within the frame of a `data.table`, i.e., within "
"`[ ... ]` (NB: we might also refer to writing things inside `DT[...]` as "
"\"querying `DT`\", as an analogy or in relevance to SQL). To understand it we "
"will have to first look at the *general form* of the `data.table` syntax, as "
"shown below:"
msgstr ""
"Par rapport à un `data.frame`, vous pouvez  faire *beaucoup plus de choses* "
"qu'extraire des lignes et sélectionner des colonnes dans la structure d'une "
"`data.table`, par exemple, avec `[ ... ]` (Notez bien : nous pourrions aussi "
"faire référence à écrire quelque chose dans `DT[...]` comme \"interroger "
"`DT`\", par analogie ou similairement à SQL). Pour le comprendre il faut "
"d'abord que nous regardions la *forme générale* de la syntaxe `data.table`, "
"comme indiqué ci-dessous :"

#: d.Rmd:block 27 (paragraph)
msgid ""
"Users with an SQL background might perhaps immediately relate to this syntax."
msgstr ""
"Les utilisateurs ayant des connaissances SQL feront peut être directement le "
"lien avec cette syntaxe."

#: d.Rmd:block 28 (header)
msgid "The way to read it (out loud) is:"
msgstr "La manière de le lire (à haute voix) est :"

#: d.Rmd:block 29 (paragraph)
msgid ""
"Take `DT`, subset/reorder rows using `i`, then calculate `j`, grouped by `by`."
msgstr ""
"Utiliser `DT`, extraire ou trier les lignes en utilisant `i`, puis calculer "
"`j`, grouper avec `by`."

#: d.Rmd:block 30 (paragraph)
msgid ""
"Let's begin by looking at `i` and `j` first - subsetting rows and operating "
"on columns."
msgstr ""
"Commençons par voir `i` et `j` d'abord - en indiçant les lignes et en "
"travaillant sur les colonnes."

#: d.Rmd:block 31 (header)
msgid "c) Subset rows in `i` {#subset-i-1c}"
msgstr "c) Regrouper les lignes en `i` {#subset-i-1c}"

#: d.Rmd:block 32 (header)
msgid ""
"-- Get all the flights with \"JFK\" as the origin airport in the month of "
"June."
msgstr ""
"-- Obtenir tous les vols qui ont \"JFK\" comme aéroport de départ pendant le "
"mois de juin."

#: d.Rmd:block 35 (header)
msgid "-- Get the first two rows from `flights`. {#subset-rows-integer}"
msgstr ""
"-- Récupérer les deux premières lignes de `flights`. {#subset-rows-integer}"

#: d.Rmd:block 38 (header)
msgid ""
"-- Sort `flights` first by column `origin` in *ascending* order, and then by "
"`dest` in *descending* order:"
msgstr ""
"-- Trier `flights` d'abord sur la colonne `origin` dans l'ordre *ascending*, "
"puis par `dest` dans l'ordre *descendant* :"

#: d.Rmd:block 39 (paragraph)
msgid "We can use the R function `order()` to accomplish this."
msgstr "Nous pouvons utiliser la fonction R `order()` pour faire cela."

#: d.Rmd:block 41 (header)
msgid "`order()` is internally optimised"
msgstr "`order()` est optimisé en interne"

#: d.Rmd:block 43 (paragraph)
msgid ""
"We will discuss `data.table`'s fast order in more detail in the *`data.table` "
"internals* vignette."
msgstr ""
"Nous discuterons de l'ordonnancement rapide de la `data.table` plus en "
"détails dans la vignette *fonctionnement interne de `data.table` internals*."

#: d.Rmd:block 44 (header)
msgid "d) Select column(s) in `j` {#select-j-1d}"
msgstr "d) Sélection de colonne(s) dans `j` {#select-j-1d}"

#: d.Rmd:block 45 (header)
msgid "-- Select `arr_delay` column, but return it as a *vector*."
msgstr ""
"-- Sélectionner la colonne `arr_delay`, mais la renvoyer en tant que *vector*."

#: d.Rmd:block 48 (header)
msgid "-- Select `arr_delay` column, but return as a `data.table` instead."
msgstr ""
"-- Sélectionner la colonne `arr_delay`, mais la renvoyer en tant que `data."
"table`."

#: d.Rmd:block 51 (paragraph)
msgid ""
"A `data.table` (and a `data.frame` too) is internally a `list` as well, with "
"the stipulation that each element has the same length and the `list` has a "
"`class` attribute. Allowing `j` to return a `list` enables converting and "
"returning `data.table` very efficiently."
msgstr ""
"Un `data.table` (et également un `data.frame`) est aussi en interne une "
"`list` , avec la caractéristique que chaque élément a la même longueur et que "
"la `list` possède un attribut `class`. En permettant à `j` de renvoyer une "
"`list` cela permet de convertir et de renvoyer des `data.table` très "
"efficacement."

#: d.Rmd:block 52 (header)
msgid "Tip: {#tip-1}"
msgstr "Conseil : {#tip-1}"

#: d.Rmd:block 53 (paragraph)
msgid ""
"As long as `j-expression` returns a `list`, each element of the list will be "
"converted to a column in the resulting `data.table`. This makes `j` quite "
"powerful, as we will see shortly. It is also very important to understand "
"this for when you'd like to make more complicated queries!!"
msgstr ""
"Tant que `j-expression` renvoie une `list`, chaque élément de la liste sera "
"converti en colonne dans la `data.table` résultante. Ce qui fait que `j` est "
"très puissant, comme nous le verrons bientôt. Il est aussi très important de "
"comprendre cela dans le cas où vous auriez à faire des requêtes plus "
"compliquées !!"

#: d.Rmd:block 54 (header)
msgid "-- Select both `arr_delay` and `dep_delay` columns."
msgstr "-- Sélectionner à la fois les colonnes `arr_delay` et `dep_delay`."

#: d.Rmd:block 57 (header)
msgid ""
"-- Select both `arr_delay` and `dep_delay` columns *and* rename them to "
"`delay_arr` and `delay_dep`."
msgstr ""
"-- Sélectionner à la fois les colonnes `arr_delay` et `dep_delay` *et* les "
"renommer en `delay_arr` et `delay_dep`."

#: d.Rmd:block 58 (paragraph)
msgid ""
"Since `.()` is just an alias for `list()`, we can name columns as we would "
"while creating a `list`."
msgstr ""
"Comme `.()` est juste un alias pour `list()`, nous pouvons donner un nom "
"quelconque aux colonnes comme si on créait une `list`."

#: d.Rmd:block 60 (header)
msgid "e) Compute or *do* in `j`"
msgstr "e) Calcul ou *do* dans `j`"

#: d.Rmd:block 61 (header)
msgid "-- How many trips have had total delay < 0?"
msgstr "-- Combien de voyages on eu un retard total < 0 ?"

#: d.Rmd:block 63 (header)
msgid "What's happening here?"
msgstr "Que se passe-t-il dans ce cas ?"

#: d.Rmd:block 65 (header)
msgid "f) Subset in `i` *and* do in `j`"
msgstr "f) Sous-ensemble de `i` *et* do dans `j`"

#: d.Rmd:block 66 (header)
msgid ""
"-- Calculate the average arrival and departure delay for all flights with "
"\"JFK\" as the origin airport in the month of June."
msgstr ""
"-- Calculer le nombre moyen de retards des arrivées et des départs pour tous "
"les vols au départ de l'aéroport \"JFK\" pendant le mois de juin."

#: d.Rmd:block 69 (paragraph)
msgid ""
"Because the three main components of the query (`i`, `j` and `by`) are "
"*together* inside `[...]`, `data.table` can see all three and optimise the "
"query altogether *before evaluation*, rather than optimizing each separately. "
"We are able to therefore avoid the entire subset (i.e., subsetting the "
"columns *besides* `arr_delay` and `dep_delay`), for both speed and memory "
"efficiency."
msgstr ""
"Parce que les trois composants principaux de la requête (`i`, `j` et `by`) "
"figurent *ensemble* dans `[...]`, `data.table` peut les voir tous trois et "
"optimiser la requête dans sa totalité *avant l'évaluation*, plutôt que "
"d'optimiser chacun séparément. Par conséquent nous pouvons éviter le sous-"
"ensemble complet (par exemple trier les colonnes *annexes* `arr_delay` et "
"`dep_delay`), pour la rapidité et l'efficacité de la mémoire."

#: d.Rmd:block 70 (header)
msgid ""
"-- How many trips have been made in 2014 from \"JFK\" airport in the month of "
"June?"
msgstr ""
"-- Combien de voyages ont été réalisés en 2014 au départ de l'aéroport "
"\"JFK\" au mois de juin ?"

#: d.Rmd:block 72 (paragraph)
msgid ""
"The function `length()` requires an input argument. We just need to compute "
"the number of rows in the subset. We could have used any other column as the "
"input argument to `length()`. This approach is reminiscent of `SELECT "
"COUNT(dest) FROM flights WHERE origin = 'JFK' AND month = 6` in SQL."
msgstr ""
"La fonction `length()` nécessite un argument d'entrée. Il suffit juste de "
"calculer le nombre de lignes du sous-ensemble. On aurait pu utiliser "
"n'importe quelle colonne comme argument d'entrée de `length()`. Cette "
"approche est une réminiscence de `SELECT COUNT(dest) FROM flights WHERE "
"origin = 'JFK' AND month = 6` en SQL."

#: d.Rmd:block 73 (paragraph)
msgid ""
"This type of operation occurs quite frequently, especially while grouping (as "
"we will see in the next section), to the point where `data.table` provides a "
"*special symbol* `.N` for it."
msgstr ""
"Ce type d'opération arrive assez fréquement, particulièrement lors des "
"regroupements (comme nous le verrons dans la section suivante), au point que "
"`data.table` fournit un *symbole spécial* `.N` pour cela."

#: d.Rmd:block 74 (header)
msgid "g) Handle non-existing elements in `i`"
msgstr "g) Gérer les éléments absents dans `i`"

#: d.Rmd:block 75 (header)
msgid "-- What happens when querying for non-existing elements?"
msgstr "-- Que se passe-t-il quand on interroge des éléments non-existants ?"

#: d.Rmd:block 76 (paragraph)
msgid ""
"When querying a `data.table` for elements that do not exist, the behavior "
"differs based on the method used."
msgstr ""
"Lorsque vous interrogez une `data.table` pour des éléments qui n'existent "
"pas, le comportement dépend de la méthode utilisée."

#: d.Rmd:block 78 (unordered list)
msgid ""
"This performs a right join on the key column `x`, resulting in a row with `d` "
"and `NA` for columns not found. When using `setkeyv`, the table is sorted by "
"the specified keys and an internal index is created, enabling binary search "
"for efficient subsetting."
msgstr ""
"Ceci réalise une jointure parfaite sur la colonne clé `x`, fournissant une "
"rangée avec `d` et `NA` pour les colonnes absentes. En utilisant `setkeyv`, "
"la table est triée en fonction des clés fournies et un index interne est "
"créé, permettant une recherche binaire et des performances optimisées."

#: d.Rmd:block 78 (unordered list)
msgid ""
"This performs a standard subset operation that does not find any matching "
"rows and thus returns an empty `data.table`."
msgstr ""
"Ceci réalise une opération standard de sous-ensemble qui ne trouve aucune "
"correspondance de lignes et donc renvoie une `data.table` vide."

#: d.Rmd:block 78 (unordered list)
msgid ""
"For exact matches without `NA` for non-existing elements, use `nomatch=NULL`:"
msgstr ""
"Pour une correspondance stricte sans `NA` pour les éléments absents, utiliser "
"`nomatch=NULL` :"

#: d.Rmd:block 79 (paragraph)
msgid ""
"Understanding these behaviors can help prevent confusion when dealing with "
"non-existing elements in your data."
msgstr ""
"En assimilant ces comportements, cela vous ôtera toute confusion lorsque vous "
"trouverez des éléments absents parmi vos données."

#: d.Rmd:block 80 (header)
msgid "Special symbol `.N`: {#special-N}"
msgstr "Symbol spécial `.N`: {#special-N}"

#: d.Rmd:block 81 (paragraph)
msgid ""
"`.N` is a special built-in variable that holds the number of observations *in "
"the current group*. It is particularly useful when combined with `by` as "
"we'll see in the next section. In the absence of group by operations, it "
"simply returns the number of rows in the subset."
msgstr ""
"`.N` est une variable interne spéciale qui contient le nombre d'observations "
"*dans le groupe actuel*. Elle est particulièrement utile combinée avec `by` "
"comme nous le verrons dans la prochaine section. S'il n'y a pas de groupe "
"pour les opérations, le nombre de lignes dans le sous-ensemble sera "
"simplement renvoyé."

#: d.Rmd:block 82 (paragraph)
msgid ""
"Now that we now, we can now accomplish the same task by using `.N` as follows:"
msgstr ""
"Maintenant que nous savons, nous pouvons accomplir la même tâche en utilisant "
"`.N` ainsi :"

#: d.Rmd:block 85 (paragraph)
msgid ""
"We could have accomplished the same operation by doing `nrow(flights[origin "
"== \"JFK\" & month == 6L])`. However, it would have to subset the entire "
"`data.table` first corresponding to the *row indices* in `i` *and then* "
"return the rows using `nrow()`, which is unnecessary and inefficient. We will "
"cover this and other optimisation aspects in detail under the *`data.table` "
"design* vignette."
msgstr ""
"On aurait pu faire la même opération en écrivant `nrow(flights[origin == "
"\"JFK\" & month == 6L])`. Néanmoins il aurait fallu d'abord dissocier la "
"`data.table` entière  en fonction des *indices de lignes* dans `i` *puis* "
"renvoyer les lignes en utilisant `nrow()`, ce qui est inutile et pas "
"efficace. Nous aborderons en détails ce sujet et d'autres aspects de "
"l'optimisation dans la vignette *architecture de `data.table`*."

#: d.Rmd:block 86 (header)
msgid ""
"h) Great! But how can I refer to columns by names in `j` (like in a `data."
"frame`)? {#refer_j}"
msgstr ""
"h) Super !  Mais comment référencer les colonnes par nom dans `j` (comme avec "
"un `data.frame`) ? {#refer_j}"

#: d.Rmd:block 87 (paragraph)
msgid ""
"If you're writing out the column names explicitly, there's no difference "
"compared to a `data.frame` (since v1.9.8)."
msgstr ""
"Si vous imprimez le nom des colonnes explicitement, il n'y a pas de "
"différence avec un `data.frame` (depuis v1.9.8)."

#: d.Rmd:block 88 (header)
msgid "-- Select both `arr_delay` and `dep_delay` columns the `data.frame` way."
msgstr ""
"-- Sélectionner simultanément les colonnes `arr_delay` et `dep_delay` à la "
"manière d'un `data.frame`."

#: d.Rmd:block 90 (paragraph)
msgid ""
"If you've stored the desired columns in a character vector, there are two "
"options: Using the `..` prefix, or using the `with` argument."
msgstr ""
"Si vous avez stocké les colonnes souhaitées dans un vecteur de caractères, il "
"y a deux options : utiliser le préfixe `..` , ou utiliser l'argument `with`."

#: d.Rmd:block 91 (header)
msgid "-- Select columns named in a variable using the `..` prefix"
msgstr ""
"-- Sélectionnez les colonnes nommées dans une variable en utilisant le "
"préfixe `..`"

#: d.Rmd:block 93 (paragraph)
msgid ""
"For those familiar with the Unix terminal, the `..` prefix should be "
"reminiscent of the \"up-one-level\" command, which is analogous to what's "
"happening here -- the `..` signals to `data.table` to look for the "
"`select_cols` variable \"up-one-level\", i.e., within the global environment "
"in this case."
msgstr ""
"Pour les habitués du terminal Unix, le préfixe `..` devrait rappeler la "
"commande de \"remontée d'un niveau\", qui est analogue à ce qui se passe ici "
"-- le `..` demande à `data.table` de chercher la variable `select_cols` \"un "
"nivau au-dessus\",  c'est à  dire dans ce cas, dans l'envronnement global."

#: d.Rmd:block 94 (header)
msgid "-- Select columns named in a variable using `with = FALSE`"
msgstr ""
"-- Sélectionner les colonnes nommées dans une variable en utilisant `with = "
"FALSE`"

#: d.Rmd:block 96 (paragraph)
msgid ""
"The argument is named `with` after the R function `with()` because of similar "
"functionality. Suppose you have a `data.frame` `DF` and you'd like to subset "
"all rows where `x > 1`. In `base` R you can do the following:"
msgstr ""
"L'argument s'appelle `with` d'après la fonction R `with()` à cause de la "
"fonctionnalité similaire. Supposez que vous ayiez une `data.frame` `DF` et "
"que vous vouliez dissocier toutes les lignes où `x > 1`. Dans la `base` R "
"vous pouvez écrire :"

#: d.Rmd:block 99 (paragraph)
msgid ""
"`with = TRUE` is the default in `data.table` because we can do much more by "
"allowing `j` to handle expressions - especially when combined with `by`, as "
"we'll see in a moment."
msgstr ""
"`with = TRUE` est la valeur par défaut dans `data.table` car nous pouvons "
"faire plus en permettant à `j` de gérer des expressions - particulièrement en "
"combinant avec `by`, comme nous le verrons dans un instant."

#: d.Rmd:block 100 (header)
msgid "2. Aggregations"
msgstr "2. Aggrégations"

#: d.Rmd:block 101 (paragraph)
msgid ""
"We've already seen `i` and `j` from `data.table`'s general form in the "
"previous section. In this section, we'll see how they can be combined "
"together with `by` to perform operations *by group*. Let's look at some "
"examples."
msgstr ""
"Nous avons déjà vu `i` et `j` dans la forme générale d'une `data.table` dans "
"la secton précédente. Dans cette section, nous allons voir comment ils "
"peuvent être combinés ensemble avec `by` pour réaliser des opérations *par "
"groupe*. Voyons quelques exemples."

#: d.Rmd:block 102 (header)
msgid "a) Grouping using `by`"
msgstr "a) Regrouper avec `by`"

#: d.Rmd:block 103 (header)
msgid ""
"-- How can we get the number of trips corresponding to each origin airport?"
msgstr "-- Comment obtenir le nombre de voyages au départ de chaque aéroport ?"

#: d.Rmd:block 106 (header)
msgid ""
"-- How can we calculate the number of trips for each origin airport for "
"carrier code `\"AA\"`? {#origin-.N}"
msgstr ""
"-- Comment calculer le nombre de voyages au départ de chaque aéroport pour le "
"transporteur ayant le code `\"AA\"`? {#origin-.N}"

#: d.Rmd:block 107 (paragraph)
msgid "The unique carrier code `\"AA\"` corresponds to *American Airlines Inc.*"
msgstr ""
"Le code unique de transporteur `\"AA\"` correspond à *American Airlines Inc.*"

#: d.Rmd:block 110 (header)
msgid ""
"-- How can we get the total number of trips for each `origin, dest` pair for "
"carrier code `\"AA\"`? {#origin-dest-.N}"
msgstr ""
"-- Comment obtenir le nombre total de voyages pour chaque paire `origin, "
"dest` du transporteur ayant pour code `\"AA\"`? {#origin-dest-.N}"

#: d.Rmd:block 113 (header)
msgid ""
"-- How can we get the average arrival and departure delay for each `orig,"
"dest` pair for each month for carrier code `\"AA\"`? {#origin-dest-month}"
msgstr ""
"-- Comment obtenir les valeurs moyennes menselles du retard des arrivées et "
"des départs pour chaque paire `orig,dest` pour le transporteur ayant le code "
"`\"AA\"`? {#origin-dest-month}"

#: d.Rmd:block 116 (paragraph)
msgid ""
"Now what if we would like to order the result by those grouping columns "
"`origin`, `dest` and `month`?"
msgstr ""
"Maintenant qu'adviendrait-il si nous voulions trier les résultats en groupant "
"les colonnes `origin`, `dest` et `month` ?"

#: d.Rmd:block 117 (header)
msgid "b) Sorted `by`: `keyby`"
msgstr "b) Tri `by` : `keyby`"

#: d.Rmd:block 118 (paragraph)
msgid ""
"`data.table` retaining the original order of groups is intentional and by "
"design. There are cases when preserving the original order is essential. But "
"at times we would like to automatically sort by the variables in our grouping."
msgstr ""
"`data.table` conserve l'ordre original des groupes; c'est intentionnel et "
"défini à la conception. Il existe des cas où conserver l'ordre original est "
"essentiel. Mais à certains moments, nous aimerions trier automatiquement par "
"variables dans notre regroupement."

#: d.Rmd:block 119 (header)
msgid "-- So how can we directly order by all the grouping variables?"
msgstr ""
"-- Donc comment pourrions-nous trier directement sur toutes les variables de "
"regroupement ?"

#: d.Rmd:block 122 (paragraph)
msgid ""
"**Keys:** Actually `keyby` does a little more than *just ordering*. It also "
"*sets a key* after ordering by setting an `attribute` called `sorted`."
msgstr ""
"**Clés :** actuellement `keyby` en fait un peu plus que *simplement trier*. "
"Il *définit une clé* également après le tri en initialisant un `attribute` "
"appelé `sorted`."

#: d.Rmd:block 123 (paragraph)
msgid ""
"We'll learn more about `keys` in the *Keys and fast binary search based "
"subset* vignette; for now, all you have to know is that you can use `keyby` "
"to automatically order the result by the columns specified in `by`."
msgstr ""
"Nous en apprendrons plus au sujet des `clés` dans la vignette *Clés et sous-"
"ensembles basés sur la recherche binaire rapide*; pour l'instant, tout ce que "
"vous devez savoir est que vous pouvez utiliser `keyby` pour trier "
"automatiquement le résultat selon les colonnes spécifiées dans `by`."

#: d.Rmd:block 124 (header)
msgid "c) Chaining"
msgstr "c) Chaînage"

#: d.Rmd:block 125 (paragraph)
msgid ""
"Let's reconsider the task of [getting the total number of trips for each "
"`origin, dest` pair for carrier *\"AA\"*](#origin-dest-.N)."
msgstr ""
"Considérons la tâche consistant à [récupérer le nombre total de voyages pour "
"chaque couple `origin, dest` du transporteur *\"AA\"*](#origin-dest-.N)."

#: d.Rmd:block 127 (header)
msgid ""
"-- How can we order `ans` using the columns `origin` in ascending order, and "
"`dest` in descending order?"
msgstr ""
"-- Comment trier `ans` en utilisant la colonne `origin` en mode croissant, et "
"la colonne `dest` en mode décroissant ?"

#: d.Rmd:block 128 (paragraph)
msgid ""
"We can store the intermediate result in a variable, and then use "
"`order(origin, -dest)` on that variable. It seems fairly straightforward."
msgstr ""
"On peut stocker le résultat intermédiaire dans une variable, puis passer "
"`order(origin, -dest)` sur cette variable. Cela semble plus direct."

#: d.Rmd:block 131 (paragraph)
msgid ""
"But this requires having to assign the intermediate result and then "
"overwriting that result. We can do one better and avoid this intermediate "
"assignment to a temporary variable altogether by *chaining* expressions."
msgstr ""
"Mais ceci nécessite d'avoir assigné le résultat intermédiaire et de réécrire "
"ce résultat. On peut faire mieux et éviter cette assignation intermédiaire à "
"une variable temporaire en *chaînant* les expressions ensemble."

#: d.Rmd:block 134 (header)
msgid "d) Expressions in `by`"
msgstr "d) Expressions de `by`"

#: d.Rmd:block 135 (header)
msgid "-- Can `by` accept *expressions* as well or does it just take columns?"
msgstr ""
"-- `by` accepte-t-il également *expressions*, ou simplement des colonnes ?"

#: d.Rmd:block 136 (paragraph)
msgid ""
"Yes it does. As an example, if we would like to find out how many flights "
"started late but arrived early (or on time), started and arrived late etc..."
msgstr ""
"Oui, il le fait. Par exemple, si nous avions voulu chercher combien de vols "
"sont partis en retard mais sont arrivés plus tôt (ou à l'heure), ou parts à "
"l'heure mais arrivés en retard, etc..."

#: d.Rmd:block 139 (header)
msgid "e) Multiple columns in `j` - `.SD`"
msgstr "e) Colonnes multiples dans `j` - `.SD`"

#: d.Rmd:block 140 (header)
msgid "-- Do we have to compute `mean()` for each column individually?"
msgstr "-- Faut-il calculer `mean()` pour chaque colonne individuellement ?"

#: d.Rmd:block 141 (paragraph)
msgid ""
"It is of course not practical to have to type `mean(myCol)` for every column "
"one by one. What if you had 100 columns to average `mean()`?"
msgstr ""
"Bien sûr il n'est pas pratique de devoir entrer `mean(myCol)` pour chaque "
"colonne, une par une. Et s'il fallait faire la moyenne `mean()` sur 100 "
"colonnes ?"

#: d.Rmd:block 142 (paragraph)
msgid ""
"How can we do this efficiently and concisely? To get there, refresh on [this "
"tip](#tip-1) - *\"As long as the `j`-expression returns a `list`, each "
"element of the `list` will be converted to a column in the resulting `data."
"table`\"*. If we can refer to the *data subset for each group* as a variable "
"*while grouping*, we can then loop through all the columns of that variable "
"using the already- or soon-to-be-familiar base function `lapply()`. No new "
"names to learn specific to `data.table`."
msgstr ""
"Comment faire cela de manière efficace et concise ?  Pour y arriver, relisons "
"[ce conseil](#tip-1) - *\"Tant que la `j`-expression renvoie une `list`, "
"chaque élément de cette `list` sera converti en une colonne de la `data."
"table` résultat\"*. Si nous pouvons adresser le *sous-ensemble de données de "
"chaque groupe* comme une variable *de regroupement*, nous pourrons ensuite "
"boucler sur toutes les colonnes de cette variables en utilisant la fonction "
"de base familière (ou en passe de le devenir) `lapply()`. Il n'y a pas de "
"nouveaux noms à apprendre particuliers pour `data.table`."

#: d.Rmd:block 143 (header)
msgid "Special symbol `.SD`: {#special-SD}"
msgstr "Symbole spécial `.SD`: {#special-SD}"

#: d.Rmd:block 144 (paragraph)
msgid ""
"`data.table` provides a *special* symbol called `.SD`. It stands for "
"**S**ubset of **D**ata. It by itself is a `data.table` that holds the data "
"for *the current group* defined using `by`."
msgstr ""
"`data.table` fournit le symbole *spécial* `.SD`. Il tire son nom de **S**ous-"
"ensemble de **D**onnées. C'est une `data.table` qui contient les données du "
"*groupe actuel* tel qu'il a été défini avec `by`."

#: d.Rmd:block 145 (paragraph)
msgid ""
"Recall that a `data.table` is internally a `list` as well with all its "
"columns of equal length."
msgstr ""
"Souvenez-vous qu'une `data.table` est représentée en interne comme une `list` "
"dont toutes les colonnes ont la même longueur."

#: d.Rmd:block 146 (paragraph)
msgid ""
"Let's use the [`data.table` `DT` from before](#what-is-datatable-1a) to get a "
"glimpse of what `.SD` looks like."
msgstr ""
"Utilisons la [`data.table` `DT` précédente](#what-is-datatable-1a) pour avoir "
"un aperçu de ce à quoi ressemble `.SD` ."

#: d.Rmd:block 149 (paragraph)
msgid ""
"To compute on (multiple) columns, we can then simply use the base R function "
"`lapply()`."
msgstr ""
"Pour calculer sur uneou plusieurs colonnes vous pouvez utiliser simplement la "
"fonction de base R `lapply()`."

#: d.Rmd:block 152 (paragraph)
msgid ""
"We are almost there. There is one little thing left to address. In our "
"`flights` `data.table`, we only wanted to calculate the `mean()` of the two "
"columns `arr_delay` and `dep_delay`. But `.SD` would contain all the columns "
"other than the grouping variables by default."
msgstr ""
"Nous y sommes presque. Il reste encore une petite chose à régler. Dans notre "
"`data.table` `flights` , nous avons voulu calculer seulement la `mean()` des "
"deux colonnes `arr_delay` et `dep_delay`. Mais `.SD` contiendrait par défaut "
"toutes les colonnes autres que les variables de groupement."

#: d.Rmd:block 153 (header)
msgid ""
"-- How can we specify just the columns we would like to compute the `mean()` "
"on?"
msgstr ""
"-- Comment spécifier uniquement les colonnes sur lesquelles nous voulons "
"appliquer `mean()` ?"

#: d.Rmd:block 154 (header)
msgid ".SDcols"
msgstr ".SDcols"

#: d.Rmd:block 155 (paragraph)
msgid ""
"Using the argument `.SDcols`. It accepts either column names or column "
"indices. For example, `.SDcols = c(\"arr_delay\", \"dep_delay\")` ensures "
"that `.SD` contains only these two columns for each group."
msgstr ""
"En utilisant l'argument `.SDcols`. Il accepte soit des noms soit des indices "
"de colonnes. Par exemple, `.SDcols = c(\"arr_delay\", \"dep_delay\")` permet "
"que `.SD` ne comporte que ces deux colonnes pour chaque groupe."

#: d.Rmd:block 156 (paragraph)
msgid ""
"Similar to [part g)](#refer_j), you can also specify the columns to remove "
"instead of columns to keep using `-` or `!`. Additionally, you can select "
"consecutive columns as `colA:colB` and deselect them as `!(colA:colB)` or `-"
"(colA:colB)`."
msgstr ""
"De la même manière que [part g)](#refer_j), vous pouvez également spécifier "
"les colonnes à supprimer au lieu des colonnes à garder en utilisant le `-` ou "
"`!`. De plus, vous pouvez sélectionner des colonnes consécutives avec `colA:"
"colB` et les désélectionner avec `!(colA:colB)` ou `-(colA:colB)`."

#: d.Rmd:block 157 (paragraph)
msgid ""
"Now let us try to use `.SD` along with `.SDcols` to get the `mean()` of "
"`arr_delay` and `dep_delay` columns grouped by `origin`, `dest` and `month`."
msgstr ""
"Maintenant essayons d'utiliser `.SD` avec `.SDcols` pour obtenir la moyenne "
"`mean()` des colonnes `arr_delay` et `dep_delay` groupées par `origin`, "
"`dest` et `month`."

#: d.Rmd:block 159 (header)
msgid "f) Subset `.SD` for each group:"
msgstr "f) Extraire `.SD` pour chaque groupe :"

#: d.Rmd:block 160 (header)
msgid "-- How can we return the first two rows for each `month`?"
msgstr "-- Comment renvoyer les deux premières lignes de chaque `month`?"

#: d.Rmd:block 163 (header)
msgid "g) Why keep `j` so flexible?"
msgstr "g) Pourquoi garder `j` si flexible ?"

#: d.Rmd:block 164 (paragraph)
msgid ""
"So that we have a consistent syntax and keep using already existing (and "
"familiar) base functions instead of learning new functions. To illustrate, "
"let us use the `data.table` `DT` that we created at the very beginning under "
"the section [What is a data.table?](#what-is-datatable-1a)."
msgstr ""
"Ainsi nous avons une syntaxe cohérente et continuons l'utilisation de "
"fonctions de base déja existantes (et familières) au lieu d'apprendre de "
"nouvelles fonctions. Pour illustrer cela utilisons la `data.table` `DT` que "
"nous avons créée tout au début dans la section [Qu'est-ce qu'une data.table ?]"
"(#what-is-datatable-1a)."

#: d.Rmd:block 165 (header)
msgid "-- How can we concatenate columns `a` and `b` for each group in `ID`?"
msgstr ""
"-- Comment concaténer les colonnes `a` et `b` pour chaque groupe de `ID` ?"

#: d.Rmd:block 168 (header)
msgid ""
"-- What if we would like to have all the values of column `a` and `b` "
"concatenated, but returned as a list column?"
msgstr ""
"-- Que se passerait-il si nous voulions avoir toutes les valeurs des colonnes "
"`a` et `b` concaténées, mais renvoyées en tant que colonne de liste ?"

#: d.Rmd:block 171 (paragraph)
msgid ""
"Once you start internalising usage in `j`, you will realise how powerful the "
"syntax can be. A very useful way to understand it is by playing around, with "
"the help of `print()`."
msgstr ""
"Une fois que vous commencerez à utiliser `j`, vous découvrirez la puissance "
"de sa syntaxe. Une manière pratique de l'aborder est de la tester en "
"utilisant `print()`."

#: d.Rmd:block 172 (paragraph)
msgid "For example:"
msgstr "Par exemple :"

#: d.Rmd:block 174 (paragraph)
msgid ""
"In (1), for each group, a vector is returned, with length = 6,4,2 here. "
"However, (2) returns a list of length 1 for each group, with its first "
"element holding vectors of length 6,4,2. Therefore, (1) results in a length "
"of `6+4+2 =`r 6+4+2``, whereas (2) returns `1+1+1=`r 1+1+1``."
msgstr ""
"Dans (1), pour chaque groupe, un vecteur est renvoyé, de longueur = 6,4,2 "
"ici. Néanmoins, (2) renvoie une liste de longueur 1 pour chaque groupe, dont "
"chaque premier élément contient des vecteurs de longueur 6,4,2. C'est "
"pourquoi, (1) a pour longueur totale `6+4+2 =`r 6+4+2``, alors que (2) "
"renvoie `1+1+1=`r 1+1+1``."

#: d.Rmd:block 175 (header)
msgid "Summary"
msgstr "Résumé"

#: d.Rmd:block 176 (paragraph)
msgid "The general form of `data.table` syntax is:"
msgstr "La forme générale de la syntaxe de `data.table` est :"

#: d.Rmd:block 178 (paragraph)
msgid "We have seen so far that,"
msgstr "Jusqu'ici nous avons vu que,"

#: d.Rmd:block 179 (header)
msgid "Using `i`:"
msgstr "En utilisant `i` :"

#: d.Rmd:block 181 (paragraph)
msgid ""
"We can do much more in `i` by keying a `data.table`, which allows for blazing "
"fast subsets and joins. We will see this in the *\"Keys and fast binary "
"search based subsets\"* and *\"Joins and rolling joins\"* vignette."
msgstr ""
"Nous pouvons faire beaucoup plus dans `i` en créant une `data.table` avec "
"clés, ce qui permet de réaliser rapidement les sous-ensembles et les "
"jointures. Nous verrons cela dans les vignettes *\"Clés et sous-ensembles "
"basés sur la recherche binaire rapide\"* et *\"Jointures et jointures liées "
"au temps\"*."

#: d.Rmd:block 182 (header)
msgid "Using `j`:"
msgstr "En utilisant `j` :"

#: d.Rmd:block 184 (header)
msgid "Using `by`:"
msgstr "En utilisant `by` :"

#: d.Rmd:block 186 (header)
msgid "And remember the tip:"
msgstr "Et souvenez-vous du conseil :"

#: d.Rmd:block 187 (paragraph)
msgid ""
"As long as `j` returns a `list`, each element of the list will become a "
"column in the resulting `data.table`."
msgstr ""
"Tant que `j` renvoie un objet `list`, chaque élément de la liste va devenir "
"une colonne du `data.table` résultant."

#: d.Rmd:block 188 (paragraph)
msgid ""
"We will see how to *add/update/delete* columns *by reference* and how to "
"combine them with `i` and `by` in the next vignette."
msgstr ""
"Nous verrons dans la vignette suivante comment *ajouter / mettre à jour / "
"supprimer* des colonnes *par référence* et comment les combiner avec `i` et "
"`by` ."

#: fr/datatable-intro.Rmd.tmp:block 1 (code)
msgid ""
"title: \"Introduction to data.table\"\n"
"date: \"`r Sys.Date()`\"\n"
"output:\n"
"  markdown::html_format\n"
"vignette: >\n"
"  %\\VignetteIndexEntry{Introduction to data.table}\n"
"  %\\VignetteEngine{knitr::knitr}\n"
"  \\usepackage[utf8]{inputenc}\n"
msgstr ""
"title: \"Introduction à data.table\"\n"
"date: \"`r Sys.Date()`\"\n"
"output:\n"
"  markdown::html_format\n"
"vignette: >\n"
"  %\\VignetteIndexEntry{Introduction à data.table}\n"
"  %\\VignetteEngine{knitr::knitr}\n"
"  \\usepackage[utf8]{inputenc}\n"

#: fr/datatable-intro.Rmd.tmp:block 2 (code)
msgid ""
"#===== r, echo = FALSE, message = FALSE\n"
"require(data.table)\n"
"knitr::opts_chunk$set(\n"
"  comment = \"#\",\n"
"    error = FALSE,\n"
"     tidy = FALSE,\n"
"    cache = FALSE,\n"
" collapse = TRUE\n"
")\n"
".old.th = setDTthreads(1)\n"
msgstr ""
"#===== r, echo = FALSE, message = FALSE\n"
"require(data.table)\n"
"knitr::opts_chunk$set(\n"
"  comment = \"#\",\n"
"    error = FALSE,\n"
"     tidy = FALSE,\n"
"    cache = FALSE,\n"
" collapse = TRUE\n"
")\n"
".old.th = setDTthreads(1)\n"

#: fr/datatable-intro.Rmd.tmp:block 11 (code)
msgid ""
"#===== r echo = FALSE\n"
"options(width = 100L)\n"
msgstr ""
"#===== r echo = FALSE\n"
"options(width = 100L)\n"

#: fr/datatable-intro.Rmd.tmp:block 12 (code)
msgid ""
"input <- if (file.exists(\"flights14.csv\")) {\n"
"   \"flights14.csv\"\n"
"} else {\n"
"  \"https://raw.githubusercontent.com/Rdatatable/data.table/master/vignettes/"
"flights14.csv\"\n"
"}\n"
"flights <- fread(input)\n"
"flights\n"
"dim(flights)\n"
msgstr ""
"input <- if (file.exists(\"../flights14.csv\")) {\n"
"   \"../flights14.csv\"\n"
"} else {\n"
"  \"https://raw.githubusercontent.com/Rdatatable/data.table/master/vignettes/"
"flights14.csv\"\n"
"}\n"
"flights <- fread(input)\n"
"flights\n"
"dim(flights)\n"

#: fr/datatable-intro.Rmd.tmp:block 20 (code)
msgid ""
"DT = data.table(\n"
"  ID = c(\"b\",\"b\",\"b\",\"a\",\"a\",\"c\"),\n"
"  a = 1:6,\n"
"  b = 7:12,\n"
"  c = 13:18\n"
")\n"
"DT\n"
"class(DT$ID)\n"
msgstr ""
"DT = data.table(\n"
"  ID = c(\"b\",\"b\",\"b\",\"a\",\"a\",\"c\"),\n"
"  a = 1:6,\n"
"  b = 7:12,\n"
"  c = 13:18\n"
")\n"
"DT\n"
"class(DT$ID)\n"

#: fr/datatable-intro.Rmd.tmp:block 26 (code)
msgid ""
"#===== r eval = FALSE\n"
"DT[i, j, by]\n"
"\n"
"##   R:                 i                 j        by\n"
"## SQL:  where | order by   select | update  group by\n"
msgstr ""
"#===== r eval = FALSE\n"
"DT[i, j, by]\n"
"\n"
"##   R:                 i                 j        by\n"
"## SQL:  where | order by   select | update  group by\n"

#: fr/datatable-intro.Rmd.tmp:block 33 (code)
msgid ""
"ans <- flights[origin == \"JFK\" & month == 6L]\n"
"head(ans)\n"
msgstr ""
"ans <- flights[origin == \"JFK\" & month == 6L]\n"
"head(ans)\n"

#: fr/datatable-intro.Rmd.tmp:block 36 (code)
msgid ""
"ans <- flights[1:2]\n"
"ans\n"
msgstr ""
"ans <- flights[1:2]\n"
"ans\n"

#: fr/datatable-intro.Rmd.tmp:block 40 (code)
msgid ""
"ans <- flights[order(origin, -dest)]\n"
"head(ans)\n"
msgstr ""
"ans <- flights[order(origin, -dest)]\n"
"head(ans)\n"

#: fr/datatable-intro.Rmd.tmp:block 46 (code)
msgid ""
"ans <- flights[, arr_delay]\n"
"head(ans)\n"
msgstr ""
"ans <- flights[, arr_delay]\n"
"head(ans)\n"

#: fr/datatable-intro.Rmd.tmp:block 49 (code)
msgid ""
"ans <- flights[, list(arr_delay)]\n"
"head(ans)\n"
msgstr ""
"ans <- flights[, list(arr_delay)]\n"
"head(ans)\n"

#: fr/datatable-intro.Rmd.tmp:block 55 (code)
msgid ""
"ans <- flights[, .(arr_delay, dep_delay)]\n"
"head(ans)\n"
"\n"
"## alternatively\n"
"# ans <- flights[, list(arr_delay, dep_delay)]\n"
msgstr ""
"ans <- flights[, .(arr_delay, dep_delay)]\n"
"head(ans)\n"
"\n"
"## forme alternative\n"
"# ans <- flights[, list(arr_delay, dep_delay)]\n"

#: fr/datatable-intro.Rmd.tmp:block 59 (code)
msgid ""
"ans <- flights[, .(delay_arr = arr_delay, delay_dep = dep_delay)]\n"
"head(ans)\n"
msgstr ""
"ans <- flights[, .(delay_arr = arr_delay, delay_dep = dep_delay)]\n"
"head(ans)\n"

#: fr/datatable-intro.Rmd.tmp:block 62 (code)
msgid ""
"ans <- flights[, sum( (arr_delay + dep_delay) < 0 )]\n"
"ans\n"
msgstr ""
"ans <- flights[, sum( (arr_delay + dep_delay) < 0 )]\n"
"ans\n"

#: fr/datatable-intro.Rmd.tmp:block 67 (code)
msgid ""
"ans <- flights[origin == \"JFK\" & month == 6L,\n"
"               .(m_arr = mean(arr_delay), m_dep = mean(dep_delay))]\n"
"ans\n"
msgstr ""
"ans <- flights[origin == \"JFK\" & month == 6L,\n"
"               .(m_arr = mean(arr_delay), m_dep = mean(dep_delay))]\n"
"ans\n"

#: fr/datatable-intro.Rmd.tmp:block 71 (code)
msgid ""
"ans <- flights[origin == \"JFK\" & month == 6L, length(dest)]\n"
"ans\n"
msgstr ""
"ans <- flights[origin == \"JFK\" & month == 6L, length(dest)]\n"
"ans\n"

#: fr/datatable-intro.Rmd.tmp:block 77 (code)
msgid "setkeyv(flights, \"origin\")\n"
msgstr "setkeyv(flights, \"origin\")\n"

#: fr/datatable-intro.Rmd.tmp:block 78 (unordered list)
msgid ""
"flights[\"XYZ\"]\n"
"# Returns:\n"
"#    origin year month day dep_time sched_dep_time dep_delay arr_time "
"sched_arr_time arr_delay carrier flight tailnum ...\n"
"# 1:    XYZ   NA    NA  NA       NA             NA        NA       "
"NA             NA        NA      NA     NA      NA ...\n"
msgstr ""
"flights[\"XYZ\"]\n"
"# Retourne:\n"
"#    origin year month day dep_time sched_dep_time dep_delay arr_time "
"sched_arr_time arr_delay carrier flight tailnum ...\n"
"# 1:    XYZ   NA    NA  NA       NA             NA        NA       "
"NA             NA        NA      NA     NA      NA ...\n"

#: fr/datatable-intro.Rmd.tmp:block 78 (unordered list)
msgid ""
"  flights[origin == \"XYZ\"]\n"
"# Returns:\n"
"# Empty data.table (0 rows and 19 cols): year,month,day,dep_time,"
"sched_dep_time,dep_delay,arr_time,sched_arr_time,arr_delay,...\n"
msgstr ""
"  flights[origin == \"XYZ\"]\n"
"# Retourne:\n"
"# Empty data.table (0 rows and 19 cols): year,month,day,dep_time,"
"sched_dep_time,dep_delay,arr_time,sched_arr_time,arr_delay,...\n"

#: fr/datatable-intro.Rmd.tmp:block 78 (unordered list)
msgid ""
"flights[\"XYZ\", nomatch=NULL]\n"
"# Returns:\n"
"# Empty data.table (0 rows and 19 cols): year,month,day,dep_time,"
"sched_dep_time,dep_delay,arr_time,sched_arr_time,arr_delay,...\n"
msgstr ""
"flights[\"XYZ\", nomatch=NULL]\n"
"# Retourne:\n"
"# Empty data.table (0 rows and 19 cols): year,month,day,dep_time,"
"sched_dep_time,dep_delay,arr_time,sched_arr_time,arr_delay,...\n"

#: fr/datatable-intro.Rmd.tmp:block 83 (code)
msgid ""
"ans <- flights[origin == \"JFK\" & month == 6L, .N]\n"
"ans\n"
msgstr ""
"ans <- flights[origin == \"JFK\" & month == 6L, .N]\n"
"ans\n"

#: fr/datatable-intro.Rmd.tmp:block 89 (code)
msgid ""
"#===== r j_cols_no_with\n"
"ans <- flights[, c(\"arr_delay\", \"dep_delay\")]\n"
"head(ans)\n"
msgstr ""
"#===== r j_cols_no_with\n"
"ans <- flights[, c(\"arr_delay\", \"dep_delay\")]\n"
"head(ans)\n"

#: fr/datatable-intro.Rmd.tmp:block 92 (code)
msgid ""
"#===== r j_cols_dot_prefix\n"
"select_cols = c(\"arr_delay\", \"dep_delay\")\n"
"flights[ , ..select_cols]\n"
msgstr ""
"#===== r j_cols_dot_prefix\n"
"select_cols = c(\"arr_delay\", \"dep_delay\")\n"
"flights[ , ..select_cols]\n"

#: fr/datatable-intro.Rmd.tmp:block 95 (code)
msgid ""
"#===== r j_cols_with\n"
"flights[ , select_cols, with = FALSE]\n"
msgstr ""
"#===== r j_cols_with\n"
"flights[ , select_cols, with = FALSE]\n"

#: fr/datatable-intro.Rmd.tmp:block 97 (code)
msgid ""
"DF = data.frame(x = c(1,1,1,2,2,3,3,3), y = 1:8)\n"
"\n"
"## (1) normal way\n"
"DF[DF$x > 1, ] # data.frame needs that ',' as well\n"
"\n"
"## (2) using with\n"
"DF[with(DF, x > 1), ]\n"
msgstr ""
"DF = data.frame(x = c(1,1,1,2,2,3,3,3), y = 1:8)\n"
"\n"
"## (1) méthode classique\n"
"DF[DF$x > 1, ] # data.frame needs that ',' as well\n"
"\n"
"## (2) en utilisant with\n"
"DF[with(DF, x > 1), ]\n"

#: fr/datatable-intro.Rmd.tmp:block 104 (code)
msgid ""
"ans <- flights[, .(.N), by = .(origin)]\n"
"ans\n"
"\n"
"## or equivalently using a character vector in 'by'\n"
"# ans <- flights[, .(.N), by = \"origin\"]\n"
msgstr ""
"ans <- flights[, .(.N), by = .(origin)]\n"
"ans\n"
"\n"
"## ou résultat identique en utilisant un vecteur de chaînes de caractères "
"dans 'by'\n"
"# ans <- flights[, .(.N), by = \"origin\"]\n"

#: fr/datatable-intro.Rmd.tmp:block 108 (code)
msgid ""
"ans <- flights[carrier == \"AA\", .N, by = origin]\n"
"ans\n"
msgstr ""
"ans <- flights[carrier == \"AA\", .N, by = origin]\n"
"ans\n"

#: fr/datatable-intro.Rmd.tmp:block 111 (code)
msgid ""
"ans <- flights[carrier == \"AA\", .N, by = .(origin, dest)]\n"
"head(ans)\n"
"\n"
"## or equivalently using a character vector in 'by'\n"
"# ans <- flights[carrier == \"AA\", .N, by = c(\"origin\", \"dest\")]\n"
msgstr ""
"ans <- flights[carrier == \"AA\", .N, by = .(origin, dest)]\n"
"head(ans)\n"
"\n"
"## ou résultat identique en utilisant une chaîne de caractères dans 'by'\n"
"# ans <- flights[carrier == \"AA\", .N, by = c(\"origin\", \"dest\")]\n"

#: fr/datatable-intro.Rmd.tmp:block 114 (code)
msgid ""
"ans <- flights[carrier == \"AA\",\n"
"        .(mean(arr_delay), mean(dep_delay)),\n"
"        by = .(origin, dest, month)]\n"
"ans\n"
msgstr ""
"ans <- flights[carrier == \"AA\",\n"
"        .(mean(arr_delay), mean(dep_delay)),\n"
"        by = .(origin, dest, month)]\n"
"ans\n"

#: fr/datatable-intro.Rmd.tmp:block 120 (code)
msgid ""
"ans <- flights[carrier == \"AA\",\n"
"        .(mean(arr_delay), mean(dep_delay)),\n"
"        keyby = .(origin, dest, month)]\n"
"ans\n"
msgstr ""
"ans <- flights[carrier == \"AA\",\n"
"        .(mean(arr_delay), mean(dep_delay)),\n"
"        keyby = .(origin, dest, month)]\n"
"ans\n"

#: fr/datatable-intro.Rmd.tmp:block 126 (code)
msgid "ans <- flights[carrier == \"AA\", .N, by = .(origin, dest)]\n"
msgstr "ans <- flights[carrier == \"AA\", .N, by = .(origin, dest)]\n"

#: fr/datatable-intro.Rmd.tmp:block 129 (code)
msgid ""
"ans <- ans[order(origin, -dest)]\n"
"head(ans)\n"
msgstr ""
"ans <- ans[order(origin, -dest)]\n"
"head(ans)\n"

#: fr/datatable-intro.Rmd.tmp:block 132 (code)
msgid ""
"ans <- flights[carrier == \"AA\", .N, by = .(origin, dest)][order(origin, -"
"dest)]\n"
"head(ans, 10)\n"
msgstr ""
"ans <- flights[carrier == \"AA\", .N, by = .(origin, dest)][order(origin, -"
"dest)]\n"
"head(ans, 10)\n"

#: fr/datatable-intro.Rmd.tmp:block 137 (code)
msgid ""
"ans <- flights[, .N, .(dep_delay>0, arr_delay>0)]\n"
"ans\n"
msgstr ""
"ans <- flights[, .N, .(dep_delay>0, arr_delay>0)]\n"
"ans\n"

#: fr/datatable-intro.Rmd.tmp:block 147 (code)
msgid ""
"DT\n"
"\n"
"DT[, print(.SD), by = ID]\n"
msgstr ""
"DT\n"
"\n"
"DT[, print(.SD), by = ID]\n"

#: fr/datatable-intro.Rmd.tmp:block 150 (code)
msgid "DT[, lapply(.SD, mean), by = ID]\n"
msgstr "DT[, lapply(.SD, mean), by = ID]\n"

#: fr/datatable-intro.Rmd.tmp:block 158 (code)
msgid ""
"flights[carrier == \"AA\",                       ## Only on trips with "
"carrier \"AA\"\n"
"        lapply(.SD, mean),                     ## compute the mean\n"
"        by = .(origin, dest, month),           ## for every 'origin,dest,"
"month'\n"
"        .SDcols = c(\"arr_delay\", \"dep_delay\")] ## for just those "
"specified in .SDcols\n"
msgstr ""
"flights[carrier == \"AA\",                       ## Seulement les vols sur "
"porteurs \"AA\"\n"
"        lapply(.SD, mean),                     ## calcule la moyenne\n"
"        by = .(origin, dest, month),           ## pour chaque 'origin,dest,"
"month'\n"
"        .SDcols = c(\"arr_delay\", \"dep_delay\")] ## pour seulement ceux "
"spécifiés dans .SDcols\n"

#: fr/datatable-intro.Rmd.tmp:block 161 (code)
msgid ""
"ans <- flights[, head(.SD, 2), by = month]\n"
"head(ans)\n"
msgstr ""
"ans <- flights[, head(.SD, 2), by = month]\n"
"head(ans)\n"

#: fr/datatable-intro.Rmd.tmp:block 166 (code)
msgid "DT[, .(val = c(a,b)), by = ID]\n"
msgstr "DT[, .(val = c(a,b)), by = ID]\n"

#: fr/datatable-intro.Rmd.tmp:block 169 (code)
msgid "DT[, .(val = list(c(a,b))), by = ID]\n"
msgstr "DT[, .(val = list(c(a,b))), by = ID]\n"

#: fr/datatable-intro.Rmd.tmp:block 173 (code)
msgid ""
"## look at the difference between\n"
"DT[, print(c(a,b)), by = ID] # (1)\n"
"\n"
"## and\n"
"DT[, print(list(c(a,b))), by = ID] # (2)\n"
msgstr ""
"## inspectez la différence entre\n"
"DT[, print(c(a,b)), by = ID] # (1)\n"
"\n"
"## et\n"
"DT[, print(list(c(a,b))), by = ID] # (2)\n"

#: fr/datatable-intro.Rmd.tmp:block 177 (code)
msgid ""
"#===== r eval = FALSE\n"
"DT[i, j, by]\n"
msgstr ""
"#===== r eval = FALSE\n"
"DT[i, j, by]\n"

#: fr/datatable-intro.Rmd.tmp:block 189 (code)
msgid ""
"#===== r, echo=FALSE\n"
"setDTthreads(.old.th)\n"
msgstr ""
"#===== r, echo=FALSE\n"
"setDTthreads(.old.th)\n"

#: fr/datatable-intro.Rmd.tmp:block 28 (code)
msgid ""
"```{.r}\n"
"getOption(\"datatable.print.nrows\")\n"
"```\n"
msgstr ""
"```{.r}\n"
"getOption(\"datatable.print.nrows\")\n"
"```\n"

#: fr/datatable-intro.Rmd.tmp:block 121 (code)
msgid ""
"Hence, the argument name `with` in `data.table`. Setting `with = FALSE` "
"disables the ability to refer to columns as if they are variables, thereby "
"restoring the \"`data.frame` mode\".\n"
msgstr ""
"D'où le nom de l'argument `with` dans `data.table`. Mettre `with = FALSE` "
"désactive la possibilité de se référer aux colonnes comme si elles étaient "
"des variables, restaurant ainsi le « mode `data.frame` ».\n"

#: fr/datatable-intro.Rmd.tmp:block 123 (code)
msgid ""
"```{chunk_with_args}\n"
"#===== r eval = FALSE\n"
"## not run\n"
"\n"
"# returns all columns except arr_delay and dep_delay\n"
"ans <- flights[, !c(\"arr_delay\", \"dep_delay\")]\n"
"# or\n"
"ans <- flights[, -c(\"arr_delay\", \"dep_delay\")]\n"
"```\n"
msgstr ""
"```{chunk_with_args}\n"
"#===== r eval = FALSE\n"
"## pas d'exécution\n"
"\n"
"# renvoie toutes les colonnes sauf arr_delay et dep_delay\n"
"ans <- flights[, !c(\"arr_delay\", \"dep_delay\")]\n"
"# ou\n"
"ans <- flights[, -c(\"arr_delay\", \"dep_delay\")]\n"
"```\n"

#: fr/datatable-intro.Rmd.tmp:block 125 (code)
msgid ""
"```{chunk_with_args}\n"
"#===== r eval = FALSE\n"
"## not run\n"
"\n"
"# returns year,month and day\n"
"ans <- flights[, year:day]\n"
"# returns day, month and year\n"
"ans <- flights[, day:year]\n"
"# returns all columns except year, month and day\n"
"ans <- flights[, -(year:day)]\n"
"ans <- flights[, !(year:day)]\n"
"```\n"
"\n"
"This is particularly handy while working interactively.\n"
msgstr ""
"```{chunk_with_args}\n"
"#===== r eval = FALSE\n"
"## pas d'exécution\n"
"\n"
"# renvoie year,month et day\n"
"ans <- flights[, year:day]\n"
"# renvoie day, month et year\n"
"ans <- flights[, day:year]\n"
"# renvoie toutes les colonnes sauf year, month et day\n"
"ans <- flights[, -(year:day)]\n"
"ans <- flights[, !(year:day)]\n"
"```\n"
"\n"
"Ceci est particulièrement pratique lorsque l'on travaille de manière "
"interactive.\n"

#: fr/datatable-intro.Rmd.tmp:block 137 (code)
msgid ""
"```{r}\n"
"ans <- flights[, .N, by = origin]\n"
"ans\n"
"```\n"
"\n"
"We'll use this convenient form wherever applicable hereafter.\n"
msgstr ""
"```{r}\n"
"ans <- flights[, .N, by = origin]\n"
"ans\n"
"```\n"
"\n"
"Nous utiliserons cette forme pratique chaque fois que cela sera possible.\n"

#: fr/datatable-intro.Rmd.tmp:block 170 (code)
msgid ""
"```{chunk_with_args}\n"
"#===== r eval = FALSE\n"
"DT[ ...\n"
"   ][ ...\n"
"     ][ ...\n"
"       ]\n"
"```\n"
msgstr ""
"```{chunk_with_args}\n"
"#===== r eval = FALSE\n"
"DT[ ...\n"
"   ][ ...\n"
"     ][ ...\n"
"       ]\n"
"```\n"

#: fr/datatable-intro.Rmd.tmp:block 6 (paragraph)
msgid ""
"=====* *concise* and *consistent* syntax irrespective of the set of "
"operations you would like to perform to achieve your end goal.====="
msgstr ""
"=====* syntaxe *concise* et *cohérente* quel que soit l'ensemble des "
"opérations que vous souhaitez effectuer pour atteindre votre objectif final."
"====="

#: fr/datatable-intro.Rmd.tmp:block 7 (paragraph)
msgid ""
"=====* performing analysis *fluidly* without the cognitive burden of having "
"to map each operation to a particular function from a potentially huge set of "
"functions available before performing the analysis.====="
msgstr ""
"=====* effectuer une analyse *fluide* sans la charge cognitive de devoir "
"faire correspondre chaque opération à une fonction particulière à partir d'un "
"ensemble potentiellement énorme de fonctions disponibles avant d'effectuer "
"l'analyse.====="

#: fr/datatable-intro.Rmd.tmp:block 8 (paragraph)
msgid ""
"=====* *automatically* optimising operations internally and very effectively "
"by knowing precisely the data required for each operation, leading to very "
"fast and memory-efficient code.====="
msgstr ""
"=====* *automatiquement* optimiser les opérations en interne et de manière "
"très efficace en connaissant précisément les données requises pour chaque "
"opération, ce qui permet d'obtenir un code très rapide et efficace sur le "
"plan de la mémoire.====="

#: fr/datatable-intro.Rmd.tmp:block 18 (paragraph)
msgid ""
"=====1. Start with the basics - what is a `data.table`, its general form, how "
"to *subset* rows, how to *select and compute* on columns;====="
msgstr ""
"=====1. Commencez par les bases - qu'est-ce qu'un `data.table`, sa forme "
"générale, comment réaliser un *sous-ensemble* des lignes, comment "
"*sélectionner et effectuer des calculs* sur les colonnes;====="

#: fr/datatable-intro.Rmd.tmp:block 19 (paragraph)
msgid "=====2. Then we will look at performing data aggregations by group====="
msgstr ""
"=====2. Nous verrons ensuite comment effectuer des agrégations de données par "
"groupe====="

#: fr/datatable-intro.Rmd.tmp:block 26 (paragraph)
msgid ""
"=====* Row numbers are printed with a `:` in order to visually separate the "
"row number from the first column.====="
msgstr ""
"=====* Les numéros de ligne sont imprimés avec un `:` afin de séparer "
"visuellement le numéro de ligne de la première colonne.====="

#: fr/datatable-intro.Rmd.tmp:block 27 (paragraph)
msgid ""
"=====* When the number of rows to print exceeds the global option `datatable."
"print.nrows` (default = `r getOption(\"datatable.print.nrows\")`), it "
"automatically prints only the top 5 and bottom 5 rows (as can be seen in the "
"[Data](#data) section). For a large `data.frame`, you may have found yourself "
"waiting around while larger tables print-and-page, sometimes seemingly "
"endlessly. This restriction helps with that, and you can query the default "
"number like so:====="
msgstr ""
"=====* Lorsque le nombre de lignes à imprimer dépasse l'option globale "
"`datatable.print.nrows` (défaut = `r getOption(\"datatable.print.nrows\")`), "
"il n'imprime automatiquement que les 5 premières et les 5 dernières lignes "
"(comme on peut le voir dans la section [Data](#data)). Pour un grand `data."
"frame`, vous avez pu vous retrouver à attendre que des tables plus grandes "
"s'impriment et se mettent en page, parfois sans fin. Cette restriction permet "
"d'y remédier, et vous pouvez demander le nombre par défaut de la façon "
"suivante : ====="

#: fr/datatable-intro.Rmd.tmp:block 29 (paragraph)
msgid ""
"=====* `data.table` doesn't set or use *row names*, ever. We will see why in "
"the *\"Keys and fast binary search based subset\"* vignette.====="
msgstr ""
"=====* `data.table` ne définit ni n'utilise jamais de *nom de ligne*. Nous "
"verrons pourquoi dans la vignette *\"Sous-ensemble basé sur des clés et "
"recherche binaire rapide\"*.====="

#: fr/datatable-intro.Rmd.tmp:block 41 (paragraph)
msgid ""
"=====* The *row indices* that satisfy the condition `origin == \"JFK\" & "
"month == 6L` are computed, and since there is nothing else left to do, all "
"columns from `flights` at rows corresponding to those *row indices* are "
"simply returned as a `data.table`.====="
msgstr ""
"=====* Les *indices de ligne* qui satisfont la condition `origin == \"JFK\" & "
"month == 6L` sont calculés, et puisqu'il n'y a rien d'autre à faire, toutes "
"les colonnes de `flights` aux lignes correspondant à ces *indices de ligne* "
"sont simplement renvoyées sous forme d’un `data.table`.====="

#: fr/datatable-intro.Rmd.tmp:block 42 (paragraph)
msgid ""
"=====* A comma after the condition in `i` is not required. But "
"`flights[origin == \"JFK\" & month == 6L, ]` would work just fine. In a `data."
"frame`, however, the comma is necessary.====="
msgstr ""
"=====* Une virgule après la condition dans `i` n'est pas nécessaire. Mais "
"`flights[origin == \"JFK\" & month == 6L, ]` fonctionnerait parfaitement. "
"Avec un `data.frame`, cependant, la virgule est indispensable.====="

#: fr/datatable-intro.Rmd.tmp:block 45 (paragraph)
msgid ""
"=====* In this case, there is no condition. The row indices are already "
"provided in `i`. We therefore return a `data.table` with all columns from "
"`flights` at rows for those *row indices*.====="
msgstr ""
"=====* Dans ce cas, il n'y a pas de condition. Les indices des lignes sont "
"déjà fournis dans `i`. Nous retournons donc un `data.table` avec toutes les "
"colonnes de `flights` aux lignes pour ces *index de ligne*.====="

#: fr/datatable-intro.Rmd.tmp:block 50 (paragraph)
msgid ""
"=====* We can use \"-\" on `character` columns within the frame of a `data."
"table` to sort in decreasing order.====="
msgstr ""
"=====* Nous pouvons utiliser \"-\" sur les colonnes `character` dans le cadre "
"d'un `data.table` pour trier par ordre décroissant.====="

#: fr/datatable-intro.Rmd.tmp:block 51 (paragraph)
msgid ""
"=====* In addition, `order(...)` within the frame of a `data.table` uses "
"`data.table`'s internal fast radix order `forder()`. This sort provided such "
"a compelling improvement over R's `base::order` that the R project adopted "
"the `data.table` algorithm as its default sort in 2016 for R 3.3.0 (for "
"reference, check `?sort` and the [R Release NEWS](https://cran.r-project.org/"
"doc/manuals/r-release/NEWS.pdf)).====="
msgstr ""
"=====* De plus, `order(...)` dans le cadre d'un `data.table` utilise l'ordre "
"radix rapide interne de `data.table` `forder()`. Ce tri a apporté une telle "
"amélioration par rapport à `base::order` de R que le projet R a adopté "
"l'algorithme `data.table` comme tri par défaut en 2016 pour R 3.3.0 (pour "
"référence, voir `?sort` et les [R Release NEWS](https://cran.r-project.org/"
"doc/manuals/r-release/NEWS.pdf)).====="

#: fr/datatable-intro.Rmd.tmp:block 56 (paragraph)
msgid ""
"=====* Since columns can be referred to as if they are variables within the "
"frame of a `data.table`, we directly refer to the *variable* we want to "
"subset. Since we want *all the rows*, we simply skip `i`.====="
msgstr ""
"=====* Puisque les colonnes peuvent être appelées comme si elles étaient des "
"variables dans le cadre d'un `data.table`, nous nous référons directement à "
"la *variable* dont nous voulons créer un sous-ensemble. Puisque nous voulons "
"*toutes les lignes*, nous sautons simplement `i`.====="

#: fr/datatable-intro.Rmd.tmp:block 57 (paragraph)
msgid "=====* It returns *all* the rows for the column `arr_delay`.====="
msgstr "=====* Il renvoie *toutes* les lignes de la colonne `arr_delay`.====="

#: fr/datatable-intro.Rmd.tmp:block 60 (paragraph)
msgid ""
"=====* We wrap the *variables* (column names) within `list()`, which ensures "
"that a `data.table` is returned. In the case of a single column name, not "
"wrapping with `list()` returns a vector instead, as seen in the [previous "
"example](#select-j-1d).====="
msgstr ""
"=====* Nous enveloppons les *variables* (noms de colonnes) dans `list()`, ce "
"qui assure qu'un `data.table` est retourné. Dans le cas d'un seul nom de "
"colonne, le fait de ne pas utiliser `list()` renvoie un vecteur, comme on "
"peut le voir dans l'exemple précédent](#select-j-1d).====="

#: fr/datatable-intro.Rmd.tmp:block 61 (paragraph)
msgid ""
"=====* `data.table` also allows wrapping columns with `.()` instead of "
"`list()`. It is an *alias* to `list()`; they both mean the same. Feel free to "
"use whichever you prefer; we have noticed most users seem to prefer `.()` for "
"conciseness, so we will continue to use `.()` hereafter.====="
msgstr ""
"=====* `data.table` permet aussi d'envelopper les colonnes avec `.()` au lieu "
"de `list()`. C'est un *alias* de `list()` ; les deux signifient la même "
"chose. N'hésitez pas à utiliser ce que vous préférez ; nous avons remarqué "
"que la plupart des utilisateurs semblent préférer `.()` pour la concision, "
"donc nous continuerons à utiliser `.()` par la suite.====="

#: fr/datatable-intro.Rmd.tmp:block 67 (paragraph)
msgid "=====* Wrap both columns within `.()`, or `list()`. That's it.====="
msgstr ""
"=====* Enveloppez les deux colonnes dans `.()`, ou `list()`. C'est tout.====="

#: fr/datatable-intro.Rmd.tmp:block 75 (paragraph)
msgid ""
"=====* `data.table`'s `j` can handle more than just *selecting columns* - it "
"can handle *expressions*, i.e., *computing on columns*. This shouldn't be "
"surprising, as columns can be referred to as if they are variables. Then we "
"should be able to *compute* by calling functions on those variables. And "
"that's what precisely happens here.====="
msgstr ""
"=====* Le `j` de `data.table` peut gérer plus que la *sélection de colonnes* "
"- il peut gérer des *expressions*, c'est-à-dire *calculer sur des colonnes*. "
"Cela ne devrait pas être surprenant, car on peut se référer aux colonnes "
"comme si elles étaient des variables. Nous devrions donc pouvoir *calculer* "
"en appelant des fonctions sur ces variables. Et c'est précisément ce qui se "
"passe ici.====="

#: fr/datatable-intro.Rmd.tmp:block 79 (paragraph)
msgid ""
"=====* We first subset in `i` to find matching *row indices* where `origin` "
"airport equals `\"JFK\"`, and `month` equals `6L`. We *do not* subset the "
"*entire* `data.table` corresponding to those rows *yet*.====="
msgstr ""
"=====* Nous commençons par effectuer un sous-ensemble dans `i` pour trouver "
"les *indices de ligne* correspondants à `origin` égal à l’aéroport `\"JFK\"`, "
"et où le `mois` est égal à `6L`. Nous *n'effectuons pas encore* le sous-"
"ensemble de *toutes* les `data.table` correspondant à ces lignes.====="

#: fr/datatable-intro.Rmd.tmp:block 80 (paragraph)
msgid ""
"=====* Now, we look at `j` and find that it uses only *two columns*. And what "
"we have to do is to compute their `mean()`. Therefore, we subset just those "
"columns corresponding to the matching rows, and compute their `mean()`.====="
msgstr ""
"=====* Maintenant, nous regardons `j` et nous constatons qu'il n'utilise que "
"*deux colonnes*. Et ce que nous devons faire, c'est calculer leur moyenne "
"avec `mean()`. Par conséquent, nous regroupons uniquement les colonnes "
"d’intérêt aux lignes correspondantes, et nous calculons leurs moyennes.====="

#: fr/datatable-intro.Rmd.tmp:block 90 (paragraph)
msgid "=====* **Key-based subsetting: `dt[\"d\"]`**====="
msgstr "=====* **Sous-ensemble basé sur les clés : `dt[\"d\"]`**====="

#: fr/datatable-intro.Rmd.tmp:block 93 (paragraph)
msgid "=====* **Logical subsetting: `dt[x == \"d\"]`**====="
msgstr "=====* **Sous-ensemble logique : `dt[x == \"d\"]`**====="

#: fr/datatable-intro.Rmd.tmp:block 96 (paragraph)
msgid "=====* **Exact match using `nomatch=NULL`**====="
msgstr "=====* **Correspondance exacte en utilisant `nomatch=NULL`**====="

#: fr/datatable-intro.Rmd.tmp:block 104 (paragraph)
msgid ""
"=====* Once again, we subset in `i` to get the *row indices* where `origin` "
"airport equals *\"JFK\"*, and `month` equals *6*.====="
msgstr ""
"=====* Une fois de plus, nous introduisons `i` pour obtenir les *indices de "
"lignes* pour lesquels l'aéroport `origin` est *\"JFK\"*, et le `mois` est *6*."
"====="

#: fr/datatable-intro.Rmd.tmp:block 105 (paragraph)
msgid ""
"=====* We see that `j` uses only `.N` and no other columns. Therefore, the "
"entire subset is not materialised. We simply return the number of rows in the "
"subset (which is just the length of row indices).====="
msgstr ""
"=====* Nous voyons que `j` n'utilise que `.N` et aucune autre colonne. Par "
"conséquent, le sous-ensemble complet n'est pas matérialisé. Nous renvoyons "
"simplement le nombre de lignes dans le sous-ensemble (qui est juste la "
"longueur des indices de ligne).====="

#: fr/datatable-intro.Rmd.tmp:block 106 (paragraph)
msgid ""
"=====* Note that we did not wrap `.N` with `list()` or `.()`. Therefore, a "
"vector is returned.====="
msgstr ""
"=====* Notez que nous n'avons pas enveloppé `.N` avec `list()` ou `.()`. Par "
"conséquent, un vecteur est retourné.====="

#: fr/datatable-intro.Rmd.tmp:block 120 (paragraph)
msgid ""
"=====* Using `with()` in (2) allows using `DF`'s column `x` as if it were a "
"variable.====="
msgstr ""
"=====* L'utilisation de `with()` dans (2) permet d'utiliser la colonne `x` de "
"`DF` comme s'il s'agissait d'une variable.====="

#: fr/datatable-intro.Rmd.tmp:block 122 (paragraph)
msgid ""
"=====* We can also *deselect* columns using `-` or `!`. For example:====="
msgstr ""
"=====* Nous pouvons également *désélectionner* des colonnes en utilisant `-` "
"ou `!`. Par exemple :====="

#: fr/datatable-intro.Rmd.tmp:block 124 (paragraph)
msgid ""
"=====* From `v1.9.5+`, we can also select by specifying start and end column "
"names, e.g., `year:day` to select the first three columns.====="
msgstr ""
"=====* A partir de la `v1.9.5+`, on peut aussi sélectionner en spécifiant les "
"noms des colonnes de début et de fin, par exemple, `year:day` pour "
"sélectionner les trois premières colonnes.====="

#: fr/datatable-intro.Rmd.tmp:block 132 (paragraph)
msgid ""
"=====* We know `.N` [is a special variable](#special-N) that holds the number "
"of rows in the current group. Grouping by `origin` obtains the number of "
"rows, `.N`, for each group.====="
msgstr ""
"=====* Nous savons que `.N` [est une variable spéciale](#special-N) qui "
"contient le nombre de lignes dans le groupe courant. En groupant par "
"`origine`, on obtient le nombre de lignes, `.N`, pour chaque groupe.====="

#: fr/datatable-intro.Rmd.tmp:block 133 (paragraph)
msgid ""
"=====* By doing `head(flights)` you can see that the origin airports occur in "
"the order *\"JFK\"*, *\"LGA\"*, and *\"EWR\"*. The original order of grouping "
"variables is preserved in the result. *This is important to keep in mind!"
"*====="
msgstr ""
"=====* En faisant `head(flights)` vous pouvez voir que les aéroports "
"d'origine sont dans l'ordre *\"JFK\"*, *\"LGA\"*, et *\"EWR\"*. L'ordre "
"original de regroupement des variables est préservé dans le résultat. *Il est "
"important de garder cela à l'esprit!*====="

#: fr/datatable-intro.Rmd.tmp:block 134 (paragraph)
msgid ""
"=====* Since we did not provide a name for the column returned in `j`, it was "
"named `N` automatically by recognising the special symbol `.N`.====="
msgstr ""
"=====* Comme nous n'avons pas fourni de nom pour la colonne retournée dans "
"`j`, elle a été nommée `N` automatiquement en reconnaissant le symbole "
"spécial `.N`.====="

#: fr/datatable-intro.Rmd.tmp:block 135 (paragraph)
msgid ""
"=====* `by` also accepts a character vector of column names. This is "
"particularly useful for coding programmatically, e.g., designing a function "
"with the grouping columns (in the form of a `character` vector) as a function "
"argument.====="
msgstr ""
"=====* `by` accepte également un vecteur de caractères de noms de colonnes. "
"Ceci est particulièrement utile pour le codage par programmation, par exemple "
"pour concevoir une fonction avec les colonnes de regroupement (sous la forme "
"d'un vecteur `character`) comme argument de la fonction.====="

#: fr/datatable-intro.Rmd.tmp:block 136 (paragraph)
msgid ""
"=====* When there's only one column or expression to refer to in `j` and "
"`by`, we can drop the `.()` notation. This is purely for convenience. We "
"could instead do:====="
msgstr ""
"=====* Lorsqu'il n'y a qu'une seule colonne ou expression à laquelle se "
"référer dans `j` et `by`, nous pouvons abandonner la notation `.()`. Ceci est "
"purement pratique. Nous pourrions plutôt faire :====="

#: fr/datatable-intro.Rmd.tmp:block 141 (paragraph)
msgid ""
"=====* We first obtain the row indices for the expression `carrier == \"AA\"` "
"from `i`.====="
msgstr ""
"=====* Nous obtenons d'abord les indices de ligne pour l'expression `carrier "
"== \"AA\"` à partir de `i`.====="

#: fr/datatable-intro.Rmd.tmp:block 142 (paragraph)
msgid ""
"=====* Using those *row indices*, we obtain the number of rows while grouped "
"by `origin`. Once again no columns are actually materialised here, because "
"the `j-expression` does not require any columns to be actually subsetted and "
"is therefore fast and memory efficient.====="
msgstr ""
"=====* En utilisant ces *index de ligne*, nous obtenons le nombre de lignes "
"groupées par `origine`. Une fois de plus, aucune colonne n'est matérialisée "
"ici, car l'expression `j` ne nécessite aucune colonne pour définir le sous-"
"ensemble et le calcul est donc rapide et peu gourmand en mémoire.====="

#: fr/datatable-intro.Rmd.tmp:block 145 (paragraph)
msgid ""
"=====* `by` accepts multiple columns. We just provide all the columns by "
"which to group by. Note the use of `.()` again in `by` -- again, this is just "
"shorthand for `list()`, and `list()` can be used here as well. Again, we'll "
"stick with `.()` in this vignette.====="
msgstr ""
"=====* `by` accepte plusieurs colonnes. Nous fournissons simplement toutes "
"les colonnes par lesquelles il faut grouper. Notez l'utilisation de `.()` "
"dans `by` -- encore une fois, c'est juste un raccourci pour `list()`, et "
"`list()` peut être utilisé ici aussi. Nous nous en tiendrons à nouveau à `."
"()` dans cette vignette.====="

#: fr/datatable-intro.Rmd.tmp:block 148 (paragraph)
msgid ""
"=====* Since we did not provide column names for the expressions in `j`, they "
"were automatically generated as `V1` and `V2`.====="
msgstr ""
"=====* Comme nous n'avons pas fourni de noms de colonnes pour les expressions "
"dans `j`, elles ont été automatiquement générées en tant que `V1` et `V2`."
"====="

#: fr/datatable-intro.Rmd.tmp:block 149 (paragraph)
msgid ""
"=====* Once again, note that the input order of grouping columns is preserved "
"in the result.====="
msgstr ""
"=====* Une fois de plus, notez que l'ordre d'entrée des colonnes de "
"regroupement est préservé dans le résultat.====="

#: fr/datatable-intro.Rmd.tmp:block 155 (paragraph)
msgid ""
"=====* All we did was change `by` to `keyby`. This automatically orders the "
"result by the grouping variables in increasing order. In fact, due to the "
"internal implementation of `by` first requiring a sort before recovering the "
"original table's order, `keyby` is typically faster than `by` because it "
"doesn't require this second step.====="
msgstr ""
"=====* Tout ce que nous avons fait, c'est remplacer `by` par `keyby`. Cela "
"ordonne automatiquement le résultat par ordre croissant des variables de "
"regroupement. En fait, à cause de l'implémentation interne de `by` qui "
"nécessite d'abord un tri avant de récupérer l'ordre de la table originale, "
"`keyby` est typiquement plus rapide que `by` parce qu'il ne nécessite pas "
"cette seconde étape.====="

#: fr/datatable-intro.Rmd.tmp:block 164 (paragraph)
msgid ""
"=====* Recall that we can use `-` on a `character` column in `order()` within "
"the frame of a `data.table`. This is possible due to `data.table`'s internal "
"query optimisation.====="
msgstr ""
"=====* Rappelons que nous pouvons utiliser `-` sur une colonne `character` "
"dans `order()` dans le cadre d'un `data.table`. Ceci est possible grâce à "
"l'optimisation interne des requêtes de `data.table`.====="

#: fr/datatable-intro.Rmd.tmp:block 165 (paragraph)
msgid ""
"=====* Also recall that `order(...)` with the frame of a `data.table` is "
"*automatically optimised* to use `data.table`'s internal fast radix order "
"`forder()` for speed. ====="
msgstr ""
"=====* Rappelez-vous aussi que `order(...)` dans le contexte d'un `data."
"table` est *automatiquement optimisé* pour utiliser l’algorithme de tri radix "
"rapide interne de `data.table` `forder()` pour plus de rapidité. ====="

#: fr/datatable-intro.Rmd.tmp:block 168 (paragraph)
msgid ""
"=====* We can tack expressions one after another, *forming a chain* of "
"operations, i.e., `DT[ ... ][ ... ][ ... ]`.====="
msgstr ""
"=====* Nous pouvons ajouter des expressions l'une après l'autre, *formant une "
"chaîne* d'opérations, c'est-à-dire `DT[ ... ][ ... ][ ... ]`.====="

#: fr/datatable-intro.Rmd.tmp:block 169 (paragraph)
msgid "=====* Or you can also chain them vertically:====="
msgstr "=====* Vous pouvez également les enchaîner verticalement :====="

#: fr/datatable-intro.Rmd.tmp:block 175 (paragraph)
msgid ""
"=====* The last row corresponds to `dep_delay > 0 = TRUE` and `arr_delay > 0 "
"= FALSE`. We can see that `r flights[!is.na(arr_delay) & !is.na(dep_delay), ."
"N, .(dep_delay>0, arr_delay>0)][, N[4L]]` flights started late but arrived "
"early (or on time).====="
msgstr ""
"=====* La dernière ligne correspond à `dep_delay > 0 = TRUE` et `arr_delay > "
"0 = FALSE`. Nous pouvons voir que les vols `r flights[!is.na(arr_delay) & !is."
"na(dep_delay), .N, .(dep_delay>0, arr_delay>0)][, N[4L]]` ont commencé en "
"retard mais sont arrivés en avance (ou à l'heure).====="

#: fr/datatable-intro.Rmd.tmp:block 176 (paragraph)
msgid ""
"=====* Note that we did not provide any names to `by-expression`. Therefore, "
"names have been automatically assigned in the result. As with `j`, you can "
"name these expressions as you would for elements of any `list`, like for e.g. "
"`DT[, .N, .(dep_delayed = dep_delay>0, arr_delayed = arr_delay>0)]`.====="
msgstr ""
"=====* Notez que nous n'avons pas fourni de noms à `by-expression`. Par "
"conséquent, les noms ont été automatiquement assignés dans le résultat. Comme "
"pour `j`, vous pouvez nommer ces expressions comme vous le feriez pour des "
"éléments de n'importe quelle liste, comme par exemple `DT[, .N, .(dep_delayed "
"= dep_delay>0, arr_delayed = arr_delay>0)]`.====="

#: fr/datatable-intro.Rmd.tmp:block 177 (paragraph)
msgid ""
"=====* You can provide other columns along with expressions, for example: "
"`DT[, .N, by = .(a, b>0)]`.====="
msgstr ""
"=====* Vous pouvez fournir d'autres colonnes avec des expressions, par "
"exemple : `DT[, .N, by = .(a, b>0)]`.====="

#: fr/datatable-intro.Rmd.tmp:block 187 (paragraph)
msgid ""
"=====* `.SD` contains all the columns *except the grouping columns* by "
"default.====="
msgstr ""
"=====* `.SD` contient toutes les colonnes *à l'exception des colonnes de "
"regroupement* par défaut.====="

#: fr/datatable-intro.Rmd.tmp:block 188 (paragraph)
msgid ""
"=====* It is also generated by preserving the original order - data "
"corresponding to `ID = \"b\"`, then `ID = \"a\"`, and then `ID = \"c\"`.====="
msgstr ""
"=====* Il est également généré en conservant l'ordre original - les données "
"correspondant à `ID = \"b\"`, puis `ID = \"a\"`, et enfin `ID = \"c\"`.====="

#: fr/datatable-intro.Rmd.tmp:block 191 (paragraph)
msgid ""
"=====* `.SD` holds the rows corresponding to columns `a`, `b` and `c` for "
"that group. We compute the `mean()` on each of these columns using the "
"already-familiar base function `lapply()`.====="
msgstr ""
"=====* `.SD` contient les lignes correspondant aux colonnes `a`, `b` et `c` "
"pour ce groupe. Nous calculons la moyenne avec `mean()` sur chacune de ces "
"colonnes en utilisant la fonction de base déjà familière `lapply()`.====="

#: fr/datatable-intro.Rmd.tmp:block 192 (paragraph)
msgid ""
"=====* Each group returns a list of three elements containing the mean value "
"which will become the columns of the resulting `data.table`.====="
msgstr ""
"=====* Chaque groupe renvoie une liste de trois éléments contenant la valeur "
"moyenne qui deviendra les colonnes du `data.table` résultant.====="

#: fr/datatable-intro.Rmd.tmp:block 193 (paragraph)
msgid ""
"=====* Since `lapply()` returns a `list`, so there is no need to wrap it with "
"an additional `.()` (if necessary, refer to [this tip](#tip-1)).====="
msgstr ""
"=====* Puisque `lapply()` renvoie une liste, il n'est pas nécessaire de "
"l'entourer d'un `.()` supplémentaire (si nécessaire, référez-vous à [cette "
"astuce](#tip-1)).====="

#: fr/datatable-intro.Rmd.tmp:block 204 (paragraph)
msgid ""
"=====* `.SD` is a `data.table` that holds all the rows for *that group*. We "
"simply subset the first two rows as we have seen [here](#subset-rows-integer) "
"already.====="
msgstr ""
"=====* `.SD` est un `data.table` qui contient toutes les lignes de *ce "
"groupe*. Nous allons simplement subdiviser les deux premières lignes comme "
"nous l'avons déjà vu [ici](#subset-rows-integer).====="

#: fr/datatable-intro.Rmd.tmp:block 205 (paragraph)
msgid ""
"=====* For each group, `head(.SD, 2)` returns the first two rows as a `data."
"table`, which is also a `list`, so we do not have to wrap it with `.()`.====="
msgstr ""
"=====* Pour chaque groupe, `head(.SD, 2)` renvoie les deux premières lignes "
"sous forme de `data.table`, qui est également une liste, ce qui nous évite de "
"l'entourer de `.()`.====="

#: fr/datatable-intro.Rmd.tmp:block 210 (paragraph)
msgid ""
"=====* That's it. There is no special syntax required. All we need to know is "
"the base function `c()` which concatenates vectors and [the tip from before]"
"(#tip-1).====="
msgstr ""
"=====* C'est tout. Aucune syntaxe particulière n'est requise. Tout ce que "
"nous avons besoin de connaître est la fonction de base `c()` qui concatène "
"des vecteurs, ainsi que [l'astuce de tout à l'heure](#tip-1).====="

#: fr/datatable-intro.Rmd.tmp:block 213 (paragraph)
msgid ""
"=====* Here, we first concatenate the values with `c(a,b)` for each group, "
"and wrap that with `list()`. So for each group, we return a list of all "
"concatenated values.====="
msgstr ""
"=====* Ici, nous concaténons d'abord les valeurs avec `c(a,b)` pour chaque "
"groupe, et nous les enveloppons avec `list()`. Ainsi, pour chaque groupe, "
"nous renvoyons une liste de toutes les valeurs concaténées.====="

#: fr/datatable-intro.Rmd.tmp:block 214 (paragraph)
msgid ""
"=====* Note that those commas are for display only. A list column can contain "
"any object in each cell, and in this example, each cell is itself a vector "
"and some cells contain longer vectors than others.====="
msgstr ""
"=====* Notez que ces virgules ne servent qu'à l'affichage. Une colonne de "
"liste peut contenir n'importe quel objet dans chaque cellule et, dans cet "
"exemple, chaque cellule est elle-même un vecteur et certaines cellules "
"contiennent des vecteurs plus longs que d'autres.====="

#: fr/datatable-intro.Rmd.tmp:block 225 (paragraph)
msgid ""
"=====* We can also sort a `data.table` using `order()`, which internally uses "
"data.table's fast order for better performance.====="
msgstr ""
"=====* Nous pouvons également trier un `data.table` en utilisant `order()`, "
"qui utilise en interne l’algorithme de tri rapide de data.table pour de "
"meilleures performances.====="

#: fr/datatable-intro.Rmd.tmp:block 228 (paragraph)
msgid "=====1. Select columns the `data.table` way: `DT[, .(colA, colB)]`.====="
msgstr ""
"=====1. Sélectionner les colonnes à la manière de `data.table` : `DT[, ."
"(colA, colB)]`.====="

#: fr/datatable-intro.Rmd.tmp:block 229 (paragraph)
msgid ""
"=====2. Select columns the `data.frame` way: `DT[, c(\"colA\", \"colB\")]`."
"====="
msgstr ""
"=====2. Sélectionner les colonnes à la manière de `data.frame` : `DT[, "
"c(\"colA\", \"colB\")]`.====="

#: fr/datatable-intro.Rmd.tmp:block 230 (paragraph)
msgid "=====3. Compute on columns: `DT[, .(sum(colA), mean(colB))]`.====="
msgstr ""
"=====3. Effectuer des calculs sur les colonnes : `DT[, .(sum(colA), "
"mean(colB))]`.====="

#: fr/datatable-intro.Rmd.tmp:block 231 (paragraph)
msgid ""
"=====4. Provide names if necessary: `DT[, .(sA =sum(colA), mB = mean(colB))]`."
"====="
msgstr ""
"=====4. Indiquer les noms si nécessaire : `DT[, .(sA =sum(colA), mB = "
"mean(colB))]`.====="

#: fr/datatable-intro.Rmd.tmp:block 232 (paragraph)
msgid "=====5. Combine with `i`: `DT[colA > value, sum(colB)]`.====="
msgstr "=====5. Combiner avec `i` : `DT[colA > valeur, sum(colB)]`.====="

#: fr/datatable-intro.Rmd.tmp:block 234 (paragraph)
msgid ""
"=====* Using `by`, we can group by columns by specifying a *list of columns* "
"or a *character vector of column names* or even *expressions*. The "
"flexibility of `j`, combined with `by` and `i`, makes for a very powerful "
"syntax.====="
msgstr ""
"=====* En utilisant `by`, nous pouvons grouper par colonnes en spécifiant une "
"*liste de colonnes* ou un *vecteur de caractères de noms de colonnes* ou même "
"des *expressions*. La flexibilité de `j`, combinée à `by` et `i`, en fait une "
"syntaxe très puissante.====="

#: fr/datatable-intro.Rmd.tmp:block 235 (paragraph)
msgid "=====* `by` can handle multiple columns and also *expressions*.====="
msgstr ""
"=====* `by` peut gérer plusieurs colonnes ainsi que des *expressions*.====="

#: fr/datatable-intro.Rmd.tmp:block 236 (paragraph)
msgid ""
"=====* We can `keyby` grouping columns to automatically sort the grouped "
"result.====="
msgstr ""
"=====* Nous pouvons regrouper les colonnes par `keyby` pour trier "
"automatiquement les résultats groupés.====="

#: fr/datatable-intro.Rmd.tmp:block 237 (paragraph)
msgid ""
"=====* We can use `.SD` and `.SDcols` in `j` to operate on multiple columns "
"using already familiar base functions. Here are some examples:====="
msgstr ""
"=====* Nous pouvons utiliser `.SD` et `.SDcols` dans `j` pour opérer sur "
"plusieurs colonnes en utilisant des fonctions de base déjà connues. Voici "
"quelques exemples:====="

#: fr/datatable-intro.Rmd.tmp:block 238 (paragraph)
msgid ""
"=====_1. `DT[, lapply(.SD, fun), by = ..., .SDcols = ...]` - applies `fun` to "
"all columns specified in `.SDcols` while grouping by the columns specified in "
"`by`.====="
msgstr ""
"=====_1. `DT[, lapply(.SD, fun), by = ..., .SDcols = ...]` - applique `fun` à "
"toutes les colonnes spécifiées dans `.SDcols` tout en groupant par les "
"colonnes spécifiées dans `by`.====="

#: fr/datatable-intro.Rmd.tmp:block 239 (paragraph)
msgid ""
"=====_2. `DT[, head(.SD, 2), by = ...]` - return the first two rows for each "
"group.====="
msgstr ""
"=====_2. `DT[, head(.SD, 2), by = ...]` - renvoie les deux premières lignes "
"pour chaque groupe.====="

#: fr/datatable-intro.Rmd.tmp:block 240 (paragraph)
msgid ""
"=====_3. `DT[col > val, head(.SD, 1), by = ...]` - combine `i` along with `j` "
"and `by`.====="
msgstr ""
"=====_3. `DT[col > val, head(.SD, 1), by = ...]` - combine `i` avec `j` et "
"`by`.====="

#: fr/datatable-intro.Rmd.tmp:block 40 (paragraph)
msgid ""
"=====* Within the frame of a `data.table`, columns can be referred to *as if "
"they are variables*, much like in SQL or Stata. Therefore, we simply refer to "
"`origin` and `month` as if they are variables. We do not need to add the "
"prefix `flights$$$` each time. Nevertheless, using `flights$$$origin` and "
"`flights$$$month` would work just fine.====="
msgstr ""
"=====* Dans le cadre d'un `data.table`, on peut se référer aux colonnes "
"*comme s'il s'agissait de variables*, un peu comme dans SQL ou Stata. Par "
"conséquent, nous nous référons simplement à `origin` et `month` comme s'il "
"s'agissait de variables. Nous n'avons pas besoin d'ajouter le préfixe `vol$$"
"$` à chaque fois. Néanmoins, l'utilisation de `flights$$$origin` et `flights$$"
"$month` fonctionnerait parfaitement.====="

#: fr/datatable-intro.Rmd.tmp:block 224 (paragraph)
msgid ""
"=====* We can subset rows similar to a `data.frame`- except you don't have to "
"use `DT$$$` repetitively since columns within the frame of a `data.table` are "
"seen as if they are *variables*.====="
msgstr ""
"=====* Nous pouvons subdiviser les lignes comme dans un `data.frame` - sauf "
"que vous n'avez pas besoin d'utiliser `DT$$$` de façon répétitive puisque les "
"colonnes dans le contexte d'un `data.table` sont vues comme si elles étaient "
"des *variables*.====="
