#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: \n"
"PO-Revision-Date: \n"
"Last-Translator: Christian Wiat <w9204-rs@yahoo.com>\n"
"Language-Team: \n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Generator: Poedit 3.4.4\n"

#: d.Rmd:block 3 (paragraph)
msgid ""
"This vignette introduces the `data.table` syntax, its general form, how to "
"*subset* rows, *select and compute* on columns, and perform aggregations *by "
"group*. Familiarity with the `data.frame` data structure from base R is "
"useful, but not essential to follow this vignette."
msgstr ""
"Cette vignette présente la syntaxe de `data.table` , sa forme générale, "
"comment *extraire les lignes*, *sélectionner et faire des opérations* sur les "
"colonnes, et réaliser des agrégations *par groupe*. Il est avantageux d'être "
"familiarisé avec la structure de données `data.frame` de base du R, mais cela "
"n'est pas essentiel pour suivre cette vignette."

#: d.Rmd:block 4 (header)
msgid "Data analysis using `data.table`"
msgstr "Analyser des données en utilisant `data.table`"

#: d.Rmd:block 5 (paragraph)
msgid ""
"Data manipulation operations such as *subset*, *group*, *update*, *join*, "
"etc. are all inherently related. Keeping these *related operations together* "
"allows for:"
msgstr ""
"Les opérations concernant le traitement des données telles que *subset*, "
"*group*, *update*, *join*, etc. sont toutes intimement liées. En regroupant "
"*ces opérations apparentées* cela nous permet :"

#: d.Rmd:block 6 (unordered list)
msgid ""
"*concise* and *consistent* syntax irrespective of the set of operations you "
"would like to perform to achieve your end goal."
msgstr ""
"une syntaxe *concise* et *cohérente* quelque soit l'ensemble d'opérations que "
"vous souhaiteriez exécuter pour finaliser vos objectifs."

#: d.Rmd:block 6 (unordered list)
msgid ""
"performing analysis *fluidly* without the cognitive burden of having to map "
"each operation to a particular function from a potentially huge set of "
"functions available before performing the analysis."
msgstr ""
"de réaliser les analyses de manière *fluide* sans le fardeau cognitif d'avoir "
"à associer chaque opération à une fonction particulière issue d'un sur-"
"ensemble particulièrement énorme de fonctions disponibles avant de réaliser "
"l'analyse."

#: d.Rmd:block 6 (unordered list)
msgid ""
"*automatically* optimising operations internally and very effectively by "
"knowing precisely the data required for each operation, leading to very fast "
"and memory-efficient code."
msgstr ""
"d'optimiser *automatiquement* les opérations de manière interne et très "
"efficace en connaissant précisément les données nécessaires à chaque "
"opération, ce qui conduit à avoir un code très rapide et qui utilise "
"efficacement la mémoire."

#: d.Rmd:block 7 (paragraph)
msgid ""
"Briefly, if you are interested in reducing *programming* and *compute* time "
"tremendously, then this package is for you. The philosophy that `data.table` "
"adheres to makes this possible. Our goal is to illustrate it through this "
"series of vignettes."
msgstr ""
"En résumé, si vous souhaitez réduire drastiquement le temps de "
"*programmation* et de *compilation*, alors ce package est fait pour vous. "
"C'est la philosophie suivie par  `data.table` pour rendre cela possible. "
"Notre but est d'illustrer ceci au travers de cette série de vignettes."

#: d.Rmd:block 8 (header)
msgid "Data {#data}"
msgstr "Données {#data}"

#: d.Rmd:block 9 (paragraph)
msgid ""
"In this vignette, we will use [NYC-flights14](https://raw.githubusercontent."
"com/Rdatatable/data.table/master/vignettes/flights14.csv) data obtained from "
"the [flights](https://github.com/arunsrinivasan/flights) package (available "
"on GitHub only). It contains On-Time flights data from the Bureau of "
"Transportation Statistics for all the flights that departed from New York "
"City airports in 2014 (inspired by [nycflights13](https://github.com/"
"tidyverse/nycflights13)). The data is available only for Jan-Oct'14."
msgstr ""
"Dans cette vignette, nous utiliseront les données [NYC-flights14](https://raw."
"githubusercontent.com/Rdatatable/data.table/master/vignettes/flights14.csv) "
"obtenues du package [flights](https://github.com/arunsrinivasan/flights) "
"(disponible sur GitHub seulement). Il contient les horaires des vols d'avions "
"du Bureau of Transportation Statistics à propos de tous les vols partant des "
"aéroports de New York City en 2014 (inspiré de [nycflights13](https://github."
"com/tidyverse/nycflights13)). Les données ne concernent que les mois de "
"janvier à octobre 2014."

#: d.Rmd:block 10 (paragraph)
msgid ""
"We can use `data.table`'s fast-and-friendly file reader `fread` to load "
"`flights` directly as follows:"
msgstr ""
"Vous pouvez utiliser le lecteur de fichiers rapide et convivial 'fread' de "
"'data.table' pour charger 'flights' ditectement ainsi :"

#: d.Rmd:block 13 (paragraph)
msgid ""
"Aside: `fread` accepts `http` and `https` URLs directly, as well as operating "
"system commands such as `sed` and `awk` output. See `?fread` for examples."
msgstr ""
"A noter : 'fread' accepte directement les URLS 'http' et 'https', ainsi que "
"les commandes système opérationnelles telles que les sorties de 'sed' et "
"'awk'. Voir '?fread' pour les exemples."

#: d.Rmd:block 14 (header)
msgid "Introduction"
msgstr "Introduction"

#: d.Rmd:block 15 (paragraph)
msgid "In this vignette, we will"
msgstr "Dans cette vignette, nous allons"

#: d.Rmd:block 16 (ordered list)
msgid ""
"Start with the basics - what is a `data.table`, its general form, how to "
"*subset* rows, how to *select and compute* on columns;"
msgstr ""
"Commencer par les notions de base - une 'data.table' c'est quoi ? sa forme "
"générale, comment extraire des *sous-ensemble* de lignes, comment "
"*sélectionner et calculer* avec les colonnes;"

#: d.Rmd:block 16 (ordered list)
msgid "Then we will look at performing data aggregations by group"
msgstr "Puis nous aborderons la manière d'agréger les données par groupes"

#: d.Rmd:block 17 (header)
msgid "1. Basics {#basics-1}"
msgstr "1. Les bases {#basics-1}"

#: d.Rmd:block 18 (header)
msgid "a) What is `data.table`? {#what-is-datatable-1a}"
msgstr "a) 'data.table' c'est quoi ? {#what-is-datatable-1a}"

#: d.Rmd:block 19 (paragraph)
msgid ""
"`data.table` is an R package that provides **an enhanced version** of a `data."
"frame`, the standard data structure for storing data in `base` R. In the "
"[Data](#data) section above, we saw how to create a `data.table` using "
"`fread()`, but alternatively we can also create one using the `data.table()` "
"function. Here is an example:"
msgstr ""
"'data.table' est un package R qui fournit **une version étendue** d'un 'data."
"frame', qui est la structure de données standard pour stocker des données "
"dans la 'base' R. Dans la [Data](#data) section ci-dessus, nous avons vu "
"comment créer une 'data.table' avec 'fread()', mais on peut aussi en créer "
"une en utilisant la fonction 'data.table()' . Voici un exemple :"

#: d.Rmd:block 21 (paragraph)
msgid ""
"You can also convert existing objects to a `data.table` using `setDT()` (for "
"`data.frame` and `list` structures) or `as.data.table()` (for other "
"structures). For more details pertaining to the difference (goes beyond the "
"scope of this vignette), please see `?setDT` and `?as.data.table`."
msgstr ""
"Vous pouvez aussi convertir des objets existants en une `data.table` en "
"utilisant `setDT()` (pour les structures `data.frame` et `list`) ou `as.data."
"table()` (pour les autres structures). Pour les autres détails concernant les "
"différences (ce qui est hors du champ de cette vignette), voir `?setDT` et `?"
"as.data.table`."

#: d.Rmd:block 22 (header)
msgid "Note that:"
msgstr "Notez que :"

#: d.Rmd:block 23 (unordered list)
msgid ""
"Row numbers are printed with a `:` in order to visually separate the row "
"number from the first column."
msgstr ""
"Les numéros de lignes sont imprimés avec un ':' pour séparer visuellement le "
"numéro de ligne, de la première colonne."

#: d.Rmd:block 23 (unordered list)
msgid ""
"When the number of rows to print exceeds the global option `datatable.print."
"nrows` (default = `r getOption(\"datatable.print.nrows\")`), it automatically "
"prints only the top 5 and bottom 5 rows (as can be seen in the [Data](#data) "
"section). For a large `data.frame`, you may have found yourself waiting "
"around while larger tables print-and-page, sometimes seemingly endlessly. "
"This restriction helps with that, and you can query the default number like "
"so:"
msgstr ""
"Quand le nombre de lignes à imprimer dépasse l'option globale `datatable."
"print.nrows` (valeur par défaut = `r getOption(\"datatable.print.nrows\")`), "
"il affiche automatiquement uniquement les 5 premières lignes et les 5 "
"dernières (comme on peut le voir dans la section [Data](#data). Pour un grand "
"`data.frame`, il est possible que vous restiez en attente le temps que les "
"tableaux plus importants soient sortis, ce qui peut paraître interminable. "
"Cette restriction vous aide en ce sens, et vous pouvez demander le nombre par "
"défaut ainsi :"

#: d.Rmd:block 23 (unordered list)
msgid ""
"`data.table` doesn't set or use *row names*, ever. We will see why in the "
"*\"Keys and fast binary search based subset\"* vignette."
msgstr ""
"'data.table' n'initialise pas ni n'utilise jamais les *row names*. Nous "
"verrons pourquoi dans la vignette *\"Clés et sous ensemble basé sur la "
"recherche binaire rapide\"*."

#: d.Rmd:block 24 (header)
msgid ""
"b) General form - in what way is a `data.table` *enhanced*? {#enhanced-1b}"
msgstr ""
"b) Forme générale - dans quel sens la 'data.table' est-elle *étendue* ? "
"{#enhanced-1b}"

#: d.Rmd:block 25 (paragraph)
msgid ""
"In contrast to a `data.frame`, you can do *a lot more* than just subsetting "
"rows and selecting columns within the frame of a `data.table`, i.e., within "
"`[ ... ]` (NB: we might also refer to writing things inside `DT[...]` as "
"\"querying `DT`\", as an analogy or in relevance to SQL). To understand it we "
"will have to first look at the *general form* of the `data.table` syntax, as "
"shown below:"
msgstr ""
"Par rapport à un `data.frame`, vous pouvez  faire *beaucoup plus de choses* "
"qu'extraire des lignes et sélectionner des colonnes dans la structure d'une "
"`data.table`, par exemple, avec `[ ... ]` (Notez bien : nous pourrions aussi "
"faire référence à écrire quelque chose dans `DT[...]` comme \"interroger "
"`DT`\", par analogie ou similairement à SQL). Pour le comprendre il faut "
"d'abord que nous regardions la *forme générale* de la syntaxe `data.table`, "
"comme indiqué ci-dessous :"

#: d.Rmd:block 27 (paragraph)
msgid ""
"Users with an SQL background might perhaps immediately relate to this syntax."
msgstr ""
"Les utilisateurs ayant des connaissances SQL feront peut être directement le "
"lien avec cette syntaxe."

#: d.Rmd:block 28 (header)
msgid "The way to read it (out loud) is:"
msgstr "La manière de le lire (à haute voix) est :"

#: d.Rmd:block 29 (paragraph)
msgid ""
"Take `DT`, subset/reorder rows using `i`, then calculate `j`, grouped by `by`."
msgstr ""
"Utiliser `DT`, extraire ou trier les lignes en utilisant `i`, puis calculer "
"`j`, grouper avec `by`."

#: d.Rmd:block 30 (paragraph)
msgid ""
"Let's begin by looking at `i` and `j` first - subsetting rows and operating "
"on columns."
msgstr ""
"Commençons par voir 'i' et 'j' d'abord - en indiçant les lignes et en "
"travaillant sur les colonnes."

#: d.Rmd:block 31 (header)
msgid "c) Subset rows in `i` {#subset-i-1c}"
msgstr "c) Regrouper les lignes en 'i' {#subset-i-1c}"

#: d.Rmd:block 32 (header)
msgid ""
"-- Get all the flights with \"JFK\" as the origin airport in the month of "
"June."
msgstr ""
"-- Obtenir tous les vols qui ont \"JFK\" comme aéroport de départ pendant le "
"mois de juin."

#: d.Rmd:block 34 (unordered list)
msgid ""
"Within the frame of a `data.table`, columns can be referred to *as if they "
"are variables*, much like in SQL or Stata. Therefore, we simply refer to "
"`origin` and `month` as if they are variables. We do not need to add the "
"prefix `flights$` each time. Nevertheless, using `flights$origin` and "
"`flights$month` would work just fine."
msgstr ""
"Dans la structure d'une `data.table`, les colonnes peuvent être référencées "
"*comme s'il s'agissait de variables*, un peu comme dans SQL ou Stata. C'est "
"pourquoi nous utiliseront simplement `origin` et `month` comme des variables. "
"Il n'est pas nécessaire d'ajouter le préfixe `flights$` à chaque fois. "
"Néanmoins, utiliser `flights$origin` et `flights$month` fonctionne aussi bien."

#: d.Rmd:block 34 (unordered list)
msgid ""
"The *row indices* that satisfy the condition `origin == \"JFK\" & month == "
"6L` are computed, and since there is nothing else left to do, all columns "
"from `flights` at rows corresponding to those *row indices* are simply "
"returned as a `data.table`."
msgstr ""
"Les *indices des lignes* qui vérifient la condition `origin == \"JFK\" & "
"month == 6L` sont calculés, et comme il ne reste plus rien d'autre à faire, "
"toutes les colonnes de `flights` des lignes qui correspondent à ces *indices "
"de lignes* sont simplement renvoyées en tant que `data.table`."

#: d.Rmd:block 34 (unordered list)
msgid ""
"A comma after the condition in `i` is not required. But `flights[origin == "
"\"JFK\" & month == 6L, ]` would work just fine. In a `data.frame`, however, "
"the comma is necessary."
msgstr ""
"Une virgule après la condition dans `i` n'est pas nécessaire. Mais "
"`flights[origin == \"JFK\" & month == 6L, ]` fonctionnera aussi bien. Avec "
"une `data.frame` néanmoins, la virgule est obligatoire."

#: d.Rmd:block 35 (header)
msgid "-- Get the first two rows from `flights`. {#subset-rows-integer}"
msgstr ""
"-- Récupérer les deux premières lignes de 'flights'. {#subset-rows-integer}"

#: d.Rmd:block 37 (unordered list)
msgid ""
"In this case, there is no condition. The row indices are already provided in "
"`i`. We therefore return a `data.table` with all columns from `flights` at "
"rows for those *row indices*."
msgstr ""
"Dans ce cas il n'y a pas de condition. Les indices de ligne sont déjà fournis "
"dans `i`. C'est pourquoi nous renvoyons une `data.table` avec toutes les "
"colonnes de `flights` pour les lignes qui correspondent aux *indices des "
"lignes*."

#: d.Rmd:block 38 (header)
msgid ""
"-- Sort `flights` first by column `origin` in *ascending* order, and then by "
"`dest` in *descending* order:"
msgstr ""
"-- Trier `flights` d'abord sur la colonne `origin` dans l'ordre *ascending*, "
"puis par `dest` dans l'ordre *descendant* :"

#: d.Rmd:block 39 (paragraph)
msgid "We can use the R function `order()` to accomplish this."
msgstr "Nous pouvons utiliser la fonction R 'order()' pour faire cela."

#: d.Rmd:block 41 (header)
msgid "`order()` is internally optimised"
msgstr "'order()' est optimisé en interne"

#: d.Rmd:block 42 (unordered list)
msgid ""
"We can use \"-\" on `character` columns within the frame of a `data.table` to "
"sort in decreasing order."
msgstr ""
"Il est possible d'utiliser '-' avec les colonnes de type `character` dans le "
"cadre d'une `data.table` pour trier par ordre décroissant."

#: d.Rmd:block 42 (unordered list)
msgid ""
"In addition, `order(...)` within the frame of a `data.table` uses `data."
"table`'s internal fast radix order `forder()`. This sort provided such a "
"compelling improvement over R's `base::order` that the R project adopted the "
"`data.table` algorithm as its default sort in 2016 for R 3.3.0 (for "
"reference, check `?sort` and the [R Release NEWS](https://cran.r-project.org/"
"doc/manuals/r-release/NEWS.pdf))."
msgstr ""
"De plus, `order(...)` dans la structure d'une `data.table` utilise 's le fast "
"radix order interne `forder()` de `data.table`. Ce tri a produit de telles "
"améliorations par rapport au `base::order` de R que le projet R a adopté "
"l'algorithme `data.table` pour son tri par défaut en 2016 pour R 3.3.0 (pour "
"les références, vérifiez `?sort` et les [Informations des versions R](https://"
"cran.r-project.org/doc/manuals/r-release/NEWS.pdf))."

#: d.Rmd:block 43 (paragraph)
msgid ""
"We will discuss `data.table`'s fast order in more detail in the *`data.table` "
"internals* vignette."
msgstr ""
"Nous discuterons de l'ordonnancement rapide de la `data.table` plus en "
"détails dans la vignette *fonctionnement interne de `data.table` internals*."

#: d.Rmd:block 44 (header)
msgid "d) Select column(s) in `j` {#select-j-1d}"
msgstr "d) Sélection de colonne(s) dans 'j' {#select-j-1d}"

#: d.Rmd:block 45 (header)
msgid "-- Select `arr_delay` column, but return it as a *vector*."
msgstr ""
"-- Sélectionner la colonne 'arr_delay', mais la renvoyer en tant que *vector*."

#: d.Rmd:block 47 (unordered list)
msgid ""
"Since columns can be referred to as if they are variables within the frame of "
"a `data.table`, we directly refer to the *variable* we want to subset. Since "
"we want *all the rows*, we simply skip `i`."
msgstr ""
"Comme les colonnes peuvent être référencées comme des variables de la "
"structure d'une `data.table`, nous utilisons directement la *variable* que "
"nous voulons extraire. Comme nous voulons *toutes les lignes*, nous omettons "
"simplement `i`."

#: d.Rmd:block 47 (unordered list)
msgid "It returns *all* the rows for the column `arr_delay`."
msgstr "Il renvoie *toutes* les lignes de la colonne 'arr_delay'."

#: d.Rmd:block 48 (header)
msgid "-- Select `arr_delay` column, but return as a `data.table` instead."
msgstr ""
"-- Sélectionner la colonne 'arr_delay', mais la renvoyer en tant que 'data."
"table'."

#: d.Rmd:block 50 (unordered list)
msgid ""
"We wrap the *variables* (column names) within `list()`, which ensures that a "
"`data.table` is returned. In the case of a single column name, not wrapping "
"with `list()` returns a vector instead, as seen in the [previous example]"
"(#select-j-1d)."
msgstr ""
"Nous encadrons les *variables* (noms des colonnes) avec `list()`, qui assure "
"qu'une `data.table` est renvoyée. Dans le cas d'un seul nom de colonne, si on "
"n'encadre pas avec `list()` alors on renvoie un vecteur à la place, comme on "
"l'a vu dans l'[exemple précédent](#select-j-1d)."

#: d.Rmd:block 50 (unordered list)
msgid ""
"`data.table` also allows wrapping columns with `.()` instead of `list()`. It "
"is an *alias* to `list()`; they both mean the same. Feel free to use "
"whichever you prefer; we have noticed most users seem to prefer `.()` for "
"conciseness, so we will continue to use `.()` hereafter."
msgstr ""
"`data.table` permet aussi d'inclure les colonnes avec `.()` à la place de "
"`list()`. C'est un *alias* de `list()`; ils signifient la même chose. "
"Utilisez la forme que vous souhaitez; nous avons remarqué que la plupart des "
"utilisateurs semblent préférer `.()` pour être plus concis, donc nous "
"continuerons à utiliser `.()` par la suite."

#: d.Rmd:block 51 (paragraph)
msgid ""
"A `data.table` (and a `data.frame` too) is internally a `list` as well, with "
"the stipulation that each element has the same length and the `list` has a "
"`class` attribute. Allowing `j` to return a `list` enables converting and "
"returning `data.table` very efficiently."
msgstr ""
"Une `data.table` (et également une `data.frame`) est aussi en interne une "
"`list` , avec la caractéristique que chaque élément a la même longueur et que "
"la `list` possède un attribut `class`. En permettant à `j` de renvoyer une "
"`list` cela permet de convertir et de renvoyer des `data.table` très "
"efficacement."

#: d.Rmd:block 52 (header)
msgid "Tip: {#tip-1}"
msgstr "Conseil : {#tip-1}"

#: d.Rmd:block 53 (paragraph)
msgid ""
"As long as `j-expression` returns a `list`, each element of the list will be "
"converted to a column in the resulting `data.table`. This makes `j` quite "
"powerful, as we will see shortly. It is also very important to understand "
"this for when you'd like to make more complicated queries!!"
msgstr ""
"Tant que `j-expression` renvoie une `list`, chaque élément de la liste sera "
"converti en colonne dans la `data.table` résultante. Ce qui fait que `j` est "
"très puissant, comme nous le verrons bientôt. Il est aussi très important de "
"comprendre cela dans le cas où vous auriez à faire des requêtes plus "
"compliquées !!"

#: d.Rmd:block 54 (header)
msgid "-- Select both `arr_delay` and `dep_delay` columns."
msgstr "-- Sélectionner à la fois les colonnes `arr_delay` et `dep_delay`."

#: d.Rmd:block 56 (unordered list)
msgid "Wrap both columns within `.()`, or `list()`. That's it."
msgstr "Encadrer les deux colonnes avec `.()`, ou `list()`. C'est tout."

#: d.Rmd:block 57 (header)
msgid ""
"-- Select both `arr_delay` and `dep_delay` columns *and* rename them to "
"`delay_arr` and `delay_dep`."
msgstr ""
"-- Sélectionner à la fois les colonnes `arr_delay` et `dep_delay` *et* les "
"renommer en `delay_arr` et `delay_dep`."

#: d.Rmd:block 58 (paragraph)
msgid ""
"Since `.()` is just an alias for `list()`, we can name columns as we would "
"while creating a `list`."
msgstr ""
"Comme `.()` est juste un alias pour `list()`, nous pouvons donner un nom "
"quelconque aux colonnes comme si on créait une `list`."

#: d.Rmd:block 60 (header)
msgid "e) Compute or *do* in `j`"
msgstr "e) Calcul ou *do* dans 'j'"

#: d.Rmd:block 61 (header)
msgid "-- How many trips have had total delay < 0?"
msgstr "-- Combien de voyages on eu un retard total < 0 ?"

#: d.Rmd:block 63 (header)
msgid "What's happening here?"
msgstr "Que se passe-t-il dans ce cas ?"

#: d.Rmd:block 64 (unordered list)
msgid ""
"`data.table`'s `j` can handle more than just *selecting columns* - it can "
"handle *expressions*, i.e., *computing on columns*. This shouldn't be "
"surprising, as columns can be referred to as if they are variables. Then we "
"should be able to *compute* by calling functions on those variables. And "
"that's what precisely happens here."
msgstr ""
"`j` de `data.table` peut gérer davantage que simplement la *sélection de "
"colonnes* - il peut gérer les *expressions*, comme *faire des calculs sur les "
"colonnes*. Ilne faut pas s'en étonner, car les colonnes peuvent être "
"référencées comme des variables. Puis nous devrions être capable de "
"*calculer* en appelant des fonctions sur ces variables. Et c'est précisément "
"ce qui se passe ici."

#: d.Rmd:block 65 (header)
msgid "f) Subset in `i` *and* do in `j`"
msgstr "f) Sous-ensemble de `i` *et* do dans `j`"

#: d.Rmd:block 66 (header)
msgid ""
"-- Calculate the average arrival and departure delay for all flights with "
"\"JFK\" as the origin airport in the month of June."
msgstr ""
"-- Calculer le nombre moyen de retards des arrivées et des départs pour tous "
"les vols au départ de l'aéroport \"JFK\" pendant le mois de juin."

#: d.Rmd:block 68 (unordered list)
msgid ""
"We first subset in `i` to find matching *row indices* where `origin` airport "
"equals `\"JFK\"`, and `month` equals `6L`. We *do not* subset the *entire* "
"`data.table` corresponding to those rows *yet*."
msgstr ""
"Nous extrayons un sous-ensemble de `i`  pour les *indices des lignes* où "
"l'aéroport `origin` vaut `\"JFK\"`, et `month` vaut `6L`. *Cependant* nous "
"*ne traitons pas* la `data.table` *entière* correspondant à ces lignes."

#: d.Rmd:block 68 (unordered list)
msgid ""
"Now, we look at `j` and find that it uses only *two columns*. And what we "
"have to do is to compute their `mean()`. Therefore, we subset just those "
"columns corresponding to the matching rows, and compute their `mean()`."
msgstr ""
"Maintenant, regardons `j` qui n'utilise que *deux colonnes*. Ce que nous "
"devons faire c'est calculer leur `mean()`. C'est pourquoi, nous n'extrayons "
"que ces deux colonnes pour les lignes qui correspondent et calculons leur "
"`mean()`."

#: d.Rmd:block 69 (paragraph)
msgid ""
"Because the three main components of the query (`i`, `j` and `by`) are "
"*together* inside `[...]`, `data.table` can see all three and optimise the "
"query altogether *before evaluation*, rather than optimizing each separately. "
"We are able to therefore avoid the entire subset (i.e., subsetting the "
"columns *besides* `arr_delay` and `dep_delay`), for both speed and memory "
"efficiency."
msgstr ""
"Parce que les trois composants principaux de la requête (`i`, `j` et `by`) "
"figurent *ensemble* dans `[...]`, `data.table` peut les voir tous trois et "
"optimiser la requête dans sa totalité *avant l'évaluation*, plutôt que "
"d'optimiser chacun séparément. Par conséquent nous pouvons éviter le sous-"
"ensemble complet (par exemple trier les colonnes *annexes* `arr_delay` et "
"`dep_delay`), pour la rapidité et l'efficacité de la mémoire."

#: d.Rmd:block 70 (header)
msgid ""
"-- How many trips have been made in 2014 from \"JFK\" airport in the month of "
"June?"
msgstr ""
"-- Combien de voyages ont été réalisés en 2014 au départ de l'aéroport "
"\"JFK\" au mois de juin ?"

#: d.Rmd:block 72 (paragraph)
msgid ""
"The function `length()` requires an input argument. We just need to compute "
"the number of rows in the subset. We could have used any other column as the "
"input argument to `length()`. This approach is reminiscent of `SELECT "
"COUNT(dest) FROM flights WHERE origin = 'JFK' AND month = 6` in SQL."
msgstr ""
"La fonction `length()` nécessite un argument d'entrée. Il suffit juste de "
"calculer le nombre de lignes du sous-ensemble. On aurait pu utiliser "
"n'importe quelle colonne comme argument d'entrée de `length()`. Cette "
"approche est une réminiscence de `SELECT COUNT(dest) FROM flights WHERE "
"origin = 'JFK' AND month = 6` en SQL."

#: d.Rmd:block 73 (paragraph)
msgid ""
"This type of operation occurs quite frequently, especially while grouping (as "
"we will see in the next section), to the point where `data.table` provides a "
"*special symbol* `.N` for it."
msgstr ""
"Ce type d'opération arrive assez fréquement, particulièrement lors des "
"regroupements (comme nous le verrons dans la section suivante), au point que "
"`data.table` fournit un *symbole spécial* `.N` pour cela."

#: d.Rmd:block 74 (header)
msgid "g) Handle non-existing elements in `i`"
msgstr "g) Gérer les éléments absents dans `i`"

#: d.Rmd:block 75 (header)
msgid "-- What happens when querying for non-existing elements?"
msgstr "-- Que se passe-t-il quand on interroge des éléments non-existants ?"

#: d.Rmd:block 76 (paragraph)
msgid ""
"When querying a `data.table` for elements that do not exist, the behavior "
"differs based on the method used."
msgstr ""
"Lorsque vous interrogez une `data.table` pour des éléments qui n'existent "
"pas, le comportement dépend de la méthode utilisée."

#: d.Rmd:block 78 (unordered list)
msgid "**Key-based subsetting: `dt[\"d\"]`**"
msgstr "**Indicer en utilisant une clé : `dt[\"d\"]`**"

#: d.Rmd:block 78 (unordered list)
msgid ""
"This performs a right join on the key column `x`, resulting in a row with `d` "
"and `NA` for columns not found. When using `setkeyv`, the table is sorted by "
"the specified keys and an internal index is created, enabling binary search "
"for efficient subsetting."
msgstr ""
"Ceci réalise une jointure parfaite sur la colonne clé `x`, fournissant une "
"rangée avec `d` et `NA` pour les colonnes absentes. En utilisant `setkeyv`, "
"la table est triée en fonction des clés fournies et un index interne est "
"créé, permettant une recherche binaire et des performances optimisées."

#: d.Rmd:block 78 (unordered list)
msgid "**Logical subsetting: `dt[x == \"d\"]`**"
msgstr "**Sous-ensemble logique : `dt[x == \"d\"]`**"

#: d.Rmd:block 78 (unordered list)
msgid ""
"This performs a standard subset operation that does not find any matching "
"rows and thus returns an empty `data.table`."
msgstr ""
"Ceci réalise une opération standard de sous-ensemble qui ne trouve aucune "
"correspondance de lignes et donc renvoie une `data.table` vide."

#: d.Rmd:block 78 (unordered list)
msgid "**Exact match using `nomatch=NULL`**"
msgstr "**Correspondance exacte en utilisant `nomatch=NULL`**"

#: d.Rmd:block 78 (unordered list)
msgid ""
"For exact matches without `NA` for non-existing elements, use `nomatch=NULL`:"
msgstr ""
"Pour une correspondance stricte sans `NA` pour les éléments absents, utiliser "
"`nomatch=NULL` :"

#: d.Rmd:block 79 (paragraph)
msgid ""
"Understanding these behaviors can help prevent confusion when dealing with "
"non-existing elements in your data."
msgstr ""
"En assimilant ces comportements, cela vous ôtera toute confusion lorsque vous "
"trouverez des éléments absents parmi vos données."

#: d.Rmd:block 80 (header)
msgid "Special symbol `.N`: {#special-N}"
msgstr "Symbol spécial `.N`: {#special-N}"

#: d.Rmd:block 81 (paragraph)
msgid ""
"`.N` is a special built-in variable that holds the number of observations *in "
"the current group*. It is particularly useful when combined with `by` as "
"we'll see in the next section. In the absence of group by operations, it "
"simply returns the number of rows in the subset."
msgstr ""
"`.N` est une variable interne spéciale qui contient le nombre d'observations "
"*dans le groupe actuel*. Elle est particulièrement utile combinée avec `by` "
"comme nous le verrons dans la prochaine section. S'il n'y a pas de groupe "
"pour les opérations, le nombre de lignes dans le sous-ensemble sera "
"simplement renvoyé."

#: d.Rmd:block 82 (paragraph)
msgid ""
"Now that we now, we can now accomplish the same task by using `.N` as follows:"
msgstr ""
"Maintenant que nous savons, nous pouvons accomplir la même tâche en utilisant "
"`.N` ainsi :"

#: d.Rmd:block 84 (unordered list)
msgid ""
"Once again, we subset in `i` to get the *row indices* where `origin` airport "
"equals *\"JFK\"*, and `month` equals *6*."
msgstr ""
"Une fois de plus, nous extrayons un sous-ensemble de `i` avec les *indices de "
"ligne* où les aéroports `origin` valent *\"JFK\"*, et `month` vaut *6*."

#: d.Rmd:block 84 (unordered list)
msgid ""
"We see that `j` uses only `.N` and no other columns. Therefore, the entire "
"subset is not materialised. We simply return the number of rows in the subset "
"(which is just the length of row indices)."
msgstr ""
"Nous voyons que `j` utilise `.N` uniquement et pas d'autres colonnnes. C'est "
"pourquoi le sous-ensemble complet n'est pas matérialisé. Nous renvoyons "
"seulement le nombre de lignes du sous-ensemble (qui est simplement la "
"longueur des indices de lignes)."

#: d.Rmd:block 84 (unordered list)
msgid ""
"Note that we did not wrap `.N` with `list()` or `.()`. Therefore, a vector is "
"returned."
msgstr ""
"Notez que nous n'avons pas encadré `.N` avec `list()` ni `.()`. C'est "
"pourquoi un vecteur est renvoyé."

#: d.Rmd:block 85 (paragraph)
msgid ""
"We could have accomplished the same operation by doing `nrow(flights[origin "
"== \"JFK\" & month == 6L])`. However, it would have to subset the entire "
"`data.table` first corresponding to the *row indices* in `i` *and then* "
"return the rows using `nrow()`, which is unnecessary and inefficient. We will "
"cover this and other optimisation aspects in detail under the *`data.table` "
"design* vignette."
msgstr ""
"On aurait pu faire la même opération en écrivant `nrow(flights[origin == "
"\"JFK\" & month == 6L])`. Néanmoins il aurait fallu d'abord dissocier la "
"`data.table` entière  en fonction des *indices de lignes* dans `i` *puis* "
"renvoyer les lignes en utilisant `nrow()`, ce qui est inutile et pas "
"efficace. Nous aborderons en détails ce sujet et d'autres aspects de "
"l'optimisation dans la vignette *architecture de `data.table`*."

#: d.Rmd:block 86 (header)
msgid ""
"h) Great! But how can I refer to columns by names in `j` (like in a `data."
"frame`)? {#refer_j}"
msgstr ""
"h) Super !  Mais comment référencer les colonnes par nom dans `j` (comme avec "
"un `data.frame`) ? {#refer_j}"

#: d.Rmd:block 87 (paragraph)
msgid ""
"If you're writing out the column names explicitly, there's no difference "
"compared to a `data.frame` (since v1.9.8)."
msgstr ""
"Si vous imprimez le nom des colonnes explicitement, il n'y a pas de "
"différence avec un `data.frame` (depuis v1.9.8)."

#: d.Rmd:block 88 (header)
msgid "-- Select both `arr_delay` and `dep_delay` columns the `data.frame` way."
msgstr ""
"-- Sélectionner simultanément les colonnes `arr_delay` et `dep_delay` à la "
"manière d'un `data.frame`."

#: d.Rmd:block 90 (paragraph)
msgid ""
"If you've stored the desired columns in a character vector, there are two "
"options: Using the `..` prefix, or using the `with` argument."
msgstr ""
"Si vous avez stocké les colonnes souhaitées dans un vecteur de caractères, il "
"y a deux options : utiliser le préfixe `..` , ou utiliser l'argument `with`."

#: d.Rmd:block 91 (header)
msgid "-- Select columns named in a variable using the `..` prefix"
msgstr ""
"-- Sélectionnez les colonnes nommées dans une variable en utilisant le "
"préfixe `..`"

#: d.Rmd:block 93 (paragraph)
msgid ""
"For those familiar with the Unix terminal, the `..` prefix should be "
"reminiscent of the \"up-one-level\" command, which is analogous to what's "
"happening here -- the `..` signals to `data.table` to look for the "
"`select_cols` variable \"up-one-level\", i.e., within the global environment "
"in this case."
msgstr ""
"Pour les habitués du terminal Unix, le préfixe `..` devrait rappeler la "
"commande de \"remontée d'un niveau\", qui est analogue à ce qui se passe ici "
"-- le `..` demande à `data.table` de chercher la variable `select_cols` \"un "
"nivau au-dessus\",  c'est à  dire dans ce cas, dans l'envronnement global."

#: d.Rmd:block 94 (header)
msgid "-- Select columns named in a variable using `with = FALSE`"
msgstr ""
"-- Sélectionner les colonnes nommées dans une variable en utilisant `with = "
"FALSE`"

#: d.Rmd:block 96 (paragraph)
msgid ""
"The argument is named `with` after the R function `with()` because of similar "
"functionality. Suppose you have a `data.frame` `DF` and you'd like to subset "
"all rows where `x > 1`. In `base` R you can do the following:"
msgstr ""
"L'argument s'appelle `with` d'après la fonction R `with()` à cause de la "
"fonctionnalité similaire. Supposez que vous ayiez une `data.frame` `DF` et "
"que vous vouliez dissocier toutes les lignes où `x > 1`. Dans la `base` R "
"vous pouvez écrire :"

#: d.Rmd:block 98 (unordered list)
msgid ""
"Using `with()` in (2) allows using `DF`'s column `x` as if it were a variable."
msgstr ""
"Utiliser `with()` dans (2) permet d'utiliser la colonne `x` de `DF` comme "
"s'il s'agissait d'une variable."

#: d.Rmd:block 98 (unordered list)
msgid ""
"Hence, the argument name `with` in `data.table`. Setting `with = FALSE` "
"disables the ability to refer to columns as if they are variables, thereby "
"restoring the \"`data.frame` mode\"."
msgstr ""
"De là le nom d'argument `with` dans `data.table`. En définissant `with = "
"FALSE` on désactive la possibilité de référencer les colonnes comme s'il "
"s'agissait de variables, ce qui rétablit le mode \"`data.frame`\"."

#: d.Rmd:block 98 (unordered list)
msgid "We can also *deselect* columns using `-` or `!`. For example:"
msgstr ""
"Il est ausi possible de *désélectionner* des colonnes en utilisant `-` ou `!"
"`. Par exemple :"

#: d.Rmd:block 98 (unordered list)
msgid ""
"From `v1.9.5+`, we can also select by specifying start and end column names, "
"e.g., `year:day` to select the first three columns."
msgstr ""
"A partir de `v1.9.5+`, la sélection est aussi possible en fournissant le nom "
"des colonnes de début et de fin, par exemple `year:day` pour sélectionner les "
"trois premières colonnes."

#: d.Rmd:block 98 (unordered list)
msgid "This is particularly handy while working interactively."
msgstr "Ceci est très pratique lorsque vous travaillez de manière interactive."

#: d.Rmd:block 99 (paragraph)
msgid ""
"`with = TRUE` is the default in `data.table` because we can do much more by "
"allowing `j` to handle expressions - especially when combined with `by`, as "
"we'll see in a moment."
msgstr ""
"`with = TRUE` est la valeur par défaut dans `data.table` car nous pouvons "
"faire plus en permettant à `j` de gérer des expressions - particulièrement en "
"combinant avec `by`, comme nous le verrons dans un instant."

#: d.Rmd:block 100 (header)
msgid "2. Aggregations"
msgstr "2. Aggrégations"

#: d.Rmd:block 101 (paragraph)
msgid ""
"We've already seen `i` and `j` from `data.table`'s general form in the "
"previous section. In this section, we'll see how they can be combined "
"together with `by` to perform operations *by group*. Let's look at some "
"examples."
msgstr ""
"Nous avons déjà vu `i` et `j` dans la forme générale d'une `data.table` dans "
"la secton précédente. Dans cette section, nous allons voir comment ils "
"peuvent être combinés ensemble avec `by` pour réaliser des opérations *par "
"groupe*. Voyons quelques exemples."

#: d.Rmd:block 102 (header)
msgid "a) Grouping using `by`"
msgstr "a) Regrouper avec `by`"

#: d.Rmd:block 103 (header)
msgid ""
"-- How can we get the number of trips corresponding to each origin airport?"
msgstr "-- Comment obtenir le nombre de voyages au départ de chaque aéroport ?"

#: d.Rmd:block 105 (unordered list)
msgid ""
"We know `.N` [is a special variable](#special-N) that holds the number of "
"rows in the current group. Grouping by `origin` obtains the number of rows, `."
"N`, for each group."
msgstr ""
"Nous savons que `.N` [est une variable spéciale](#special-N) qui contient le "
"nombre de lignes du groupe actuel. Si on regroupe par `origin` on obtient le "
"nombre de lignes `.N`, pour chaque groupe."

#: d.Rmd:block 105 (unordered list)
msgid ""
"By doing `head(flights)` you can see that the origin airports occur in the "
"order *\"JFK\"*, *\"LGA\"*, and *\"EWR\"*. The original order of grouping "
"variables is preserved in the result. *This is important to keep in mind!*"
msgstr ""
"En écrivant `head(flights)` vous voyez que les aéroports de départ "
"apparaissent dans l'ordre *\"JFK\"*, *\"LGA\"*, et *\"EWR\"*. L'ordre "
"original de regroupement des variables est préservé dans le résultat. *C'est "
"important d'avoir cela à l'esprit !*"

#: d.Rmd:block 105 (unordered list)
msgid ""
"Since we did not provide a name for the column returned in `j`, it was named "
"`N` automatically by recognising the special symbol `.N`."
msgstr ""
"Comme nous n'avons pas fourni de nom pour la colonne renvoyée de `j`, elle a "
"été nommée `N` automatiquement car le symbole spécial `.N` a été reconnu."

#: d.Rmd:block 105 (unordered list)
msgid ""
"`by` also accepts a character vector of column names. This is particularly "
"useful for coding programmatically, e.g., designing a function with the "
"grouping columns (in the form of a `character` vector) as a function argument."
msgstr ""
"`by` accepte également un vecteur de caractères de noms de colonnes. C'est "
"particulièrement utile pour le logiciel, par exemple lorsque l'on définit une "
"fonction avec des colonnes de regroupement (sour la  forme d'un vecteur de "
"`character`) comme argument de fonction."

#: d.Rmd:block 105 (unordered list)
msgid ""
"When there's only one column or expression to refer to in `j` and `by`, we "
"can drop the `.()` notation. This is purely for convenience. We could instead "
"do:"
msgstr ""
"Quand on ne se réfère qu'à une colonne ou une expression dans `j` et `by`, on "
"peut omettre la notation `.()` . C'est une facilité. Nous aurions pu écrire à "
"la place :"

#: d.Rmd:block 105 (unordered list)
msgid "We'll use this convenient form wherever applicable hereafter."
msgstr ""
"Cette forme pratique sera ensuite utilisée par la suite là où nécessaire."

#: d.Rmd:block 106 (header)
msgid ""
"-- How can we calculate the number of trips for each origin airport for "
"carrier code `\"AA\"`? {#origin-.N}"
msgstr ""
"-- Comment calculer le nombre de voyages au départ de chaque aéroport pour le "
"transporteur ayant le code `\"AA\"`? {#origin-.N}"

#: d.Rmd:block 107 (paragraph)
msgid "The unique carrier code `\"AA\"` corresponds to *American Airlines Inc.*"
msgstr ""
"Le code unique de transporteur `\"AA\"` correspond à *American Airlines Inc.*"

#: d.Rmd:block 109 (unordered list)
msgid ""
"We first obtain the row indices for the expression `carrier == \"AA\"` from "
"`i`."
msgstr ""
"Nous obtenons d'abord les indices des lignes pour l'expression `carrier == "
"\"AA\"` à partir de `i`."

#: d.Rmd:block 109 (unordered list)
msgid ""
"Using those *row indices*, we obtain the number of rows while grouped by "
"`origin`. Once again no columns are actually materialised here, because the "
"`j-expression` does not require any columns to be actually subsetted and is "
"therefore fast and memory efficient."
msgstr ""
"En  utilisant ces *indices de lignes*, nous obtenons le nombre de lignes "
"groupées par `origin`. Une fois de plus, aucune colonne n'est actuellement "
"matérialisée ici, parce que la `j-expression` nécessite aucun tri de colonne "
"d'où la rapidité et l'efficacité mémoire."

#: d.Rmd:block 110 (header)
msgid ""
"-- How can we get the total number of trips for each `origin, dest` pair for "
"carrier code `\"AA\"`? {#origin-dest-.N}"
msgstr ""
"-- Comment obtenir le nombre total de voyages pour chaque paire `origin, "
"dest` du transporteur ayant pour code `\"AA\"`? {#origin-dest-.N}"

#: d.Rmd:block 112 (unordered list)
msgid ""
"`by` accepts multiple columns. We just provide all the columns by which to "
"group by. Note the use of `.()` again in `by` -- again, this is just "
"shorthand for `list()`, and `list()` can be used here as well. Again, we'll "
"stick with `.()` in this vignette."
msgstr ""
"`by` accepte plusieurs colonnes. Nous fournissons simplement toutes les "
"colonnes qui servent au groupement. Notez l'utilisation à nouveau de `.()` "
"dans `by` -- encore une fois, il s'agit d'un raccourci pour `list()`, mais "
"`list()` peut également être utilisé. A nouveau, nous garderons `.()` dans "
"cette this vignette."

#: d.Rmd:block 113 (header)
msgid ""
"-- How can we get the average arrival and departure delay for each `orig,"
"dest` pair for each month for carrier code `\"AA\"`? {#origin-dest-month}"
msgstr ""
"-- Comment obtenir les valeurs moyennes menselles du retard des arrivées et "
"des départs pour chaque paire `orig,dest` pour le transporteur ayant le code "
"`\"AA\"`? {#origin-dest-month}"

#: d.Rmd:block 115 (unordered list)
msgid ""
"Since we did not provide column names for the expressions in `j`, they were "
"automatically generated as `V1` and `V2`."
msgstr ""
"Comme nous n'avons pas fourni le nom des colonnes pour les expressions dans "
"`j`, ils ont été automatiquement générés en tant que `V1` et `V2`."

#: d.Rmd:block 115 (unordered list)
msgid ""
"Once again, note that the input order of grouping columns is preserved in the "
"result."
msgstr ""
"Une fois de plus, notez que l'ordre d'entrée du roupement des colonnes est "
"préservé dans le résultat."

#: d.Rmd:block 116 (paragraph)
msgid ""
"Now what if we would like to order the result by those grouping columns "
"`origin`, `dest` and `month`?"
msgstr ""
"Maintenant qu'adviendrait-il si nous voulions trier les résultats en groupant "
"les colonnes `origin`, `dest` et `month` ?"

#: d.Rmd:block 117 (header)
msgid "b) Sorted `by`: `keyby`"
msgstr "b) Tri `by` : `keyby`"

#: d.Rmd:block 118 (paragraph)
msgid ""
"`data.table` retaining the original order of groups is intentional and by "
"design. There are cases when preserving the original order is essential. But "
"at times we would like to automatically sort by the variables in our grouping."
msgstr ""
"`data.table` conserve l'ordre original des groupes; c'est intentionnel et "
"défini à la conception. Il existe des cas où conserver l'ordre original est "
"essentiel. Mais à certains moments, nous aimerions trier automatiquement par "
"variables dans notre regroupement."

#: d.Rmd:block 119 (header)
msgid "-- So how can we directly order by all the grouping variables?"
msgstr ""
"-- Donc comment pourrions-nous trier directement sur toutes les variables de "
"regroupement ?"

#: d.Rmd:block 121 (unordered list)
msgid ""
"All we did was change `by` to `keyby`. This automatically orders the result "
"by the grouping variables in increasing order. In fact, due to the internal "
"implementation of `by` first requiring a sort before recovering the original "
"table's order, `keyby` is typically faster than `by` because it doesn't "
"require this second step."
msgstr ""
"Tout ce que nous avons fait c'est de changer `by` en `keyby`. Ceci trie "
"automatiquement le résultat en fonction des variables de groupement, dans "
"l'ordre croissant. En fait, à cause de l'implémentation interne de `by` qui "
"demande d'abord un tri avant de récupérer l'ordre initial du tableau, `keyby` "
"est typiquement plus rapide que `by` car l ne nécessite pas cette seconde "
"étape."

#: d.Rmd:block 122 (paragraph)
msgid ""
"**Keys:** Actually `keyby` does a little more than *just ordering*. It also "
"*sets a key* after ordering by setting an `attribute` called `sorted`."
msgstr ""
"**Clés :** actuellement `keyby` en fait un peu plus que *simplement trier*. "
"Il *définit une clé* également après le tri en initialisant un `attribute` "
"appelé `sorted`."

#: d.Rmd:block 123 (paragraph)
msgid ""
"We'll learn more about `keys` in the *Keys and fast binary search based "
"subset* vignette; for now, all you have to know is that you can use `keyby` "
"to automatically order the result by the columns specified in `by`."
msgstr ""
"Nous en apprendrons plus au sujet des `clés` dans la vignette *Clés et sous-"
"ensembles basés sur la recherche binaire rapide*; pour l'instant, tout ce que "
"vous devez savoir est que vous pouvez utiliser `keyby` pour trier "
"automatiquement le résultat selon les colonnes spécifiées dans `by`."

#: d.Rmd:block 124 (header)
msgid "c) Chaining"
msgstr "c) Chaînage"

#: d.Rmd:block 125 (paragraph)
msgid ""
"Let's reconsider the task of [getting the total number of trips for each "
"`origin, dest` pair for carrier *\"AA\"*](#origin-dest-.N)."
msgstr ""
"Considérons la tâche consistant à [récupérer le nombre total de voyages pour "
"chaque couple `origin, dest` du transporteur *\"AA\"*](#origin-dest-.N)."

#: d.Rmd:block 127 (header)
msgid ""
"-- How can we order `ans` using the columns `origin` in ascending order, and "
"`dest` in descending order?"
msgstr ""
"-- Comment trier `ans` en utilisant la colonne `origin` en mode croissant, et "
"la colonne `dest` en mode décroissant ?"

#: d.Rmd:block 128 (paragraph)
msgid ""
"We can store the intermediate result in a variable, and then use "
"`order(origin, -dest)` on that variable. It seems fairly straightforward."
msgstr ""
"On peut stocker le résultat intermédiaire dans une variable, puis passer "
"`order(origin, -dest)` sur cette variable. Cela semble plus direct."

#: d.Rmd:block 130 (unordered list)
msgid ""
"Recall that we can use `-` on a `character` column in `order()` within the "
"frame of a `data.table`. This is possible due to `data.table`'s internal "
"query optimisation."
msgstr ""
"Souvenez-vous que nous pouvons utiliser `-` avec une colonne `character` dans "
"`order()` sur la structure d'une `data.table`. Ceci est possible grâce à "
"l'optimisation interne des requêtes dans `data.table` ."

#: d.Rmd:block 130 (unordered list)
msgid ""
"Also recall that `order(...)` with the frame of a `data.table` is "
"*automatically optimised* to use `data.table`'s internal fast radix order "
"`forder()` for speed."
msgstr ""
"Souvenez-vous aussi que `order(...)` avec la structure d'une `data.table` est "
"*optimisé automatiquement* pour utiliser l'ordre interne fast radix "
"`forder()` de `data.table` qui est très rapide."

#: d.Rmd:block 131 (paragraph)
msgid ""
"But this requires having to assign the intermediate result and then "
"overwriting that result. We can do one better and avoid this intermediate "
"assignment to a temporary variable altogether by *chaining* expressions."
msgstr ""
"Mais ceci nécessite d'avoir assigné le résultat intermédiaire et de réécrire "
"ce résultat. On peut faire mieux et éviter cette assignation intermédiaire à "
"une variable temporaire en *chaînant* les expressions ensemble."

#: d.Rmd:block 133 (unordered list)
msgid ""
"We can tack expressions one after another, *forming a chain* of operations, i."
"e., `DT[ ... ][ ... ][ ... ]`."
msgstr ""
"Il est possible de concaténer des expressions à la suite, de sorte à *former "
"une chaîne* d'opérations, comme par exemple, `DT[ ... ][ ... ][ ... ]`."

#: d.Rmd:block 133 (unordered list)
msgid "Or you can also chain them vertically:"
msgstr "Ou vous pouvez aussi les chaîner verticalement :"

#: d.Rmd:block 134 (header)
msgid "d) Expressions in `by`"
msgstr "d) Expressions de `by`"

#: d.Rmd:block 135 (header)
msgid "-- Can `by` accept *expressions* as well or does it just take columns?"
msgstr ""
"-- `by` accepte-t-il également *expressions*, ou simplement des colonnes ?"

#: d.Rmd:block 136 (paragraph)
msgid ""
"Yes it does. As an example, if we would like to find out how many flights "
"started late but arrived early (or on time), started and arrived late etc..."
msgstr ""
"Oui, il le fait. Par exemple, si nous avions voulu chercher combien de vols "
"sont partis en retard mais sont arrivés plus tôt (ou à l'heure), ou parts à "
"l'heure mais arrivés en retard, etc..."

#: d.Rmd:block 138 (unordered list)
msgid ""
"The last row corresponds to `dep_delay > 0 = TRUE` and `arr_delay > 0 = "
"FALSE`. We can see that `r flights[!is.na(arr_delay) & !is.na(dep_delay), ."
"N, .(dep_delay>0, arr_delay>0)][, N[4L]]` flights started late but arrived "
"early (or on time)."
msgstr ""
"La dernière ligne correspond à `dep_delay > 0 = TRUE` et `arr_delay > 0 = "
"FALSE`. Nous voyons que `r flights[!is.na(arr_delay) & !is.na(dep_delay), ."
"N, .(dep_delay>0, arr_delay>0)][, N[4L]]` vols sont partis en retard mais "
"sont arrivés plus tôt (ou à l'heure)."

#: d.Rmd:block 138 (unordered list)
msgid ""
"Note that we did not provide any names to `by-expression`. Therefore, names "
"have been automatically assigned in the result. As with `j`, you can name "
"these expressions as you would for elements of any `list`, like for e.g. "
"`DT[, .N, .(dep_delayed = dep_delay>0, arr_delayed = arr_delay>0)]`."
msgstr ""
"Notez que nous n'avons fourni aucun nom à `by-expression`. C'est pourquoi des "
"noms ont été assignés automatiquement dans le résultat. Comme avec `j`, vous "
"pouvez nommer ces expressions comme vous le feriez pour des éléments de "
"n'importe quelle `list`, comme par exemple `DT[, .N, .(dep_delayed = "
"dep_delay>0, arr_delayed = arr_delay>0)]`."

#: d.Rmd:block 138 (unordered list)
msgid ""
"You can provide other columns along with expressions, for example: `DT[, .N, "
"by = .(a, b>0)]`."
msgstr ""
"Vous pouvez fournir d'autres colonnes avec des expressions, par exemple: "
"`DT[, .N, by = .(a, b>0)]`."

#: d.Rmd:block 139 (header)
msgid "e) Multiple columns in `j` - `.SD`"
msgstr "e) Colonnes multiples dans `j` - `.SD`"

#: d.Rmd:block 140 (header)
msgid "-- Do we have to compute `mean()` for each column individually?"
msgstr "-- Faut-il calculer `mean()` pour chaque colonne individuellement ?"

#: d.Rmd:block 141 (paragraph)
msgid ""
"It is of course not practical to have to type `mean(myCol)` for every column "
"one by one. What if you had 100 columns to average `mean()`?"
msgstr ""
"Bien sûr il n'est pas pratique de devoir entrer `mean(myCol)` pour chaque "
"colonne, une par une. Et s'il fallait faire la moyenne `mean()` sur 100 "
"colonnes ?"

#: d.Rmd:block 142 (paragraph)
msgid ""
"How can we do this efficiently and concisely? To get there, refresh on [this "
"tip](#tip-1) - *\"As long as the `j`-expression returns a `list`, each "
"element of the `list` will be converted to a column in the resulting `data."
"table`\"*. If we can refer to the *data subset for each group* as a variable "
"*while grouping*, we can then loop through all the columns of that variable "
"using the already- or soon-to-be-familiar base function `lapply()`. No new "
"names to learn specific to `data.table`."
msgstr ""
"Comment faire cela de manière efficace et concise ?  Pour y arriver, relisons "
"[ce conseil](#tip-1) - *\"Tant que la `j`-expression renvoie une `list`, "
"chaque élément de cette `list` sera converti en une colonne de la `data."
"table` résultat\"*. Si nous pouvons adresser le *sous-ensemble de données de "
"chaque groupe* comme une variable *de regroupement*, nous pourrons ensuite "
"boucler sur toutes les colonnes de cette variables en utilisant la fonction "
"de base familière (ou en passe de le devenir) `lapply()`. Il n'y a pas de "
"nouveaux noms à apprendre particuliers pour `data.table`."

#: d.Rmd:block 143 (header)
msgid "Special symbol `.SD`: {#special-SD}"
msgstr "Symbole spécial `.SD`: {#special-SD}"

#: d.Rmd:block 144 (paragraph)
msgid ""
"`data.table` provides a *special* symbol called `.SD`. It stands for "
"**S**ubset of **D**ata. It by itself is a `data.table` that holds the data "
"for *the current group* defined using `by`."
msgstr ""
"`data.table` fournit le symbole *spécial* `.SD`. Il tire son nom de **S**ous-"
"ensemble de **D**onnées. C'est une `data.table` qui contient les données du "
"*groupe actuel* tel qu'il a été défini avec `by`."

#: d.Rmd:block 145 (paragraph)
msgid ""
"Recall that a `data.table` is internally a `list` as well with all its "
"columns of equal length."
msgstr ""
"Souvenez-vous qu'une `data.table` est représentée en interne comme une `list` "
"dont toutes les colonnes ont la même longueur."

#: d.Rmd:block 146 (paragraph)
msgid ""
"Let's use the [`data.table` `DT` from before](#what-is-datatable-1a) to get a "
"glimpse of what `.SD` looks like."
msgstr ""
"Utilisons la [`data.table` `DT` précédente](#what-is-datatable-1a) pour avoir "
"un aperçu de ce à quoi ressemble `.SD` ."

#: d.Rmd:block 148 (unordered list)
msgid "`.SD` contains all the columns *except the grouping columns* by default."
msgstr ""
"`.SD` contient pas défaut toutes les colonnes *sauf les colonnes regroupées*."

#: d.Rmd:block 148 (unordered list)
msgid ""
"It is also generated by preserving the original order - data corresponding to "
"`ID = \"b\"`, then `ID = \"a\"`, and then `ID = \"c\"`."
msgstr ""
"La génération se fait aussi en préservant l'ordre original - données "
"correspondant à `ID = \"b\"`, puis `ID = \"a\"`, et enfin `ID = \"c\"`."

#: d.Rmd:block 149 (paragraph)
msgid ""
"To compute on (multiple) columns, we can then simply use the base R function "
"`lapply()`."
msgstr ""
"Pour calculer sur uneou plusieurs colonnes vous pouvez utiliser simplement la "
"fonction de base R `lapply()`."

#: d.Rmd:block 151 (unordered list)
msgid ""
"`.SD` holds the rows corresponding to columns `a`, `b` and `c` for that "
"group. We compute the `mean()` on each of these columns using the already-"
"familiar base function `lapply()`."
msgstr ""
"`.SD` contient les lignes correspondant aux colonnnes `a`, `b` et `c` pour ce "
"groupe. Nous calculons la `mean()` sur chacune de ces colonnes en utilisant "
"la fonction de base déjà familière `lapply()`."

#: d.Rmd:block 151 (unordered list)
msgid ""
"Each group returns a list of three elements containing the mean value which "
"will become the columns of the resulting `data.table`."
msgstr ""
"Chaque groupe renvoie une liste de trois éléments qui contiennent la valeur "
"moyenne qui deviendront les colonnes du résultat `data.table`."

#: d.Rmd:block 151 (unordered list)
msgid ""
"Since `lapply()` returns a `list`, so there is no need to wrap it with an "
"additional `.()` (if necessary, refer to [this tip](#tip-1))."
msgstr ""
"Il n'est pas utile d'encadrer `lapply()` avec `.()` car il renvoie déjà une "
"`list` (si nécessaire voir [ce conseil](#tip-1))."

#: d.Rmd:block 152 (paragraph)
msgid ""
"We are almost there. There is one little thing left to address. In our "
"`flights` `data.table`, we only wanted to calculate the `mean()` of the two "
"columns `arr_delay` and `dep_delay`. But `.SD` would contain all the columns "
"other than the grouping variables by default."
msgstr ""
"Nous y sommes presque. Il reste encore une petite chose à régler. Dans notre "
"`data.table` `flights` , nous avons voulu calculer seulement la `mean()` des "
"deux colonnes `arr_delay` et `dep_delay`. Mais `.SD` contiendrait par défaut "
"toutes les colonnes autres que les variables de groupement."

#: d.Rmd:block 153 (header)
msgid ""
"-- How can we specify just the columns we would like to compute the `mean()` "
"on?"
msgstr ""
"-- Comment spécifier uniquement les colonnes sur lesquelles nous voulons "
"appliquer `mean()` ?"

#: d.Rmd:block 154 (header)
msgid ".SDcols"
msgstr ".SDcols"

#: d.Rmd:block 155 (paragraph)
msgid ""
"Using the argument `.SDcols`. It accepts either column names or column "
"indices. For example, `.SDcols = c(\"arr_delay\", \"dep_delay\")` ensures "
"that `.SD` contains only these two columns for each group."
msgstr ""
"En utilisant l'argument `.SDcols`. Il accepte soit des noms soit des indices "
"de colonnes. Par exemple, `.SDcols = c(\"arr_delay\", \"dep_delay\")` permet "
"que `.SD` ne comporte que ces deux colonnes pour chaque groupe."

#: d.Rmd:block 156 (paragraph)
msgid ""
"Similar to [part g)](#refer_j), you can also specify the columns to remove "
"instead of columns to keep using `-` or `!`. Additionally, you can select "
"consecutive columns as `colA:colB` and deselect them as `!(colA:colB)` or `-"
"(colA:colB)`."
msgstr ""
"De la même manière que [part g)](#refer_j), vous pouvez également spécifier "
"les colonnes à supprimer au lieu des colonnes à garder en utilisant le `-` ou "
"`!`. De plus, vous pouvez sélectionner des colonnes consécutives avec `colA:"
"colB` et les désélectionner avec `!(colA:colB)` ou `-(colA:colB)`."

#: d.Rmd:block 157 (paragraph)
msgid ""
"Now let us try to use `.SD` along with `.SDcols` to get the `mean()` of "
"`arr_delay` and `dep_delay` columns grouped by `origin`, `dest` and `month`."
msgstr ""
"Maintenant essayons d'utiliser `.SD` avec `.SDcols` pour obtenir la moyenne "
"`mean()` des colonnes `arr_delay` et `dep_delay` groupées par `origin`, "
"`dest` et `month`."

#: d.Rmd:block 159 (header)
msgid "f) Subset `.SD` for each group:"
msgstr "f) Extraire `.SD` pour chaque groupe :"

#: d.Rmd:block 160 (header)
msgid "-- How can we return the first two rows for each `month`?"
msgstr "-- Comment renvoyer les deux premières lignes de chque 'month`?"

#: d.Rmd:block 162 (unordered list)
msgid ""
"`.SD` is a `data.table` that holds all the rows for *that group*. We simply "
"subset the first two rows as we have seen [here](#subset-rows-integer) "
"already."
msgstr ""
"`.SD` est une `data.table` qui contient toutes les lignes pour *ce groupe*. "
"Nous dissocions simplement les deux premières lignes comme nous l'avons déjà "
"vu [ici](#subset-rows-integer)."

#: d.Rmd:block 162 (unordered list)
msgid ""
"For each group, `head(.SD, 2)` returns the first two rows as a `data.table`, "
"which is also a `list`, so we do not have to wrap it with `.()`."
msgstr ""
"Pour chaque groupe, `head(.SD, 2)` renvoie les deux premières lignes en tant "
"que `data.table`, qui est aussi une `list`, il n'est donc pas nécessaire de "
"l'encadrer avec `.()`."

#: d.Rmd:block 163 (header)
msgid "g) Why keep `j` so flexible?"
msgstr "g) Pourquoi garder `j` si flexible ?"

#: d.Rmd:block 164 (paragraph)
msgid ""
"So that we have a consistent syntax and keep using already existing (and "
"familiar) base functions instead of learning new functions. To illustrate, "
"let us use the `data.table` `DT` that we created at the very beginning under "
"the section [What is a data.table?](#what-is-datatable-1a)."
msgstr ""
"Ainsi nous avons une syntaxe cohérente et continuons l'utilisation de "
"fonctions de base déja existantes (et familières) au lieu d'apprendre de "
"nouvelles fonctions. Pour illustrer cela utilisons la `data.table` `DT` que "
"nous avons créée tout au début dans la section [Qu'est-ce qu'une data.table ?]"
"(#what-is-datatable-1a)."

#: d.Rmd:block 165 (header)
msgid "-- How can we concatenate columns `a` and `b` for each group in `ID`?"
msgstr ""
"-- Comment concaténer les colonnes `a` et `b` pour chaque groupe de `ID` ?"

#: d.Rmd:block 167 (unordered list)
msgid ""
"That's it. There is no special syntax required. All we need to know is the "
"base function `c()` which concatenates vectors and [the tip from before]"
"(#tip-1)."
msgstr ""
"C'est tout. Aucune syntaxe particulière n'est requise. Tout ce dont nous "
"avons besoin de connaître est la fonction de base `c()` qui concatène les "
"vecteurs et [la recommendation précédente](#tip-1)."

#: d.Rmd:block 168 (header)
msgid ""
"-- What if we would like to have all the values of column `a` and `b` "
"concatenated, but returned as a list column?"
msgstr ""
"-- Que se passerait-il si nous voulions avoir toutes les valeurs des colonnes "
"`a` et `b` concaténées, mais renvoyées en tant que colonne de liste ?"

#: d.Rmd:block 170 (unordered list)
msgid ""
"Here, we first concatenate the values with `c(a,b)` for each group, and wrap "
"that with `list()`. So for each group, we return a list of all concatenated "
"values."
msgstr ""
"Ici, nous concaténons d'abord les valeurs avec `c(a,b)` pour chaque groupe, "
"et que nous encadrons avec `list()`. Donc pour chaque groupe, nous renvoyons "
"une liste de toutes les valeurs concaténées."

#: d.Rmd:block 170 (unordered list)
msgid ""
"Note that those commas are for display only. A list column can contain any "
"object in each cell, and in this example, each cell is itself a vector and "
"some cells contain longer vectors than others."
msgstr ""
"Notez que ces virgules ne servent qu'à l'affichage. Une colonne qui est une "
"liste peut contenir dans chaque cellule n'importe quel objet, et dans cet "
"exemple chaque cellule est elle-même un vecteur et certaines cellules "
"contiennent des vecteurs plus longs que d'autres."

#: d.Rmd:block 171 (paragraph)
msgid ""
"Once you start internalising usage in `j`, you will realise how powerful the "
"syntax can be. A very useful way to understand it is by playing around, with "
"the help of `print()`."
msgstr ""
"Une fois que vous commencerez à utiliser `j`, vous découvrirez la puissance "
"de sa syntaxe. Une manière pratique de l'aborder est de la tester en "
"utilisant `print()`."

#: d.Rmd:block 172 (paragraph)
msgid "For example:"
msgstr "Par exemple :"

#: d.Rmd:block 174 (paragraph)
msgid ""
"In (1), for each group, a vector is returned, with length = 6,4,2 here. "
"However, (2) returns a list of length 1 for each group, with its first "
"element holding vectors of length 6,4,2. Therefore, (1) results in a length "
"of `6+4+2 =`r 6+4+2``, whereas (2) returns `1+1+1=`r 1+1+1``."
msgstr ""
"Dans (1), pour chaque groupe, un vecteur est renvoyé, de longueur = 6,4,2 "
"ici. Néanmoins, (2) renvoie une liste de longueur 1 pour chaque groupe, dont "
"chaque premier élément contient des vecteurs de longueur 6,4,2. C'est "
"pourquoi, (1) a pour longueur totale `6+4+2 =`r 6+4+2``, alors que (2) "
"renvoie `1+1+1=`r 1+1+1``."

#: d.Rmd:block 175 (header)
msgid "Summary"
msgstr "Résumé"

#: d.Rmd:block 176 (paragraph)
msgid "The general form of `data.table` syntax is:"
msgstr "La forme générale de la syntaxe de `data.table` est :"

#: d.Rmd:block 178 (paragraph)
msgid "We have seen so far that,"
msgstr "Jusqu'ici nous avons vu que,"

#: d.Rmd:block 179 (header)
msgid "Using `i`:"
msgstr "En utilisant 'i' :"

#: d.Rmd:block 180 (unordered list)
msgid ""
"We can subset rows similar to a `data.frame`- except you don't have to use "
"`DT$` repetitively since columns within the frame of a `data.table` are seen "
"as if they are *variables*."
msgstr ""
"On peut extraire des lignes de manière similaire à une `data.frame`- sauf que "
"vous ne devez pas utiliser `DT$` de manière répétitive car les colonnes dans "
"la structure d'une `data.table` sont vues comme s'il s'agissait de "
"*variables*."

#: d.Rmd:block 180 (unordered list)
msgid ""
"We can also sort a `data.table` using `order()`, which internally uses data."
"table's fast order for better performance."
msgstr ""
"Nous pouvons aussi trier une `data.table` avec `order()`, qui utilise en "
"interne l'ordonnancement rapide de data.table pour de meilleures performances."

#: d.Rmd:block 181 (paragraph)
msgid ""
"We can do much more in `i` by keying a `data.table`, which allows for blazing "
"fast subsets and joins. We will see this in the *\"Keys and fast binary "
"search based subsets\"* and *\"Joins and rolling joins\"* vignette."
msgstr ""
"Nous pouvons faire beaucoup plus dans `i` en créant une `data.table` avec "
"clés, ce qui permet de réaliser rapidement les sous-ensembles et les "
"jointures. Nous verrons cela dans les vignettes *\"Clés et sous-ensembles "
"basés sur la recherche binaire rapide\"* et *\"Jointures et jointures liées "
"au temps\"*."

#: d.Rmd:block 182 (header)
msgid "Using `j`:"
msgstr "En utilisant 'j' :"

#: d.Rmd:block 183 (ordered list)
msgid "Select columns the `data.table` way: `DT[, .(colA, colB)]`."
msgstr ""
"Sélectionner les colonnes à la manière `data.frame` : `DT[, c(\"colA\", "
"\"colB\")]`."

#: d.Rmd:block 183 (ordered list)
msgid "Select columns the `data.frame` way: `DT[, c(\"colA\", \"colB\")]`."
msgstr ""
"Sélectionner les colonnes à la manière `data.frame` : `DT[, c(\"colA\", "
"\"colB\")]`."

#: d.Rmd:block 183 (ordered list)
msgid "Compute on columns: `DT[, .(sum(colA), mean(colB))]`."
msgstr "Evaluer sur les colonnes : 'DT[, .(sum(colA), mean(colB))]'."

#: d.Rmd:block 183 (ordered list)
msgid "Provide names if necessary: `DT[, .(sA =sum(colA), mB = mean(colB))]`."
msgstr ""
"Fournir les noms si nécessaire : 'DT[, .(sA =sum(colA), mB = mean(colB))]'."

#: d.Rmd:block 183 (ordered list)
msgid "Combine with `i`: `DT[colA > value, sum(colB)]`."
msgstr "Combiner avec 'i' : 'DT[colA > value, sum(colB)]'."

#: d.Rmd:block 184 (header)
msgid "Using `by`:"
msgstr "En utilisant 'by' :"

#: d.Rmd:block 185 (unordered list)
msgid ""
"Using `by`, we can group by columns by specifying a *list of columns* or a "
"*character vector of column names* or even *expressions*. The flexibility of "
"`j`, combined with `by` and `i`, makes for a very powerful syntax."
msgstr ""
"Avec `by`, nous pouvons regrouper par colonnes en spécifiant une *liste de "
"colonnes* ou un *vecteur de caractères comportant le nom des colonnes* ou "
"même des *expressions*. La flexibilité de `j`, combinée avec `by` et `i`, "
"contribuent à obtenir une syntaxe très puissante."

#: d.Rmd:block 185 (unordered list)
msgid "`by` can handle multiple columns and also *expressions*."
msgstr "`by` peut gérer plusieurs colonnes et aussi des *expressions*."

#: d.Rmd:block 185 (unordered list)
msgid ""
"We can `keyby` grouping columns to automatically sort the grouped result."
msgstr ""
"Vous pouvez grouper les colonnes avec `keyby` pour trier automatiquement les "
"résultats groupés."

#: d.Rmd:block 185 (unordered list)
msgid ""
"We can use `.SD` and `.SDcols` in `j` to operate on multiple columns using "
"already familiar base functions. Here are some examples:"
msgstr ""
"Nous pouvons utiliser `.SD` et `.SDcols` dans `j` pour opérer sur plusieurs "
"colonnes en reprenant les fonctions de base déjà familières. Voici quelques "
"exemples :"

#: d.Rmd:block 185 (unordered list)
msgid ""
"`DT[, lapply(.SD, fun), by = ..., .SDcols = ...]` - applies `fun` to all "
"columns specified in `.SDcols` while grouping by the columns specified in "
"`by`."
msgstr ""
"'DT[, lapply(.SD, fun), by = ..., .SDcols = ...]' - applique 'fun' à toutes "
"les colonnes spécifiées dans '.SDcols' en les regroupant selon les colonnes "
"spécifiées dans 'by'."

#: d.Rmd:block 185 (unordered list)
msgid ""
"`DT[, head(.SD, 2), by = ...]` - return the first two rows for each group."
msgstr ""
"'DT[, head(.SD, 2), by = ...]' - renvoie les deux premières lignes de chaque "
"groupe."

#: d.Rmd:block 185 (unordered list)
msgid ""
"`DT[col > val, head(.SD, 1), by = ...]` - combine `i` along with `j` and `by`."
msgstr "'DT[col > val, head(.SD, 1), by = ...]' - combine 'i' avec 'j' et 'by'."

#: d.Rmd:block 186 (header)
msgid "And remember the tip:"
msgstr "Et souvenez-vous du conseil :"

#: d.Rmd:block 187 (paragraph)
msgid ""
"As long as `j` returns a `list`, each element of the list will become a "
"column in the resulting `data.table`."
msgstr ""
"Tant que 'j renvoie une 'liste', chaque élément de la liste va devenir une "
"colonne de la 'data.table' résultante."

#: d.Rmd:block 188 (paragraph)
msgid ""
"We will see how to *add/update/delete* columns *by reference* and how to "
"combine them with `i` and `by` in the next vignette."
msgstr ""
"Nous verrons dans la vignette suivante comment *ajouter / mettre à jour / "
"supprimer* des colonnes *par référence* et comment les combiner avec 'i' et "
"'by' ."

#: fr/datatable-intro.Rmd.tmp:block 1 (code)
msgid ""
"title: \"Introduction to data.table\"\n"
"date: \"`r Sys.Date()`\"\n"
"output:\n"
"  markdown::html_format\n"
"vignette: >\n"
"  %\\VignetteIndexEntry{Introduction to data.table}\n"
"  %\\VignetteEngine{knitr::knitr}\n"
"  \\usepackage[utf8]{inputenc}\n"
msgstr ""
"title: \"Introduction à data.table\"\n"
"date: \"`r Sys.Date()`\"\n"
"output:\n"
"  markdown::html_format\n"
"vignette: >\n"
"  %\\VignetteIndexEntry{Introduction à data.table}\n"
"  %\\VignetteEngine{knitr::knitr}\n"
"  \\usepackage[utf8]{inputenc}\n"

#: fr/datatable-intro.Rmd.tmp:block 2 (code)
msgid ""
"# Chunk args: r, echo = FALSE, message = FALSE\n"
"require(data.table)\n"
"knitr::opts_chunk$set(\n"
"  comment = \"#\",\n"
"    error = FALSE,\n"
"     tidy = FALSE,\n"
"    cache = FALSE,\n"
" collapse = TRUE\n"
")\n"
".old.th = setDTthreads(1)\n"
msgstr ""
"# Chunk args: r, echo = FALSE, message = FALSE\n"
"require(data.table)\n"
"knitr::opts_chunk$set(\n"
"  comment = \"#\",\n"
"    error = FALSE,\n"
"     tidy = FALSE,\n"
"    cache = FALSE,\n"
" collapse = TRUE\n"
")\n"
".old.th = setDTthreads(1)\n"

#: fr/datatable-intro.Rmd.tmp:block 11 (code)
msgid ""
"# Chunk args: r echo = FALSE\n"
"options(width = 100L)\n"
msgstr ""
"# Chunk args: r echo = FALSE\n"
"options(width = 100L)\n"

#: fr/datatable-intro.Rmd.tmp:block 12 (code)
msgid ""
"input <- if (file.exists(\"flights14.csv\")) {\n"
"   \"flights14.csv\"\n"
"} else {\n"
"  \"https://raw.githubusercontent.com/Rdatatable/data.table/master/vignettes/"
"flights14.csv\"\n"
"}\n"
"flights <- fread(input)\n"
"flights\n"
"dim(flights)\n"
msgstr ""
"input <- if (file.exists(\"../flights14.csv\")) {\n"
"   \"../flights14.csv\"\n"
"} else {\n"
"  \"https://raw.githubusercontent.com/Rdatatable/data.table/master/vignettes/"
"flights14.csv\"\n"
"}\n"
"flights <- fread(input)\n"
"flights\n"
"dim(flights)\n"

#: fr/datatable-intro.Rmd.tmp:block 20 (code)
msgid ""
"DT = data.table(\n"
"  ID = c(\"b\",\"b\",\"b\",\"a\",\"a\",\"c\"),\n"
"  a = 1:6,\n"
"  b = 7:12,\n"
"  c = 13:18\n"
")\n"
"DT\n"
"class(DT$ID)\n"
msgstr ""
"DT = data.table(\n"
"  ID = c(\"b\",\"b\",\"b\",\"a\",\"a\",\"c\"),\n"
"  a = 1:6,\n"
"  b = 7:12,\n"
"  c = 13:18\n"
")\n"
"DT\n"
"class(DT$ID)\n"

#: fr/datatable-intro.Rmd.tmp:block 23 (unordered list)
msgid "getOption(\"datatable.print.nrows\")\n"
msgstr "getOption(\"datatable.print.nrows\")\n"

#: fr/datatable-intro.Rmd.tmp:block 26 (code)
msgid ""
"# Chunk args: r eval = FALSE\n"
"DT[i, j, by]\n"
"\n"
"##   R:                 i                 j        by\n"
"## SQL:  where | order by   select | update  group by\n"
msgstr ""
"# Chunk args: r eval = FALSE\n"
"DT[i, j, by]\n"
"\n"
"##   R:                 i                 j        by\n"
"## SQL:  where | order by   select | update  group by\n"

#: fr/datatable-intro.Rmd.tmp:block 33 (code)
msgid ""
"ans <- flights[origin == \"JFK\" & month == 6L]\n"
"head(ans)\n"
msgstr ""
"ans <- flights[origin == \"JFK\" & month == 6L]\n"
"head(ans)\n"

#: fr/datatable-intro.Rmd.tmp:block 36 (code)
msgid ""
"ans <- flights[1:2]\n"
"ans\n"
msgstr ""
"ans <- flights[1:2]\n"
"ans\n"

#: fr/datatable-intro.Rmd.tmp:block 40 (code)
msgid ""
"ans <- flights[order(origin, -dest)]\n"
"head(ans)\n"
msgstr ""
"ans <- flights[order(origin, -dest)]\n"
"head(ans)\n"

#: fr/datatable-intro.Rmd.tmp:block 46 (code)
msgid ""
"ans <- flights[, arr_delay]\n"
"head(ans)\n"
msgstr ""
"ans <- flights[, arr_delay]\n"
"head(ans)\n"

#: fr/datatable-intro.Rmd.tmp:block 49 (code)
msgid ""
"ans <- flights[, list(arr_delay)]\n"
"head(ans)\n"
msgstr ""
"ans <- flights[, list(arr_delay)]\n"
"head(ans)\n"

#: fr/datatable-intro.Rmd.tmp:block 55 (code)
msgid ""
"ans <- flights[, .(arr_delay, dep_delay)]\n"
"head(ans)\n"
"\n"
"## alternatively\n"
"# ans <- flights[, list(arr_delay, dep_delay)]\n"
msgstr ""
"ans <- flights[, .(arr_delay, dep_delay)]\n"
"head(ans)\n"
"\n"
"## forme alternative\n"
"# ans <- flights[, list(arr_delay, dep_delay)]\n"

#: fr/datatable-intro.Rmd.tmp:block 59 (code)
msgid ""
"ans <- flights[, .(delay_arr = arr_delay, delay_dep = dep_delay)]\n"
"head(ans)\n"
msgstr ""
"ans <- flights[, .(delay_arr = arr_delay, delay_dep = dep_delay)]\n"
"head(ans)\n"

#: fr/datatable-intro.Rmd.tmp:block 62 (code)
msgid ""
"ans <- flights[, sum( (arr_delay + dep_delay) < 0 )]\n"
"ans\n"
msgstr ""
"ans <- flights[, sum( (arr_delay + dep_delay) < 0 )]\n"
"ans\n"

#: fr/datatable-intro.Rmd.tmp:block 67 (code)
msgid ""
"ans <- flights[origin == \"JFK\" & month == 6L,\n"
"               .(m_arr = mean(arr_delay), m_dep = mean(dep_delay))]\n"
"ans\n"
msgstr ""
"ans <- flights[origin == \"JFK\" & month == 6L,\n"
"               .(m_arr = mean(arr_delay), m_dep = mean(dep_delay))]\n"
"ans\n"

#: fr/datatable-intro.Rmd.tmp:block 71 (code)
msgid ""
"ans <- flights[origin == \"JFK\" & month == 6L, length(dest)]\n"
"ans\n"
msgstr ""
"ans <- flights[origin == \"JFK\" & month == 6L, length(dest)]\n"
"ans\n"

#: fr/datatable-intro.Rmd.tmp:block 77 (code)
msgid "setkeyv(flights, \"origin\")\n"
msgstr "setkeyv(flights, \"origin\")\n"

#: fr/datatable-intro.Rmd.tmp:block 78 (unordered list)
msgid ""
"flights[\"XYZ\"]\n"
"# Returns:\n"
"#    origin year month day dep_time sched_dep_time dep_delay arr_time "
"sched_arr_time arr_delay carrier flight tailnum ...\n"
"# 1:    XYZ   NA    NA  NA       NA             NA        NA       "
"NA             NA        NA      NA     NA      NA ...\n"
msgstr ""
"flights[\"XYZ\"]\n"
"# Retourne:\n"
"#    origin year month day dep_time sched_dep_time dep_delay arr_time "
"sched_arr_time arr_delay carrier flight tailnum ...\n"
"# 1:    XYZ   NA    NA  NA       NA             NA        NA       "
"NA             NA        NA      NA     NA      NA ...\n"

#: fr/datatable-intro.Rmd.tmp:block 78 (unordered list)
msgid ""
"  flights[origin == \"XYZ\"]\n"
"# Returns:\n"
"# Empty data.table (0 rows and 19 cols): year,month,day,dep_time,"
"sched_dep_time,dep_delay,arr_time,sched_arr_time,arr_delay,...\n"
msgstr ""
"  flights[origin == \"XYZ\"]\n"
"# Retourne:\n"
"# Empty data.table (0 rows and 19 cols): year,month,day,dep_time,"
"sched_dep_time,dep_delay,arr_time,sched_arr_time,arr_delay,...\n"

#: fr/datatable-intro.Rmd.tmp:block 78 (unordered list)
msgid ""
"flights[\"XYZ\", nomatch=NULL]\n"
"# Returns:\n"
"# Empty data.table (0 rows and 19 cols): year,month,day,dep_time,"
"sched_dep_time,dep_delay,arr_time,sched_arr_time,arr_delay,...\n"
msgstr ""
"flights[\"XYZ\", nomatch=NULL]\n"
"# Retourne:\n"
"# Empty data.table (0 rows and 19 cols): year,month,day,dep_time,"
"sched_dep_time,dep_delay,arr_time,sched_arr_time,arr_delay,...\n"

#: fr/datatable-intro.Rmd.tmp:block 83 (code)
msgid ""
"ans <- flights[origin == \"JFK\" & month == 6L, .N]\n"
"ans\n"
msgstr ""
"ans <- flights[origin == \"JFK\" & month == 6L, .N]\n"
"ans\n"

#: fr/datatable-intro.Rmd.tmp:block 89 (code)
msgid ""
"# Chunk args: r j_cols_no_with\n"
"ans <- flights[, c(\"arr_delay\", \"dep_delay\")]\n"
"head(ans)\n"
msgstr ""
"# Chunk args: r j_cols_no_with\n"
"ans <- flights[, c(\"arr_delay\", \"dep_delay\")]\n"
"head(ans)\n"

#: fr/datatable-intro.Rmd.tmp:block 92 (code)
msgid ""
"# Chunk args: r j_cols_dot_prefix\n"
"select_cols = c(\"arr_delay\", \"dep_delay\")\n"
"flights[ , ..select_cols]\n"
msgstr ""
"# Chunk args: r j_cols_dot_prefix\n"
"select_cols = c(\"arr_delay\", \"dep_delay\")\n"
"flights[ , ..select_cols]\n"

#: fr/datatable-intro.Rmd.tmp:block 95 (code)
msgid ""
"# Chunk args: r j_cols_with\n"
"flights[ , select_cols, with = FALSE]\n"
msgstr ""
"# Chunk args: r j_cols_with\n"
"flights[ , select_cols, with = FALSE]\n"

#: fr/datatable-intro.Rmd.tmp:block 97 (code)
msgid ""
"DF = data.frame(x = c(1,1,1,2,2,3,3,3), y = 1:8)\n"
"\n"
"## (1) normal way\n"
"DF[DF$x > 1, ] # data.frame needs that ',' as well\n"
"\n"
"## (2) using with\n"
"DF[with(DF, x > 1), ]\n"
msgstr ""
"DF = data.frame(x = c(1,1,1,2,2,3,3,3), y = 1:8)\n"
"\n"
"## (1) méthode classique\n"
"DF[DF$x > 1, ] # data.frame needs that ',' as well\n"
"\n"
"## (2) en utilisant with\n"
"DF[with(DF, x > 1), ]\n"

#: fr/datatable-intro.Rmd.tmp:block 104 (code)
msgid ""
"ans <- flights[, .(.N), by = .(origin)]\n"
"ans\n"
"\n"
"## or equivalently using a character vector in 'by'\n"
"# ans <- flights[, .(.N), by = \"origin\"]\n"
msgstr ""
"ans <- flights[, .(.N), by = .(origin)]\n"
"ans\n"
"\n"
"## ou résultat identique en utilisant un vecteur de chaînes de caractères "
"dans 'by'\n"
"# ans <- flights[, .(.N), by = \"origin\"]\n"

#: fr/datatable-intro.Rmd.tmp:block 105 (unordered list)
msgid ""
"ans <- flights[, .N, by = origin]\n"
"ans\n"
msgstr ""
"ans <- flights[, .N, by = origin]\n"
"ans\n"

#: fr/datatable-intro.Rmd.tmp:block 108 (code)
msgid ""
"ans <- flights[carrier == \"AA\", .N, by = origin]\n"
"ans\n"
msgstr ""
"ans <- flights[carrier == \"AA\", .N, by = origin]\n"
"ans\n"

#: fr/datatable-intro.Rmd.tmp:block 111 (code)
msgid ""
"ans <- flights[carrier == \"AA\", .N, by = .(origin, dest)]\n"
"head(ans)\n"
"\n"
"## or equivalently using a character vector in 'by'\n"
"# ans <- flights[carrier == \"AA\", .N, by = c(\"origin\", \"dest\")]\n"
msgstr ""
"ans <- flights[carrier == \"AA\", .N, by = .(origin, dest)]\n"
"head(ans)\n"
"\n"
"## ou résultat identique en utilisant une chaîne de caractères dans 'by'\n"
"# ans <- flights[carrier == \"AA\", .N, by = c(\"origin\", \"dest\")]\n"

#: fr/datatable-intro.Rmd.tmp:block 114 (code)
msgid ""
"ans <- flights[carrier == \"AA\",\n"
"        .(mean(arr_delay), mean(dep_delay)),\n"
"        by = .(origin, dest, month)]\n"
"ans\n"
msgstr ""
"ans <- flights[carrier == \"AA\",\n"
"        .(mean(arr_delay), mean(dep_delay)),\n"
"        by = .(origin, dest, month)]\n"
"ans\n"

#: fr/datatable-intro.Rmd.tmp:block 120 (code)
msgid ""
"ans <- flights[carrier == \"AA\",\n"
"        .(mean(arr_delay), mean(dep_delay)),\n"
"        keyby = .(origin, dest, month)]\n"
"ans\n"
msgstr ""
"ans <- flights[carrier == \"AA\",\n"
"        .(mean(arr_delay), mean(dep_delay)),\n"
"        keyby = .(origin, dest, month)]\n"
"ans\n"

#: fr/datatable-intro.Rmd.tmp:block 126 (code)
msgid "ans <- flights[carrier == \"AA\", .N, by = .(origin, dest)]\n"
msgstr "ans <- flights[carrier == \"AA\", .N, by = .(origin, dest)]\n"

#: fr/datatable-intro.Rmd.tmp:block 129 (code)
msgid ""
"ans <- ans[order(origin, -dest)]\n"
"head(ans)\n"
msgstr ""
"ans <- ans[order(origin, -dest)]\n"
"head(ans)\n"

#: fr/datatable-intro.Rmd.tmp:block 132 (code)
msgid ""
"ans <- flights[carrier == \"AA\", .N, by = .(origin, dest)][order(origin, -"
"dest)]\n"
"head(ans, 10)\n"
msgstr ""
"ans <- flights[carrier == \"AA\", .N, by = .(origin, dest)][order(origin, -"
"dest)]\n"
"head(ans, 10)\n"

#: fr/datatable-intro.Rmd.tmp:block 137 (code)
msgid ""
"ans <- flights[, .N, .(dep_delay>0, arr_delay>0)]\n"
"ans\n"
msgstr ""
"ans <- flights[, .N, .(dep_delay>0, arr_delay>0)]\n"
"ans\n"

#: fr/datatable-intro.Rmd.tmp:block 147 (code)
msgid ""
"DT\n"
"\n"
"DT[, print(.SD), by = ID]\n"
msgstr ""
"DT\n"
"\n"
"DT[, print(.SD), by = ID]\n"

#: fr/datatable-intro.Rmd.tmp:block 150 (code)
msgid "DT[, lapply(.SD, mean), by = ID]\n"
msgstr "DT[, lapply(.SD, mean), by = ID]\n"

#: fr/datatable-intro.Rmd.tmp:block 158 (code)
msgid ""
"flights[carrier == \"AA\",                       ## Only on trips with "
"carrier \"AA\"\n"
"        lapply(.SD, mean),                     ## compute the mean\n"
"        by = .(origin, dest, month),           ## for every 'origin,dest,"
"month'\n"
"        .SDcols = c(\"arr_delay\", \"dep_delay\")] ## for just those "
"specified in .SDcols\n"
msgstr ""
"flights[carrier == \"AA\",                       ## Seulement les vols sur "
"porteurs \"AA\"\n"
"        lapply(.SD, mean),                     ## calcule la moyenne\n"
"        by = .(origin, dest, month),           ## pour chaque 'origin,dest,"
"month'\n"
"        .SDcols = c(\"arr_delay\", \"dep_delay\")] ## pour seulement ceux "
"spécifiés dans .SDcols\n"

#: fr/datatable-intro.Rmd.tmp:block 161 (code)
msgid ""
"ans <- flights[, head(.SD, 2), by = month]\n"
"head(ans)\n"
msgstr ""
"ans <- flights[, head(.SD, 2), by = month]\n"
"head(ans)\n"

#: fr/datatable-intro.Rmd.tmp:block 166 (code)
msgid "DT[, .(val = c(a,b)), by = ID]\n"
msgstr "DT[, .(val = c(a,b)), by = ID]\n"

#: fr/datatable-intro.Rmd.tmp:block 169 (code)
msgid "DT[, .(val = list(c(a,b))), by = ID]\n"
msgstr "DT[, .(val = list(c(a,b))), by = ID]\n"

#: fr/datatable-intro.Rmd.tmp:block 173 (code)
msgid ""
"## look at the difference between\n"
"DT[, print(c(a,b)), by = ID] # (1)\n"
"\n"
"## and\n"
"DT[, print(list(c(a,b))), by = ID] # (2)\n"
msgstr ""
"## inspectez la différence entre\n"
"DT[, print(c(a,b)), by = ID] # (1)\n"
"\n"
"## et\n"
"DT[, print(list(c(a,b))), by = ID] # (2)\n"

#: fr/datatable-intro.Rmd.tmp:block 177 (code)
msgid ""
"# Chunk args: r eval = FALSE\n"
"DT[i, j, by]\n"
msgstr ""
"# Chunk args: r eval = FALSE\n"
"DT[i, j, by]\n"

#: fr/datatable-intro.Rmd.tmp:block 189 (code)
msgid ""
"# Chunk args: r, echo=FALSE\n"
"setDTthreads(.old.th)\n"
msgstr ""
"# Chunk args: r, echo=FALSE\n"
"setDTthreads(.old.th)\n"

#: fr/datatable-intro.Rmd.tmp:block 98 (unordered list)
msgid ""
"# Chunk args: r eval = FALSE\n"
"## not run\n"
"\n"
"# returns all columns except arr_delay and dep_delay\n"
"ans <- flights[, !c(\"arr_delay\", \"dep_delay\")]\n"
"# or\n"
"ans <- flights[, -c(\"arr_delay\", \"dep_delay\")]\n"
msgstr ""
"# Chunk args: r eval = FALSE\n"
"## non exécuté\n"
"\n"
"# renvoie toutes le colonnes excepté arr_delay et dep_delay\n"
"ans <- flights[, !c(\"arr_delay\", \"dep_delay\")]\n"
"# ou\n"
"ans <- flights[, -c(\"arr_delay\", \"dep_delay\")]\n"

#: fr/datatable-intro.Rmd.tmp:block 98 (unordered list)
msgid ""
"# Chunk args: r eval = FALSE\n"
"## not run\n"
"\n"
"# returns year,month and day\n"
"ans <- flights[, year:day]\n"
"# returns day, month and year\n"
"ans <- flights[, day:year]\n"
"# returns all columns except year, month and day\n"
"ans <- flights[, -(year:day)]\n"
"ans <- flights[, !(year:day)]\n"
msgstr ""
"# Chunk args: r eval = FALSE\n"
"## non exécuté\n"
"\n"
"# renvoie year,month et day\n"
"ans <- flights[, year:day]\n"
"# renvoie day, month et year\n"
"ans <- flights[, day:year]\n"
"# renvoie toutes les colonnes excepté year, month et day\n"
"ans <- flights[, -(year:day)]\n"
"ans <- flights[, !(year:day)]\n"

#: fr/datatable-intro.Rmd.tmp:block 133 (unordered list)
msgid ""
"# Chunk args: r eval = FALSE\n"
"DT[ ...\n"
"   ][ ...\n"
"     ][ ...\n"
"       ]\n"
msgstr ""
"# Chunk args: r eval = FALSE\n"
"DT[ ...\n"
"   ][ ...\n"
"     ][ ...\n"
"       ]\n"
